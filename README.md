/*! For license information please see vendors.e9380a7a55d375999a06.js.LICENSE.txt */
!function() {
    try {
        var t = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}
          , e = (new Error).stack;
        e && (t._sentryDebugIds = t._sentryDebugIds || {},
        t._sentryDebugIds[e] = "38ac5505-b6e9-4fa5-b096-aa842e169152",
        t._sentryDebugIdIdentifier = "sentry-dbid-38ac5505-b6e9-4fa5-b096-aa842e169152")
    } catch (t) {}
}(),
(self.webpackChunk = self.webpackChunk || []).push([[216], {
    85509: function(t, e, r) {
        "use strict";
        r.d(e, {
            S1: function() {
                return Re
            }
        });
        var n = r(12343)
          , i = r(62844)
          , s = r(57321);
        const o = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/]
          , a = [/^.*healthcheck.*$/, /^.*healthy.*$/, /^.*live.*$/, /^.*ready.*$/, /^.*heartbeat.*$/, /^.*\/health$/, /^.*\/healthz$/];
        class h {
            static __initStatic() {
                this.id = "InboundFilters"
            }
            constructor(t={}) {
                this.name = h.id,
                this._options = t
            }
            setupOnce(t, e) {
                const r = t => {
                    const r = e();
                    if (r) {
                        const e = r.getIntegration(h);
                        if (e) {
                            const h = r.getClient()
                              , u = h ? h.getOptions() : {}
                              , c = function(t={}, e={}) {
                                return {
                                    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
                                    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
                                    ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...t.disableErrorDefaults ? [] : o],
                                    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || [], ...t.disableTransactionDefaults ? [] : a],
                                    ignoreInternal: void 0 === t.ignoreInternal || t.ignoreInternal
                                }
                            }(e._options, u);
                            return function(t, e) {
                                return e.ignoreInternal && function(t) {
                                    try {
                                        return "SentryError" === t.exception.values[0].type
                                    } catch (t) {}
                                    return !1
                                }(t) ? (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${(0,
                                i.jH)(t)}`),
                                !0) : function(t, e) {
                                    return !(t.type || !e || !e.length) && function(t) {
                                        if (t.message)
                                            return [t.message];
                                        if (t.exception) {
                                            const {values: e} = t.exception;
                                            try {
                                                const {type: t="", value: r=""} = e && e[e.length - 1] || {};
                                                return [`${r}`, `${t}: ${r}`]
                                            } catch (e) {
                                                return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.error(`Cannot extract message for event ${(0,
                                                i.jH)(t)}`),
                                                []
                                            }
                                        }
                                        return []
                                    }(t).some((t => (0,
                                    s.U0)(t, e)))
                                }(t, e.ignoreErrors) ? (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${(0,
                                i.jH)(t)}`),
                                !0) : function(t, e) {
                                    if ("transaction" !== t.type || !e || !e.length)
                                        return !1;
                                    const r = t.transaction;
                                    return !!r && (0,
                                    s.U0)(r, e)
                                }(t, e.ignoreTransactions) ? (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${(0,
                                i.jH)(t)}`),
                                !0) : function(t, e) {
                                    if (!e || !e.length)
                                        return !1;
                                    const r = l(t);
                                    return !!r && (0,
                                    s.U0)(r, e)
                                }(t, e.denyUrls) ? (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${(0,
                                i.jH)(t)}.\nUrl: ${l(t)}`),
                                !0) : !function(t, e) {
                                    if (!e || !e.length)
                                        return !0;
                                    const r = l(t);
                                    return !r || (0,
                                    s.U0)(r, e)
                                }(t, e.allowUrls) && (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${(0,
                                i.jH)(t)}.\nUrl: ${l(t)}`),
                                !0)
                            }(t, c) ? null : t
                        }
                    }
                    return t
                }
                ;
                r.id = this.name,
                t(r)
            }
        }
        function l(t) {
            try {
                let e;
                try {
                    e = t.exception.values[0].stacktrace.frames
                } catch (t) {}
                return e ? function(t=[]) {
                    for (let e = t.length - 1; e >= 0; e--) {
                        const r = t[e];
                        if (r && "<anonymous>" !== r.filename && "[native code]" !== r.filename)
                            return r.filename || null
                    }
                    return null
                }(e) : null
            } catch (e) {
                return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.error(`Cannot extract url for event ${(0,
                i.jH)(t)}`),
                null
            }
        }
        h.__initStatic();
        var u = r(20535);
        let c;
        class d {
            static __initStatic() {
                this.id = "FunctionToString"
            }
            constructor() {
                this.name = d.id
            }
            setupOnce() {
                c = Function.prototype.toString;
                try {
                    Function.prototype.toString = function(...t) {
                        const e = (0,
                        u.HK)(this) || this;
                        return c.apply(e, t)
                    }
                } catch (t) {}
            }
        }
        d.__initStatic();
        var f = r(95659)
          , p = r(10350);
        const m = [];
        function g(t) {
            const e = t.defaultIntegrations || []
              , r = t.integrations;
            let n;
            e.forEach((t => {
                t.isDefaultInstance = !0
            }
            )),
            n = Array.isArray(r) ? [...e, ...r] : "function" == typeof r ? (0,
            i.lE)(r(e)) : e;
            const s = function(t) {
                const e = {};
                return t.forEach((t => {
                    const {name: r} = t
                      , n = e[r];
                    n && !n.isDefaultInstance && t.isDefaultInstance || (e[r] = t)
                }
                )),
                Object.keys(e).map((t => e[t]))
            }(n)
              , o = function(t, e) {
                for (let e = 0; e < t.length; e++)
                    if (!0 == ("Debug" === t[e].name))
                        return e;
                return -1
            }(s);
            if (-1 !== o) {
                const [t] = s.splice(o, 1);
                s.push(t)
            }
            return s
        }
        function v(t, e) {
            e[t.name] = t,
            -1 === m.indexOf(t.name) && (t.setupOnce(p.c, f.Gd),
            m.push(t.name),
            ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.log(`Integration installed: ${t.name}`))
        }
        const y = 50
          , _ = /\(error: (.*)\)/
          , x = /captureMessage|captureException/;
        function b(...t) {
            const e = t.sort(( (t, e) => t[0] - e[0])).map((t => t[1]));
            return (t, r=0) => {
                const n = []
                  , i = t.split("\n");
                for (let t = r; t < i.length; t++) {
                    const r = i[t];
                    if (r.length > 1024)
                        continue;
                    const s = _.test(r) ? r.replace(_, "$1") : r;
                    if (!s.match(/\S*Error: /)) {
                        for (const t of e) {
                            const e = t(s);
                            if (e) {
                                n.push(e);
                                break
                            }
                        }
                        if (n.length >= y)
                            break
                    }
                }
                return function(t) {
                    if (!t.length)
                        return [];
                    const e = Array.from(t);
                    return /sentryWrapped/.test(e[e.length - 1].function || "") && e.pop(),
                    e.reverse(),
                    x.test(e[e.length - 1].function || "") && (e.pop(),
                    x.test(e[e.length - 1].function || "") && e.pop()),
                    e.slice(0, y).map((t => ({
                        ...t,
                        filename: t.filename || e[e.length - 1].filename,
                        function: t.function || "?"
                    })))
                }(n)
            }
        }
        const E = "<anonymous>";
        function T(t) {
            try {
                return t && "function" == typeof t && t.name || E
            } catch (t) {
                return E
            }
        }
        var w = r(71235);
        const S = (0,
        w.Rf)();
        function A() {
            if (!("fetch"in S))
                return !1;
            try {
                return new Headers,
                new Request("http://www.example.com"),
                new Response,
                !0
            } catch (t) {
                return !1
            }
        }
        function C(t) {
            return t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
        }
        var R = r(67597);
        const P = (0,
        w.Rf)()
          , I = (0,
        w.Rf)()
          , M = "__sentry_xhr_v2__"
          , D = {}
          , O = {};
        function B(t, e) {
            D[t] = D[t] || [],
            D[t].push(e),
            function(t) {
                if (!O[t])
                    switch (O[t] = !0,
                    t) {
                    case "console":
                        "console"in I && n.RU.forEach((function(t) {
                            t in I.console && (0,
                            u.hl)(I.console, t, (function(e) {
                                return function(...r) {
                                    k("console", {
                                        args: r,
                                        level: t
                                    }),
                                    e && e.apply(I.console, r)
                                }
                            }
                            ))
                        }
                        ));
                        break;
                    case "dom":
                        !function() {
                            if (!("document"in I))
                                return;
                            const t = k.bind(null, "dom")
                              , e = z(t, !0);
                            I.document.addEventListener("click", e, !1),
                            I.document.addEventListener("keypress", e, !1),
                            ["EventTarget", "Node"].forEach((e => {
                                const r = I[e] && I[e].prototype;
                                r && r.hasOwnProperty && r.hasOwnProperty("addEventListener") && ((0,
                                u.hl)(r, "addEventListener", (function(e) {
                                    return function(r, n, i) {
                                        if ("click" === r || "keypress" == r)
                                            try {
                                                const n = this
                                                  , s = n.__sentry_instrumentation_handlers__ = n.__sentry_instrumentation_handlers__ || {}
                                                  , o = s[r] = s[r] || {
                                                    refCount: 0
                                                };
                                                if (!o.handler) {
                                                    const n = z(t);
                                                    o.handler = n,
                                                    e.call(this, r, n, i)
                                                }
                                                o.refCount++
                                            } catch (t) {}
                                        return e.call(this, r, n, i)
                                    }
                                }
                                )),
                                (0,
                                u.hl)(r, "removeEventListener", (function(t) {
                                    return function(e, r, n) {
                                        if ("click" === e || "keypress" == e)
                                            try {
                                                const r = this
                                                  , i = r.__sentry_instrumentation_handlers__ || {}
                                                  , s = i[e];
                                                s && (s.refCount--,
                                                s.refCount <= 0 && (t.call(this, e, s.handler, n),
                                                s.handler = void 0,
                                                delete i[e]),
                                                0 === Object.keys(i).length && delete r.__sentry_instrumentation_handlers__)
                                            } catch (t) {}
                                        return t.call(this, e, r, n)
                                    }
                                }
                                )))
                            }
                            ))
                        }();
                        break;
                    case "xhr":
                        !function() {
                            if (!("XMLHttpRequest"in I))
                                return;
                            const t = XMLHttpRequest.prototype;
                            (0,
                            u.hl)(t, "open", (function(t) {
                                return function(...e) {
                                    const r = e[1]
                                      , n = this[M] = {
                                        method: (0,
                                        R.HD)(e[0]) ? e[0].toUpperCase() : e[0],
                                        url: e[1],
                                        request_headers: {}
                                    };
                                    (0,
                                    R.HD)(r) && "POST" === n.method && r.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
                                    const i = () => {
                                        const t = this[M];
                                        if (t && 4 === this.readyState) {
                                            try {
                                                t.status_code = this.status
                                            } catch (t) {}
                                            k("xhr", {
                                                args: e,
                                                endTimestamp: Date.now(),
                                                startTimestamp: Date.now(),
                                                xhr: this
                                            })
                                        }
                                    }
                                    ;
                                    return "onreadystatechange"in this && "function" == typeof this.onreadystatechange ? (0,
                                    u.hl)(this, "onreadystatechange", (function(t) {
                                        return function(...e) {
                                            return i(),
                                            t.apply(this, e)
                                        }
                                    }
                                    )) : this.addEventListener("readystatechange", i),
                                    (0,
                                    u.hl)(this, "setRequestHeader", (function(t) {
                                        return function(...e) {
                                            const [r,n] = e
                                              , i = this[M];
                                            return i && (i.request_headers[r.toLowerCase()] = n),
                                            t.apply(this, e)
                                        }
                                    }
                                    )),
                                    t.apply(this, e)
                                }
                            }
                            )),
                            (0,
                            u.hl)(t, "send", (function(t) {
                                return function(...e) {
                                    const r = this[M];
                                    return r && void 0 !== e[0] && (r.body = e[0]),
                                    k("xhr", {
                                        args: e,
                                        startTimestamp: Date.now(),
                                        xhr: this
                                    }),
                                    t.apply(this, e)
                                }
                            }
                            ))
                        }();
                        break;
                    case "fetch":
                        (function() {
                            if (!A())
                                return !1;
                            if (C(S.fetch))
                                return !0;
                            let t = !1;
                            const e = S.document;
                            if (e && "function" == typeof e.createElement)
                                try {
                                    const r = e.createElement("iframe");
                                    r.hidden = !0,
                                    e.head.appendChild(r),
                                    r.contentWindow && r.contentWindow.fetch && (t = C(r.contentWindow.fetch)),
                                    e.head.removeChild(r)
                                } catch (t) {
                                    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", t)
                                }
                            return t
                        }
                        )() && (0,
                        u.hl)(I, "fetch", (function(t) {
                            return function(...e) {
                                const {method: r, url: n} = function(t) {
                                    if (0 === t.length)
                                        return {
                                            method: "GET",
                                            url: ""
                                        };
                                    if (2 === t.length) {
                                        const [e,r] = t;
                                        return {
                                            url: N(e),
                                            method: L(r, "method") ? String(r.method).toUpperCase() : "GET"
                                        }
                                    }
                                    const e = t[0];
                                    return {
                                        url: N(e),
                                        method: L(e, "method") ? String(e.method).toUpperCase() : "GET"
                                    }
                                }(e)
                                  , i = {
                                    args: e,
                                    fetchData: {
                                        method: r,
                                        url: n
                                    },
                                    startTimestamp: Date.now()
                                };
                                return k("fetch", {
                                    ...i
                                }),
                                t.apply(I, e).then((t => (k("fetch", {
                                    ...i,
                                    endTimestamp: Date.now(),
                                    response: t
                                }),
                                t)), (t => {
                                    throw k("fetch", {
                                        ...i,
                                        endTimestamp: Date.now(),
                                        error: t
                                    }),
                                    t
                                }
                                ))
                            }
                        }
                        ));
                        break;
                    case "history":
                        !function() {
                            if (!function() {
                                const t = P.chrome
                                  , e = t && t.app && t.app.runtime
                                  , r = "history"in P && !!P.history.pushState && !!P.history.replaceState;
                                return !e && r
                            }())
                                return;
                            const t = I.onpopstate;
                            function e(t) {
                                return function(...e) {
                                    const r = e.length > 2 ? e[2] : void 0;
                                    if (r) {
                                        const t = F
                                          , e = String(r);
                                        F = e,
                                        k("history", {
                                            from: t,
                                            to: e
                                        })
                                    }
                                    return t.apply(this, e)
                                }
                            }
                            I.onpopstate = function(...e) {
                                const r = I.location.href
                                  , n = F;
                                if (F = r,
                                k("history", {
                                    from: n,
                                    to: r
                                }),
                                t)
                                    try {
                                        return t.apply(this, e)
                                    } catch (t) {}
                            }
                            ,
                            (0,
                            u.hl)(I.history, "pushState", e),
                            (0,
                            u.hl)(I.history, "replaceState", e)
                        }();
                        break;
                    case "error":
                        H = I.onerror,
                        I.onerror = function(t, e, r, n, i) {
                            return k("error", {
                                column: n,
                                error: i,
                                line: r,
                                msg: t,
                                url: e
                            }),
                            !(!H || H.__SENTRY_LOADER__) && H.apply(this, arguments)
                        }
                        ,
                        I.onerror.__SENTRY_INSTRUMENTED__ = !0;
                        break;
                    case "unhandledrejection":
                        $ = I.onunhandledrejection,
                        I.onunhandledrejection = function(t) {
                            return k("unhandledrejection", t),
                            !($ && !$.__SENTRY_LOADER__) || $.apply(this, arguments)
                        }
                        ,
                        I.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
                        break;
                    default:
                        ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn("unknown instrumentation type:", t)
                    }
            }(t)
        }
        function k(t, e) {
            if (t && D[t])
                for (const r of D[t] || [])
                    try {
                        r(e)
                    } catch (e) {
                        ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.error(`Error while triggering instrumentation handler.\nType: ${t}\nName: ${T(r)}\nError:`, e)
                    }
        }
        function L(t, e) {
            return !!t && "object" == typeof t && !!t[e]
        }
        function N(t) {
            return "string" == typeof t ? t : t ? L(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
        }
        let F;
        const U = 1e3;
        let G, j;
        function z(t, e=!1) {
            return r => {
                if (!r || j === r)
                    return;
                if (function(t) {
                    if ("keypress" !== t.type)
                        return !1;
                    try {
                        const e = t.target;
                        if (!e || !e.tagName)
                            return !0;
                        if ("INPUT" === e.tagName || "TEXTAREA" === e.tagName || e.isContentEditable)
                            return !1
                    } catch (t) {}
                    return !0
                }(r))
                    return;
                const n = "keypress" === r.type ? "input" : r.type;
                (void 0 === G || function(t, e) {
                    if (!t)
                        return !0;
                    if (t.type !== e.type)
                        return !0;
                    try {
                        if (t.target !== e.target)
                            return !0
                    } catch (t) {}
                    return !1
                }(j, r)) && (t({
                    event: r,
                    name: n,
                    global: e
                }),
                j = r),
                clearTimeout(G),
                G = I.setTimeout(( () => {
                    G = void 0
                }
                ), U)
            }
        }
        let H = null
          , $ = null;
        const X = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
        function V(t, e=!1) {
            const {host: r, path: n, pass: i, port: s, projectId: o, protocol: a, publicKey: h} = t;
            return `${a}://${h}${e && i ? `:${i}` : ""}@${r}${s ? `:${s}` : ""}/${n ? `${n}/` : n}${o}`
        }
        function W(t) {
            return {
                protocol: t.protocol,
                publicKey: t.publicKey || "",
                pass: t.pass || "",
                host: t.host,
                port: t.port || "",
                path: t.path || "",
                projectId: t.projectId
            }
        }
        var Y = r(96893);
        function q(t, e=100, r=1 / 0) {
            try {
                return Z("", t, e, r)
            } catch (t) {
                return {
                    ERROR: `**non-serializable** (${t})`
                }
            }
        }
        function K(t, e=3, r=102400) {
            const n = q(t, e);
            return i = n,
            function(t) {
                return ~-encodeURI(t).split(/%..|./).length
            }(JSON.stringify(i)) > r ? K(t, e - 1, r) : n;
            var i
        }
        function Z(t, e, n=1 / 0, i=1 / 0, s=function() {
            const t = "function" == typeof WeakSet
              , e = t ? new WeakSet : [];
            return [function(r) {
                if (t)
                    return !!e.has(r) || (e.add(r),
                    !1);
                for (let t = 0; t < e.length; t++)
                    if (e[t] === r)
                        return !0;
                return e.push(r),
                !1
            }
            , function(r) {
                if (t)
                    e.delete(r);
                else
                    for (let t = 0; t < e.length; t++)
                        if (e[t] === r) {
                            e.splice(t, 1);
                            break
                        }
            }
            ]
        }()) {
            const [o,a] = s;
            if (null == e || ["number", "boolean", "string"].includes(typeof e) && !(0,
            R.i2)(e))
                return e;
            const h = function(t, e) {
                try {
                    if ("domain" === t && e && "object" == typeof e && e._events)
                        return "[Domain]";
                    if ("domainEmitter" === t)
                        return "[DomainEmitter]";
                    if (void 0 !== r.g && e === r.g)
                        return "[Global]";
                    if ("undefined" != typeof window && e === window)
                        return "[Window]";
                    if ("undefined" != typeof document && e === document)
                        return "[Document]";
                    if ((0,
                    R.Cy)(e))
                        return "[SyntheticEvent]";
                    if ("number" == typeof e && e != e)
                        return "[NaN]";
                    if ("function" == typeof e)
                        return `[Function: ${T(e)}]`;
                    if ("symbol" == typeof e)
                        return `[${String(e)}]`;
                    if ("bigint" == typeof e)
                        return `[BigInt: ${String(e)}]`;
                    const n = function(t) {
                        const e = Object.getPrototypeOf(t);
                        return e ? e.constructor.name : "null prototype"
                    }(e);
                    return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
                } catch (t) {
                    return `**non-serializable** (${t})`
                }
            }(t, e);
            if (!h.startsWith("[object "))
                return h;
            if (e.__sentry_skip_normalization__)
                return e;
            const l = "number" == typeof e.__sentry_override_normalization_depth__ ? e.__sentry_override_normalization_depth__ : n;
            if (0 === l)
                return h.replace("object ", "");
            if (o(e))
                return "[Circular ~]";
            const c = e;
            if (c && "function" == typeof c.toJSON)
                try {
                    return Z("", c.toJSON(), l - 1, i, s)
                } catch (t) {}
            const d = Array.isArray(e) ? [] : {};
            let f = 0;
            const p = (0,
            u.Sh)(e);
            for (const t in p) {
                if (!Object.prototype.hasOwnProperty.call(p, t))
                    continue;
                if (f >= i) {
                    d[t] = "[MaxProperties ~]";
                    break
                }
                const e = p[t];
                d[t] = Z(t, e, l - 1, i, s),
                f++
            }
            return a(e),
            d
        }
        function J(t, e=[]) {
            return [t, e]
        }
        function Q(t, e) {
            const [r,n] = t;
            return [r, [...n, e]]
        }
        function tt(t, e) {
            const r = t[1];
            for (const t of r)
                if (e(t, t[0].type))
                    return !0;
            return !1
        }
        function et(t, e) {
            return (e || new TextEncoder).encode(t)
        }
        function rt(t, e) {
            const [r,n] = t;
            let i = JSON.stringify(r);
            function s(t) {
                "string" == typeof i ? i = "string" == typeof t ? i + t : [et(i, e), t] : i.push("string" == typeof t ? et(t, e) : t)
            }
            for (const t of n) {
                const [e,r] = t;
                if (s(`\n${JSON.stringify(e)}\n`),
                "string" == typeof r || r instanceof Uint8Array)
                    s(r);
                else {
                    let t;
                    try {
                        t = JSON.stringify(r)
                    } catch (e) {
                        t = JSON.stringify(q(r))
                    }
                    s(t)
                }
            }
            return "string" == typeof i ? i : function(t) {
                const e = t.reduce(( (t, e) => t + e.length), 0)
                  , r = new Uint8Array(e);
                let n = 0;
                for (const e of t)
                    r.set(e, n),
                    n += e.length;
                return r
            }(i)
        }
        function nt(t, e) {
            const r = "string" == typeof t.data ? et(t.data, e) : t.data;
            return [(0,
            u.Jr)({
                type: "attachment",
                length: r.length,
                filename: t.filename,
                content_type: t.contentType,
                attachment_type: t.attachmentType
            }), r]
        }
        const it = {
            session: "session",
            sessions: "session",
            attachment: "attachment",
            transaction: "transaction",
            event: "error",
            client_report: "internal",
            user_report: "default",
            profile: "profile",
            replay_event: "replay",
            replay_recording: "replay",
            check_in: "monitor"
        };
        function st(t) {
            return it[t]
        }
        function ot(t) {
            if (!t || !t.sdk)
                return;
            const {name: e, version: r} = t.sdk;
            return {
                name: e,
                version: r
            }
        }
        class at extends Error {
            constructor(t, e="warn") {
                super(t),
                this.message = t,
                this.name = new.target.prototype.constructor.name,
                Object.setPrototypeOf(this, new.target.prototype),
                this.logLevel = e
            }
        }
        var ht = r(9015)
          , lt = r(51131)
          , ut = r(21170);
        const ct = new WeakMap
          , dt = "Not capturing exception because it's already been captured.";
        class ft {
            constructor(t) {
                if (this._options = t,
                this._integrations = {},
                this._integrationsInitialized = !1,
                this._numProcessing = 0,
                this._outcomes = {},
                this._hooks = {},
                t.dsn ? this._dsn = function(t) {
                    const e = "string" == typeof t ? function(t) {
                        const e = X.exec(t);
                        if (!e)
                            return void console.error(`Invalid Sentry Dsn: ${t}`);
                        const [r,n,i="",s,o="",a] = e.slice(1);
                        let h = ""
                          , l = a;
                        const u = l.split("/");
                        if (u.length > 1 && (h = u.slice(0, -1).join("/"),
                        l = u.pop()),
                        l) {
                            const t = l.match(/^\d+/);
                            t && (l = t[0])
                        }
                        return W({
                            host: s,
                            pass: i,
                            path: h,
                            projectId: l,
                            port: o,
                            protocol: r,
                            publicKey: n
                        })
                    }(t) : W(t);
                    if (e && function(t) {
                        if ("undefined" != typeof __SENTRY_DEBUG__ && !__SENTRY_DEBUG__)
                            return !0;
                        const {port: e, projectId: r, protocol: i} = t;
                        return !(["protocol", "publicKey", "host", "projectId"].find((e => !t[e] && (n.kg.error(`Invalid Sentry Dsn: ${e} missing`),
                        !0))) || (r.match(/^\d+$/) ? function(t) {
                            return "http" === t || "https" === t
                        }(i) ? e && isNaN(parseInt(e, 10)) && (n.kg.error(`Invalid Sentry Dsn: Invalid port ${e}`),
                        1) : (n.kg.error(`Invalid Sentry Dsn: Invalid protocol ${i}`),
                        1) : (n.kg.error(`Invalid Sentry Dsn: Invalid projectId ${r}`),
                        1)))
                    }(e))
                        return e
                }(t.dsn) : ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn("No DSN provided, client will not do anything."),
                this._dsn) {
                    const e = function(t, e={}) {
                        const r = "string" == typeof e ? e : e.tunnel
                          , n = "string" != typeof e && e._metadata ? e._metadata.sdk : void 0;
                        return r || `${function(t) {
                            return `${function(t) {
                                const e = t.protocol ? `${t.protocol}:` : ""
                                  , r = t.port ? `:${t.port}` : "";
                                return `${e}//${t.host}${r}${t.path ? `/${t.path}` : ""}/api/`
                            }(t)}${t.projectId}/envelope/`
                        }(t)}?${function(t, e) {
                            return (0,
                            u._j)({
                                sentry_key: t.publicKey,
                                sentry_version: "7",
                                ...e && {
                                    sentry_client: `${e.name}/${e.version}`
                                }
                            })
                        }(t, n)}`
                    }(this._dsn, t);
                    this._transport = t.transport({
                        recordDroppedEvent: this.recordDroppedEvent.bind(this),
                        ...t.transportOptions,
                        url: e
                    })
                }
            }
            captureException(t, e, r) {
                if ((0,
                i.YO)(t))
                    return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.log(dt));
                let s = e && e.event_id;
                return this._process(this.eventFromException(t, e).then((t => this._captureEvent(t, e, r))).then((t => {
                    s = t
                }
                ))),
                s
            }
            captureMessage(t, e, r, n) {
                let i = r && r.event_id;
                const s = (0,
                R.pt)(t) ? this.eventFromMessage(String(t), e, r) : this.eventFromException(t, r);
                return this._process(s.then((t => this._captureEvent(t, r, n))).then((t => {
                    i = t
                }
                ))),
                i
            }
            captureEvent(t, e, r) {
                if (e && e.originalException && (0,
                i.YO)(e.originalException))
                    return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.log(dt));
                let s = e && e.event_id;
                return this._process(this._captureEvent(t, e, r).then((t => {
                    s = t
                }
                ))),
                s
            }
            captureSession(t) {
                this._isEnabled() ? "string" != typeof t.release ? ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn("Discarded session because of missing or non-string release") : (this.sendSession(t),
                (0,
                ht.CT)(t, {
                    init: !1
                })) : ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn("SDK not enabled, will not capture session.")
            }
            getDsn() {
                return this._dsn
            }
            getOptions() {
                return this._options
            }
            getSdkMetadata() {
                return this._options._metadata
            }
            getTransport() {
                return this._transport
            }
            flush(t) {
                const e = this._transport;
                return e ? this._isClientDoneProcessing(t).then((r => e.flush(t).then((t => r && t)))) : (0,
                Y.WD)(!0)
            }
            close(t) {
                return this.flush(t).then((t => (this.getOptions().enabled = !1,
                t)))
            }
            setupIntegrations() {
                this._isEnabled() && !this._integrationsInitialized && (this._integrations = function(t) {
                    const e = {};
                    return t.forEach((t => {
                        t && v(t, e)
                    }
                    )),
                    e
                }(this._options.integrations),
                this._integrationsInitialized = !0)
            }
            getIntegrationById(t) {
                return this._integrations[t]
            }
            getIntegration(t) {
                try {
                    return this._integrations[t.id] || null
                } catch (e) {
                    return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn(`Cannot retrieve integration ${t.id} from the current Client`),
                    null
                }
            }
            addIntegration(t) {
                v(t, this._integrations)
            }
            sendEvent(t, e={}) {
                if (this._dsn) {
                    let r = function(t, e, r, n) {
                        const i = ot(r)
                          , s = t.type && "replay_event" !== t.type ? t.type : "event";
                        !function(t, e) {
                            e && (t.sdk = t.sdk || {},
                            t.sdk.name = t.sdk.name || e.name,
                            t.sdk.version = t.sdk.version || e.version,
                            t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []],
                            t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []])
                        }(t, r && r.sdk);
                        const o = function(t, e, r, n) {
                            const i = t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
                            return {
                                event_id: t.event_id,
                                sent_at: (new Date).toISOString(),
                                ...e && {
                                    sdk: e
                                },
                                ...!!r && {
                                    dsn: V(n)
                                },
                                ...i && {
                                    trace: (0,
                                    u.Jr)({
                                        ...i
                                    })
                                }
                            }
                        }(t, i, n, e);
                        return delete t.sdkProcessingMetadata,
                        J(o, [[{
                            type: s
                        }, t]])
                    }(t, this._dsn, this._options._metadata, this._options.tunnel);
                    for (const t of e.attachments || [])
                        r = Q(r, nt(t, this._options.transportOptions && this._options.transportOptions.textEncoder));
                    const n = this._sendEnvelope(r);
                    n && n.then((e => this.emit("afterSendEvent", t, e)), null)
                }
            }
            sendSession(t) {
                if (this._dsn) {
                    const e = function(t, e, r, n) {
                        const i = ot(r);
                        return J({
                            sent_at: (new Date).toISOString(),
                            ...i && {
                                sdk: i
                            },
                            ...!!n && {
                                dsn: V(e)
                            }
                        }, ["aggregates"in t ? [{
                            type: "sessions"
                        }, t] : [{
                            type: "session"
                        }, t.toJSON()]])
                    }(t, this._dsn, this._options._metadata, this._options.tunnel);
                    this._sendEnvelope(e)
                }
            }
            recordDroppedEvent(t, e, r) {
                if (this._options.sendClientReports) {
                    const r = `${t}:${e}`;
                    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.log(`Adding outcome: "${r}"`),
                    this._outcomes[r] = this._outcomes[r] + 1 || 1
                }
            }
            on(t, e) {
                this._hooks[t] || (this._hooks[t] = []),
                this._hooks[t].push(e)
            }
            emit(t, ...e) {
                this._hooks[t] && this._hooks[t].forEach((t => t(...e)))
            }
            _updateSessionFromEvent(t, e) {
                let r = !1
                  , n = !1;
                const i = e.exception && e.exception.values;
                if (i) {
                    n = !0;
                    for (const t of i) {
                        const e = t.mechanism;
                        if (e && !1 === e.handled) {
                            r = !0;
                            break
                        }
                    }
                }
                const s = "ok" === t.status;
                (s && 0 === t.errors || s && r) && ((0,
                ht.CT)(t, {
                    ...r && {
                        status: "crashed"
                    },
                    errors: t.errors || Number(n || r)
                }),
                this.captureSession(t))
            }
            _isClientDoneProcessing(t) {
                return new Y.cW((e => {
                    let r = 0;
                    const n = setInterval(( () => {
                        0 == this._numProcessing ? (clearInterval(n),
                        e(!0)) : (r += 1,
                        t && r >= t && (clearInterval(n),
                        e(!1)))
                    }
                    ), 1)
                }
                ))
            }
            _isEnabled() {
                return !1 !== this.getOptions().enabled && void 0 !== this._dsn
            }
            _prepareEvent(t, e, r) {
                const n = this.getOptions()
                  , o = Object.keys(this._integrations);
                return !e.integrations && o.length > 0 && (e.integrations = o),
                function(t, e, r, n) {
                    const {normalizeDepth: o=3, normalizeMaxBreadth: a=1e3} = t
                      , h = {
                        ...e,
                        event_id: e.event_id || r.event_id || (0,
                        i.DM)(),
                        timestamp: e.timestamp || (0,
                        ut.yW)()
                    }
                      , l = r.integrations || t.integrations.map((t => t.name));
                    !function(t, e) {
                        const {environment: r, release: n, dist: i, maxValueLength: o=250} = e;
                        "environment"in t || (t.environment = "environment"in e ? r : lt.J),
                        void 0 === t.release && void 0 !== n && (t.release = n),
                        void 0 === t.dist && void 0 !== i && (t.dist = i),
                        t.message && (t.message = (0,
                        s.$G)(t.message, o));
                        const a = t.exception && t.exception.values && t.exception.values[0];
                        a && a.value && (a.value = (0,
                        s.$G)(a.value, o));
                        const h = t.request;
                        h && h.url && (h.url = (0,
                        s.$G)(h.url, o))
                    }(h, t),
                    function(t, e) {
                        e.length > 0 && (t.sdk = t.sdk || {},
                        t.sdk.integrations = [...t.sdk.integrations || [], ...e])
                    }(h, l),
                    void 0 === e.type && function(t, e) {
                        const r = w.n2._sentryDebugIds;
                        if (!r)
                            return;
                        let n;
                        const i = ct.get(e);
                        i ? n = i : (n = new Map,
                        ct.set(e, n));
                        const s = Object.keys(r).reduce(( (t, i) => {
                            let s;
                            const o = n.get(i);
                            o ? s = o : (s = e(i),
                            n.set(i, s));
                            for (let e = s.length - 1; e >= 0; e--) {
                                const n = s[e];
                                if (n.filename) {
                                    t[n.filename] = r[i];
                                    break
                                }
                            }
                            return t
                        }
                        ), {});
                        try {
                            t.exception.values.forEach((t => {
                                t.stacktrace.frames.forEach((t => {
                                    t.filename && (t.debug_id = s[t.filename])
                                }
                                ))
                            }
                            ))
                        } catch (t) {}
                    }(h, t.stackParser);
                    let u = n;
                    r.captureContext && (u = p.s.clone(u).update(r.captureContext));
                    let c = (0,
                    Y.WD)(h);
                    if (u) {
                        if (u.getAttachments) {
                            const t = [...r.attachments || [], ...u.getAttachments()];
                            t.length && (r.attachments = t)
                        }
                        c = u.applyToEvent(h, r)
                    }
                    return c.then((t => (t && function(t) {
                        const e = {};
                        try {
                            t.exception.values.forEach((t => {
                                t.stacktrace.frames.forEach((t => {
                                    t.debug_id && (t.abs_path ? e[t.abs_path] = t.debug_id : t.filename && (e[t.filename] = t.debug_id),
                                    delete t.debug_id)
                                }
                                ))
                            }
                            ))
                        } catch (t) {}
                        if (0 === Object.keys(e).length)
                            return;
                        t.debug_meta = t.debug_meta || {},
                        t.debug_meta.images = t.debug_meta.images || [];
                        const r = t.debug_meta.images;
                        Object.keys(e).forEach((t => {
                            r.push({
                                type: "sourcemap",
                                code_file: t,
                                debug_id: e[t]
                            })
                        }
                        ))
                    }(t),
                    "number" == typeof o && o > 0 ? function(t, e, r) {
                        if (!t)
                            return null;
                        const n = {
                            ...t,
                            ...t.breadcrumbs && {
                                breadcrumbs: t.breadcrumbs.map((t => ({
                                    ...t,
                                    ...t.data && {
                                        data: q(t.data, e, r)
                                    }
                                })))
                            },
                            ...t.user && {
                                user: q(t.user, e, r)
                            },
                            ...t.contexts && {
                                contexts: q(t.contexts, e, r)
                            },
                            ...t.extra && {
                                extra: q(t.extra, e, r)
                            }
                        };
                        return t.contexts && t.contexts.trace && n.contexts && (n.contexts.trace = t.contexts.trace,
                        t.contexts.trace.data && (n.contexts.trace.data = q(t.contexts.trace.data, e, r))),
                        t.spans && (n.spans = t.spans.map((t => (t.data && (t.data = q(t.data, e, r)),
                        t)))),
                        n
                    }(t, o, a) : t)))
                }(n, t, e, r).then((t => {
                    if (null === t)
                        return t;
                    const {propagationContext: e} = t.sdkProcessingMetadata || {};
                    if ((!t.contexts || !t.contexts.trace) && e) {
                        const {traceId: n, spanId: i, parentSpanId: s, dsc: o} = e;
                        t.contexts = {
                            trace: {
                                trace_id: n,
                                span_id: i,
                                parent_span_id: s
                            },
                            ...t.contexts
                        };
                        const a = o || function(t, e, r) {
                            const n = e.getOptions()
                              , {publicKey: i} = e.getDsn() || {}
                              , {segment: s} = r && r.getUser() || {}
                              , o = (0,
                            u.Jr)({
                                environment: n.environment || lt.J,
                                release: n.release,
                                user_segment: s,
                                public_key: i,
                                trace_id: t
                            });
                            return e.emit && e.emit("createDsc", o),
                            o
                        }(n, this, r);
                        t.sdkProcessingMetadata = {
                            dynamicSamplingContext: a,
                            ...t.sdkProcessingMetadata
                        }
                    }
                    return t
                }
                ))
            }
            _captureEvent(t, e={}, r) {
                return this._processEvent(t, e, r).then((t => t.event_id), (t => {
                    if ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) {
                        const e = t;
                        "log" === e.logLevel ? n.kg.log(e.message) : n.kg.warn(e)
                    }
                }
                ))
            }
            _processEvent(t, e, r) {
                const n = this.getOptions()
                  , {sampleRate: i} = n;
                if (!this._isEnabled())
                    return (0,
                    Y.$2)(new at("SDK not enabled, will not capture event.","log"));
                const s = mt(t)
                  , o = pt(t)
                  , a = t.type || "error"
                  , h = `before send for type \`${a}\``;
                if (o && "number" == typeof i && Math.random() > i)
                    return this.recordDroppedEvent("sample_rate", "error", t),
                    (0,
                    Y.$2)(new at(`Discarding event because it's not included in the random sample (sampling rate = ${i})`,"log"));
                const l = "replay_event" === a ? "replay" : a;
                return this._prepareEvent(t, e, r).then((r => {
                    if (null === r)
                        throw this.recordDroppedEvent("event_processor", l, t),
                        new at("An event processor returned `null`, will not send event.","log");
                    if (e.data && !0 === e.data.__sentry__)
                        return r;
                    const i = function(t, e, r) {
                        const {beforeSend: n, beforeSendTransaction: i} = t;
                        return pt(e) && n ? n(e, r) : mt(e) && i ? i(e, r) : e
                    }(n, r, e);
                    return function(t, e) {
                        const r = `${e} must return \`null\` or a valid event.`;
                        if ((0,
                        R.J8)(t))
                            return t.then((t => {
                                if (!(0,
                                R.PO)(t) && null !== t)
                                    throw new at(r);
                                return t
                            }
                            ), (t => {
                                throw new at(`${e} rejected with ${t}`)
                            }
                            ));
                        if (!(0,
                        R.PO)(t) && null !== t)
                            throw new at(r);
                        return t
                    }(i, h)
                }
                )).then((n => {
                    if (null === n)
                        throw this.recordDroppedEvent("before_send", l, t),
                        new at(`${h} returned \`null\`, will not send event.`,"log");
                    const i = r && r.getSession();
                    !s && i && this._updateSessionFromEvent(i, n);
                    const o = n.transaction_info;
                    if (s && o && n.transaction !== t.transaction) {
                        const t = "custom";
                        n.transaction_info = {
                            ...o,
                            source: t
                        }
                    }
                    return this.sendEvent(n, e),
                    n
                }
                )).then(null, (t => {
                    if (t instanceof at)
                        throw t;
                    throw this.captureException(t, {
                        data: {
                            __sentry__: !0
                        },
                        originalException: t
                    }),
                    new at(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${t}`)
                }
                ))
            }
            _process(t) {
                this._numProcessing++,
                t.then((t => (this._numProcessing--,
                t)), (t => (this._numProcessing--,
                t)))
            }
            _sendEnvelope(t) {
                if (this._transport && this._dsn)
                    return this.emit("beforeEnvelope", t),
                    this._transport.send(t).then(null, (t => {
                        ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.error("Error while sending event:", t)
                    }
                    ));
                ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.error("Transport disabled")
            }
            _clearOutcomes() {
                const t = this._outcomes;
                return this._outcomes = {},
                Object.keys(t).map((e => {
                    const [r,n] = e.split(":");
                    return {
                        reason: r,
                        category: n,
                        quantity: t[e]
                    }
                }
                ))
            }
        }
        function pt(t) {
            return void 0 === t.type
        }
        function mt(t) {
            return "transaction" === t.type
        }
        const gt = "7.64.0";
        var vt = r(68518);
        function yt(t, e) {
            const r = xt(t, e)
              , n = {
                type: e && e.name,
                value: Et(e)
            };
            return r.length && (n.stacktrace = {
                frames: r
            }),
            void 0 === n.type && "" === n.value && (n.value = "Unrecoverable error caught"),
            n
        }
        function _t(t, e) {
            return {
                exception: {
                    values: [yt(t, e)]
                }
            }
        }
        function xt(t, e) {
            const r = e.stacktrace || e.stack || ""
              , n = function(t) {
                if (t) {
                    if ("number" == typeof t.framesToPop)
                        return t.framesToPop;
                    if (bt.test(t.message))
                        return 1
                }
                return 0
            }(e);
            try {
                return t(r, n)
            } catch (t) {}
            return []
        }
        const bt = /Minified React error #\d+;/i;
        function Et(t) {
            const e = t && t.message;
            return e ? e.error && "string" == typeof e.error.message ? e.error.message : e : "No error message"
        }
        function Tt(t, e, r, n, s) {
            let o;
            if ((0,
            R.VW)(e) && e.error)
                return _t(t, e.error);
            if ((0,
            R.TX)(e) || (0,
            R.fm)(e)) {
                const s = e;
                if ("stack"in e)
                    o = _t(t, e);
                else {
                    const e = s.name || ((0,
                    R.TX)(s) ? "DOMError" : "DOMException")
                      , a = s.message ? `${e}: ${s.message}` : e;
                    o = wt(t, a, r, n),
                    (0,
                    i.Db)(o, a)
                }
                return "code"in s && (o.tags = {
                    ...o.tags,
                    "DOMException.code": `${s.code}`
                }),
                o
            }
            return (0,
            R.VZ)(e) ? _t(t, e) : (0,
            R.PO)(e) || (0,
            R.cO)(e) ? (o = function(t, e, r, n) {
                const i = (0,
                f.Gd)().getClient()
                  , s = i && i.getOptions().normalizeDepth
                  , o = {
                    exception: {
                        values: [{
                            type: (0,
                            R.cO)(e) ? e.constructor.name : n ? "UnhandledRejection" : "Error",
                            value: St(e, {
                                isUnhandledRejection: n
                            })
                        }]
                    },
                    extra: {
                        __serialized__: K(e, s)
                    }
                };
                if (r) {
                    const e = xt(t, r);
                    e.length && (o.exception.values[0].stacktrace = {
                        frames: e
                    })
                }
                return o
            }(t, e, r, s),
            (0,
            i.EG)(o, {
                synthetic: !0
            }),
            o) : (o = wt(t, e, r, n),
            (0,
            i.Db)(o, `${e}`, void 0),
            (0,
            i.EG)(o, {
                synthetic: !0
            }),
            o)
        }
        function wt(t, e, r, n) {
            const i = {
                message: e
            };
            if (n && r) {
                const n = xt(t, r);
                n.length && (i.exception = {
                    values: [{
                        value: e,
                        stacktrace: {
                            frames: n
                        }
                    }]
                })
            }
            return i
        }
        function St(t, {isUnhandledRejection: e}) {
            const r = (0,
            u.zf)(t)
              , n = e ? "promise rejection" : "exception";
            return (0,
            R.VW)(t) ? `Event \`ErrorEvent\` captured as ${n} with message \`${t.message}\`` : (0,
            R.cO)(t) ? `Event \`${function(t) {
                try {
                    const e = Object.getPrototypeOf(t);
                    return e ? e.constructor.name : void 0
                } catch (t) {}
            }(t)}\` (type=${t.type}) captured as ${n}` : `Object captured as ${n} with keys: ${r}`
        }
        var At = r(64487);
        const Ct = w.n2;
        let Rt = 0;
        function Pt() {
            return Rt > 0
        }
        function It(t, e={}, r) {
            if ("function" != typeof t)
                return t;
            try {
                const e = t.__sentry_wrapped__;
                if (e)
                    return e;
                if ((0,
                u.HK)(t))
                    return t
            } catch (e) {
                return t
            }
            const n = function() {
                const n = Array.prototype.slice.call(arguments);
                try {
                    r && "function" == typeof r && r.apply(this, arguments);
                    const i = n.map((t => It(t, e)));
                    return t.apply(this, i)
                } catch (t) {
                    throw Rt++,
                    setTimeout(( () => {
                        Rt--
                    }
                    )),
                    (0,
                    At.$e)((r => {
                        r.addEventProcessor((t => (e.mechanism && ((0,
                        i.Db)(t, void 0, void 0),
                        (0,
                        i.EG)(t, e.mechanism)),
                        t.extra = {
                            ...t.extra,
                            arguments: n
                        },
                        t))),
                        (0,
                        At.Tb)(t)
                    }
                    )),
                    t
                }
            };
            try {
                for (const e in t)
                    Object.prototype.hasOwnProperty.call(t, e) && (n[e] = t[e])
            } catch (t) {}
            (0,
            u.$Q)(n, t),
            (0,
            u.xp)(t, "__sentry_wrapped__", n);
            try {
                Object.getOwnPropertyDescriptor(n, "name").configurable && Object.defineProperty(n, "name", {
                    get() {
                        return t.name
                    }
                })
            } catch (t) {}
            return n
        }
        var Mt = r(58464);
        const Dt = ["fatal", "error", "warning", "log", "info", "debug"];
        function Ot(t) {
            if (!t)
                return {};
            const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
            if (!e)
                return {};
            const r = e[6] || ""
              , n = e[8] || "";
            return {
                host: e[4],
                path: e[5],
                protocol: e[2],
                search: r,
                hash: n,
                relative: e[5] + r + n
            }
        }
        const Bt = "Breadcrumbs";
        class kt {
            static __initStatic() {
                this.id = Bt
            }
            constructor(t) {
                this.name = kt.id,
                this.options = {
                    console: !0,
                    dom: !0,
                    fetch: !0,
                    history: !0,
                    sentry: !0,
                    xhr: !0,
                    ...t
                }
            }
            setupOnce() {
                var t;
                this.options.console && B("console", Lt),
                this.options.dom && B("dom", (t = this.options.dom,
                function(e) {
                    let r, i = "object" == typeof t ? t.serializeAttribute : void 0, s = "object" == typeof t && "number" == typeof t.maxStringLength ? t.maxStringLength : void 0;
                    s && s > 1024 && (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${s} was configured. Sentry will use 1024 instead.`),
                    s = 1024),
                    "string" == typeof i && (i = [i]);
                    try {
                        const t = e.event;
                        r = function(t) {
                            return !!t && !!t.target
                        }(t) ? (0,
                        Mt.Rt)(t.target, {
                            keyAttrs: i,
                            maxStringLength: s
                        }) : (0,
                        Mt.Rt)(t, {
                            keyAttrs: i,
                            maxStringLength: s
                        })
                    } catch (t) {
                        r = "<unknown>"
                    }
                    0 !== r.length && (0,
                    f.Gd)().addBreadcrumb({
                        category: `ui.${e.name}`,
                        message: r
                    }, {
                        event: e.event,
                        name: e.name,
                        global: e.global
                    })
                }
                )),
                this.options.xhr && B("xhr", Nt),
                this.options.fetch && B("fetch", Ft),
                this.options.history && B("history", Ut)
            }
            addSentryBreadcrumb(t) {
                this.options.sentry && (0,
                f.Gd)().addBreadcrumb({
                    category: "sentry." + ("transaction" === t.type ? "transaction" : "event"),
                    event_id: t.event_id,
                    level: t.level,
                    message: (0,
                    i.jH)(t)
                }, {
                    event: t
                })
            }
        }
        function Lt(t) {
            for (let e = 0; e < t.args.length; e++)
                if ("ref=Ref<" === t.args[e]) {
                    t.args[e + 1] = "viewRef";
                    break
                }
            const e = {
                category: "console",
                data: {
                    arguments: t.args,
                    logger: "console"
                },
                level: (r = t.level,
                "warn" === r ? "warning" : Dt.includes(r) ? r : "log"),
                message: (0,
                s.nK)(t.args, " ")
            };
            var r;
            if ("assert" === t.level) {
                if (!1 !== t.args[0])
                    return;
                e.message = `Assertion failed: ${(0,
                s.nK)(t.args.slice(1), " ") || "console.assert"}`,
                e.data.arguments = t.args.slice(1)
            }
            (0,
            f.Gd)().addBreadcrumb(e, {
                input: t.args,
                level: t.level
            })
        }
        function Nt(t) {
            const {startTimestamp: e, endTimestamp: r} = t
              , n = t.xhr[M];
            if (!e || !r || !n)
                return;
            const {method: i, url: s, status_code: o, body: a} = n
              , h = {
                method: i,
                url: s,
                status_code: o
            }
              , l = {
                xhr: t.xhr,
                input: a,
                startTimestamp: e,
                endTimestamp: r
            };
            (0,
            f.Gd)().addBreadcrumb({
                category: "xhr",
                data: h,
                type: "http"
            }, l)
        }
        function Ft(t) {
            const {startTimestamp: e, endTimestamp: r} = t;
            if (r && (!t.fetchData.url.match(/sentry_key/) || "POST" !== t.fetchData.method))
                if (t.error) {
                    const n = t.fetchData
                      , i = {
                        data: t.error,
                        input: t.args,
                        startTimestamp: e,
                        endTimestamp: r
                    };
                    (0,
                    f.Gd)().addBreadcrumb({
                        category: "fetch",
                        data: n,
                        level: "error",
                        type: "http"
                    }, i)
                } else {
                    const n = {
                        ...t.fetchData,
                        status_code: t.response && t.response.status
                    }
                      , i = {
                        input: t.args,
                        response: t.response,
                        startTimestamp: e,
                        endTimestamp: r
                    };
                    (0,
                    f.Gd)().addBreadcrumb({
                        category: "fetch",
                        data: n,
                        type: "http"
                    }, i)
                }
        }
        function Ut(t) {
            let e = t.from
              , r = t.to;
            const n = Ot(Ct.location.href);
            let i = Ot(e);
            const s = Ot(r);
            i.path || (i = n),
            n.protocol === s.protocol && n.host === s.host && (r = s.relative),
            n.protocol === i.protocol && n.host === i.host && (e = i.relative),
            (0,
            f.Gd)().addBreadcrumb({
                category: "navigation",
                data: {
                    from: e,
                    to: r
                }
            })
        }
        kt.__initStatic();
        class Gt extends ft {
            constructor(t) {
                const e = Ct.SENTRY_SDK_SOURCE || (0,
                vt.S)();
                t._metadata = t._metadata || {},
                t._metadata.sdk = t._metadata.sdk || {
                    name: "sentry.javascript.browser",
                    packages: [{
                        name: `${e}:@sentry/browser`,
                        version: gt
                    }],
                    version: gt
                },
                super(t),
                t.sendClientReports && Ct.document && Ct.document.addEventListener("visibilitychange", ( () => {
                    "hidden" === Ct.document.visibilityState && this._flushOutcomes()
                }
                ))
            }
            eventFromException(t, e) {
                return function(t, e, r, n) {
                    const s = Tt(t, e, r && r.syntheticException || void 0, n);
                    return (0,
                    i.EG)(s),
                    s.level = "error",
                    r && r.event_id && (s.event_id = r.event_id),
                    (0,
                    Y.WD)(s)
                }(this._options.stackParser, t, e, this._options.attachStacktrace)
            }
            eventFromMessage(t, e="info", r) {
                return function(t, e, r="info", n, i) {
                    const s = wt(t, e, n && n.syntheticException || void 0, i);
                    return s.level = r,
                    n && n.event_id && (s.event_id = n.event_id),
                    (0,
                    Y.WD)(s)
                }(this._options.stackParser, t, e, r, this._options.attachStacktrace)
            }
            sendEvent(t, e) {
                const r = this.getIntegrationById(Bt);
                r && r.addSentryBreadcrumb && r.addSentryBreadcrumb(t),
                super.sendEvent(t, e)
            }
            captureUserFeedback(t) {
                if (!this._isEnabled())
                    return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn("SDK not enabled, will not capture user feedback."));
                const e = function(t, {metadata: e, tunnel: r, dsn: n}) {
                    const i = {
                        event_id: t.event_id,
                        sent_at: (new Date).toISOString(),
                        ...e && e.sdk && {
                            sdk: {
                                name: e.sdk.name,
                                version: e.sdk.version
                            }
                        },
                        ...!!r && !!n && {
                            dsn: V(n)
                        }
                    }
                      , s = function(t) {
                        return [{
                            type: "user_report"
                        }, t]
                    }(t);
                    return J(i, [s])
                }(t, {
                    metadata: this.getSdkMetadata(),
                    dsn: this.getDsn(),
                    tunnel: this.getOptions().tunnel
                });
                this._sendEnvelope(e)
            }
            _prepareEvent(t, e, r) {
                return t.platform = t.platform || "javascript",
                super._prepareEvent(t, e, r)
            }
            _flushOutcomes() {
                const t = this._clearOutcomes();
                if (0 === t.length)
                    return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.log("No outcomes to send"));
                if (!this._dsn)
                    return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.log("No dsn provided, will not send outcomes"));
                ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.log("Sending outcomes:", t);
                const e = (r = t,
                J((i = this._options.tunnel && V(this._dsn)) ? {
                    dsn: i
                } : {}, [[{
                    type: "client_report"
                }, {
                    timestamp: (0,
                    ut.yW)(),
                    discarded_events: r
                }]]));
                var r, i;
                this._sendEnvelope(e)
            }
        }
        class jt {
            static __initStatic() {
                this.id = "GlobalHandlers"
            }
            constructor(t) {
                this.name = jt.id,
                this._options = {
                    onerror: !0,
                    onunhandledrejection: !0,
                    ...t
                },
                this._installFunc = {
                    onerror: zt,
                    onunhandledrejection: Ht
                }
            }
            setupOnce() {
                Error.stackTraceLimit = 50;
                const t = this._options;
                for (const r in t) {
                    const i = this._installFunc[r];
                    i && t[r] && (e = r,
                    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.log(`Global Handler attached: ${e}`),
                    i(),
                    this._installFunc[r] = void 0)
                }
                var e
            }
        }
        function zt() {
            B("error", (t => {
                const [e,r,n] = Vt();
                if (!e.getIntegration(jt))
                    return;
                const {msg: i, url: s, line: o, column: a, error: h} = t;
                if (Pt() || h && h.__sentry_own_request__)
                    return;
                const l = void 0 === h && (0,
                R.HD)(i) ? function(t, e, r, n) {
                    let i = (0,
                    R.VW)(t) ? t.message : t
                      , s = "Error";
                    const o = i.match(/^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i);
                    o && (s = o[1],
                    i = o[2]);
                    return $t({
                        exception: {
                            values: [{
                                type: s,
                                value: i
                            }]
                        }
                    }, e, r, n)
                }(i, s, o, a) : $t(Tt(r, h || i, void 0, n, !1), s, o, a);
                l.level = "error",
                Xt(e, h, l, "onerror")
            }
            ))
        }
        function Ht() {
            B("unhandledrejection", (t => {
                const [e,r,n] = Vt();
                if (!e.getIntegration(jt))
                    return;
                let i = t;
                try {
                    "reason"in t ? i = t.reason : "detail"in t && "reason"in t.detail && (i = t.detail.reason)
                } catch (t) {}
                if (Pt() || i && i.__sentry_own_request__)
                    return !0;
                const s = (0,
                R.pt)(i) ? {
                    exception: {
                        values: [{
                            type: "UnhandledRejection",
                            value: `Non-Error promise rejection captured with value: ${String(i)}`
                        }]
                    }
                } : Tt(r, i, void 0, n, !0);
                s.level = "error",
                Xt(e, i, s, "onunhandledrejection")
            }
            ))
        }
        function $t(t, e, r, n) {
            const i = t.exception = t.exception || {}
              , s = i.values = i.values || []
              , o = s[0] = s[0] || {}
              , a = o.stacktrace = o.stacktrace || {}
              , h = a.frames = a.frames || []
              , l = isNaN(parseInt(n, 10)) ? void 0 : n
              , u = isNaN(parseInt(r, 10)) ? void 0 : r
              , c = (0,
            R.HD)(e) && e.length > 0 ? e : (0,
            Mt.l4)();
            return 0 === h.length && h.push({
                colno: l,
                filename: c,
                function: "?",
                in_app: !0,
                lineno: u
            }),
            t
        }
        function Xt(t, e, r, n) {
            (0,
            i.EG)(r, {
                handled: !1,
                type: n
            }),
            t.captureEvent(r, {
                originalException: e
            })
        }
        function Vt() {
            const t = (0,
            f.Gd)()
              , e = t.getClient()
              , r = e && e.getOptions() || {
                stackParser: () => [],
                attachStacktrace: !1
            };
            return [t, r.stackParser, r.attachStacktrace]
        }
        jt.__initStatic();
        const Wt = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
        class Yt {
            static __initStatic() {
                this.id = "TryCatch"
            }
            constructor(t) {
                this.name = Yt.id,
                this._options = {
                    XMLHttpRequest: !0,
                    eventTarget: !0,
                    requestAnimationFrame: !0,
                    setInterval: !0,
                    setTimeout: !0,
                    ...t
                }
            }
            setupOnce() {
                this._options.setTimeout && (0,
                u.hl)(Ct, "setTimeout", qt),
                this._options.setInterval && (0,
                u.hl)(Ct, "setInterval", qt),
                this._options.requestAnimationFrame && (0,
                u.hl)(Ct, "requestAnimationFrame", Kt),
                this._options.XMLHttpRequest && "XMLHttpRequest"in Ct && (0,
                u.hl)(XMLHttpRequest.prototype, "send", Zt);
                const t = this._options.eventTarget;
                t && (Array.isArray(t) ? t : Wt).forEach(Jt)
            }
        }
        function qt(t) {
            return function(...e) {
                const r = e[0];
                return e[0] = It(r, {
                    mechanism: {
                        data: {
                            function: T(t)
                        },
                        handled: !0,
                        type: "instrument"
                    }
                }),
                t.apply(this, e)
            }
        }
        function Kt(t) {
            return function(e) {
                return t.apply(this, [It(e, {
                    mechanism: {
                        data: {
                            function: "requestAnimationFrame",
                            handler: T(t)
                        },
                        handled: !0,
                        type: "instrument"
                    }
                })])
            }
        }
        function Zt(t) {
            return function(...e) {
                const r = this;
                return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((t => {
                    t in r && "function" == typeof r[t] && (0,
                    u.hl)(r, t, (function(e) {
                        const r = {
                            mechanism: {
                                data: {
                                    function: t,
                                    handler: T(e)
                                },
                                handled: !0,
                                type: "instrument"
                            }
                        }
                          , n = (0,
                        u.HK)(e);
                        return n && (r.mechanism.data.handler = T(n)),
                        It(e, r)
                    }
                    ))
                }
                )),
                t.apply(this, e)
            }
        }
        function Jt(t) {
            const e = Ct
              , r = e[t] && e[t].prototype;
            r && r.hasOwnProperty && r.hasOwnProperty("addEventListener") && ((0,
            u.hl)(r, "addEventListener", (function(e) {
                return function(r, n, i) {
                    try {
                        "function" == typeof n.handleEvent && (n.handleEvent = It(n.handleEvent, {
                            mechanism: {
                                data: {
                                    function: "handleEvent",
                                    handler: T(n),
                                    target: t
                                },
                                handled: !0,
                                type: "instrument"
                            }
                        }))
                    } catch (t) {}
                    return e.apply(this, [r, It(n, {
                        mechanism: {
                            data: {
                                function: "addEventListener",
                                handler: T(n),
                                target: t
                            },
                            handled: !0,
                            type: "instrument"
                        }
                    }), i])
                }
            }
            )),
            (0,
            u.hl)(r, "removeEventListener", (function(t) {
                return function(e, r, n) {
                    const i = r;
                    try {
                        const r = i && i.__sentry_wrapped__;
                        r && t.call(this, e, r, n)
                    } catch (t) {}
                    return t.call(this, e, i, n)
                }
            }
            )))
        }
        function Qt(t, e, r=250, n, i, o, a) {
            if (!(o.exception && o.exception.values && a && (0,
            R.V9)(a.originalException, Error)))
                return;
            const h = o.exception.values.length > 0 ? o.exception.values[o.exception.values.length - 1] : void 0;
            var l, u;
            h && (o.exception.values = (l = te(t, e, i, a.originalException, n, o.exception.values, h, 0),
            u = r,
            l.map((t => (t.value && (t.value = (0,
            s.$G)(t.value, u)),
            t)))))
        }
        function te(t, e, r, n, i, s, o, a) {
            if (s.length >= r + 1)
                return s;
            let h = [...s];
            if ((0,
            R.V9)(n[i], Error)) {
                ee(o, a);
                const s = t(e, n[i])
                  , l = h.length;
                re(s, i, l, a),
                h = te(t, e, r, n[i], i, [s, ...h], s, l)
            }
            return Array.isArray(n.errors) && n.errors.forEach(( (n, s) => {
                if ((0,
                R.V9)(n, Error)) {
                    ee(o, a);
                    const l = t(e, n)
                      , u = h.length;
                    re(l, `errors[${s}]`, u, a),
                    h = te(t, e, r, n, i, [l, ...h], l, u)
                }
            }
            )),
            h
        }
        function ee(t, e) {
            t.mechanism = t.mechanism || {
                type: "generic",
                handled: !0
            },
            t.mechanism = {
                ...t.mechanism,
                is_exception_group: !0,
                exception_id: e
            }
        }
        function re(t, e, r, n) {
            t.mechanism = t.mechanism || {
                type: "generic",
                handled: !0
            },
            t.mechanism = {
                ...t.mechanism,
                type: "chained",
                source: e,
                exception_id: r,
                parent_id: n
            }
        }
        Yt.__initStatic();
        class ne {
            static __initStatic() {
                this.id = "LinkedErrors"
            }
            constructor(t={}) {
                this.name = ne.id,
                this._key = t.key || "cause",
                this._limit = t.limit || 5
            }
            setupOnce(t, e) {
                t(( (t, r) => {
                    const n = e()
                      , i = n.getClient()
                      , s = n.getIntegration(ne);
                    if (!i || !s)
                        return t;
                    const o = i.getOptions();
                    return Qt(yt, o.stackParser, o.maxValueLength, s._key, s._limit, t, r),
                    t
                }
                ))
            }
        }
        ne.__initStatic();
        class ie {
            static __initStatic() {
                this.id = "HttpContext"
            }
            constructor() {
                this.name = ie.id
            }
            setupOnce() {
                (0,
                p.c)((t => {
                    if ((0,
                    f.Gd)().getIntegration(ie)) {
                        if (!Ct.navigator && !Ct.location && !Ct.document)
                            return t;
                        const e = t.request && t.request.url || Ct.location && Ct.location.href
                          , {referrer: r} = Ct.document || {}
                          , {userAgent: n} = Ct.navigator || {}
                          , i = {
                            ...t.request && t.request.headers,
                            ...r && {
                                Referer: r
                            },
                            ...n && {
                                "User-Agent": n
                            }
                        }
                          , s = {
                            ...t.request,
                            ...e && {
                                url: e
                            },
                            headers: i
                        };
                        return {
                            ...t,
                            request: s
                        }
                    }
                    return t
                }
                ))
            }
        }
        ie.__initStatic();
        class se {
            static __initStatic() {
                this.id = "Dedupe"
            }
            constructor() {
                this.name = se.id
            }
            setupOnce(t, e) {
                const r = t => {
                    if (t.type)
                        return t;
                    const r = e().getIntegration(se);
                    if (r) {
                        try {
                            if (function(t, e) {
                                return !!e && (!!function(t, e) {
                                    const r = t.message
                                      , n = e.message;
                                    return !(!r && !n) && (!(r && !n || !r && n) && (r === n && (!!ae(t, e) && !!oe(t, e))))
                                }(t, e) || !!function(t, e) {
                                    const r = he(e)
                                      , n = he(t);
                                    return !(!r || !n) && (r.type === n.type && r.value === n.value && (!!ae(t, e) && !!oe(t, e)))
                                }(t, e))
                            }(t, r._previousEvent))
                                return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn("Event dropped due to being a duplicate of previously captured event."),
                                null
                        } catch (e) {
                            return r._previousEvent = t
                        }
                        return r._previousEvent = t
                    }
                    return t
                }
                ;
                r.id = this.name,
                t(r)
            }
        }
        function oe(t, e) {
            let r = le(t)
              , n = le(e);
            if (!r && !n)
                return !0;
            if (r && !n || !r && n)
                return !1;
            if (n.length !== r.length)
                return !1;
            for (let t = 0; t < n.length; t++) {
                const e = n[t]
                  , i = r[t];
                if (e.filename !== i.filename || e.lineno !== i.lineno || e.colno !== i.colno || e.function !== i.function)
                    return !1
            }
            return !0
        }
        function ae(t, e) {
            let r = t.fingerprint
              , n = e.fingerprint;
            if (!r && !n)
                return !0;
            if (r && !n || !r && n)
                return !1;
            try {
                return !(r.join("") !== n.join(""))
            } catch (t) {
                return !1
            }
        }
        function he(t) {
            return t.exception && t.exception.values && t.exception.values[0]
        }
        function le(t) {
            const e = t.exception;
            if (e)
                try {
                    return e.values[0].stacktrace.frames
                } catch (t) {
                    return
                }
        }
        se.__initStatic();
        const ue = "?";
        function ce(t, e, r, n) {
            const i = {
                filename: t,
                function: e,
                in_app: !0
            };
            return void 0 !== r && (i.lineno = r),
            void 0 !== n && (i.colno = n),
            i
        }
        const de = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i
          , fe = /\((\S*)(?::(\d+))(?::(\d+))\)/
          , pe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i
          , me = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i
          , ge = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i
          , ve = b([30, t => {
            const e = de.exec(t);
            if (e) {
                if (e[2] && 0 === e[2].indexOf("eval")) {
                    const t = fe.exec(e[2]);
                    t && (e[2] = t[1],
                    e[3] = t[2],
                    e[4] = t[3])
                }
                const [t,r] = ye(e[1] || ue, e[2]);
                return ce(r, t, e[3] ? +e[3] : void 0, e[4] ? +e[4] : void 0)
            }
        }
        ], [50, t => {
            const e = pe.exec(t);
            if (e) {
                if (e[3] && e[3].indexOf(" > eval") > -1) {
                    const t = me.exec(e[3]);
                    t && (e[1] = e[1] || "eval",
                    e[3] = t[1],
                    e[4] = t[2],
                    e[5] = "")
                }
                let t = e[3]
                  , r = e[1] || ue;
                return [r,t] = ye(r, t),
                ce(t, r, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
            }
        }
        ], [40, t => {
            const e = ge.exec(t);
            return e ? ce(e[2], e[1] || ue, +e[3], e[4] ? +e[4] : void 0) : void 0
        }
        ])
          , ye = (t, e) => {
            const r = -1 !== t.indexOf("safari-extension")
              , n = -1 !== t.indexOf("safari-web-extension");
            return r || n ? [-1 !== t.indexOf("@") ? t.split("@")[0] : ue, r ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [t, e]
        }
        ;
        const _e = 6e4;
        const xe = 30;
        function be(t, e, r=function(t) {
            const e = [];
            function r(t) {
                return e.splice(e.indexOf(t), 1)[0]
            }
            return {
                $: e,
                add: function(n) {
                    if (!(void 0 === t || e.length < t))
                        return (0,
                        Y.$2)(new at("Not adding Promise because buffer limit was reached."));
                    const i = n();
                    return -1 === e.indexOf(i) && e.push(i),
                    i.then(( () => r(i))).then(null, ( () => r(i).then(null, ( () => {}
                    )))),
                    i
                },
                drain: function(t) {
                    return new Y.cW(( (r, n) => {
                        let i = e.length;
                        if (!i)
                            return r(!0);
                        const s = setTimeout(( () => {
                            t && t > 0 && r(!1)
                        }
                        ), t);
                        e.forEach((t => {
                            (0,
                            Y.WD)(t).then(( () => {
                                --i || (clearTimeout(s),
                                r(!0))
                            }
                            ), n)
                        }
                        ))
                    }
                    ))
                }
            }
        }(t.bufferSize || xe)) {
            let i = {};
            function s(s) {
                const o = [];
                if (tt(s, ( (e, r) => {
                    const n = st(r);
                    if (function(t, e, r=Date.now()) {
                        return function(t, e) {
                            return t[e] || t.all || 0
                        }(t, e) > r
                    }(i, n)) {
                        const i = Ee(e, r);
                        t.recordDroppedEvent("ratelimit_backoff", n, i)
                    } else
                        o.push(e)
                }
                )),
                0 === o.length)
                    return (0,
                    Y.WD)();
                const a = J(s[0], o)
                  , h = e => {
                    tt(a, ( (r, n) => {
                        const i = Ee(r, n);
                        t.recordDroppedEvent(e, st(n), i)
                    }
                    ))
                }
                ;
                return r.add(( () => e({
                    body: rt(a, t.textEncoder)
                }).then((t => (void 0 !== t.statusCode && (t.statusCode < 200 || t.statusCode >= 300) && ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn(`Sentry responded with status code ${t.statusCode} to sent event.`),
                i = function(t, {statusCode: e, headers: r}, n=Date.now()) {
                    const i = {
                        ...t
                    }
                      , s = r && r["x-sentry-rate-limits"]
                      , o = r && r["retry-after"];
                    if (s)
                        for (const t of s.trim().split(",")) {
                            const [e,r] = t.split(":", 2)
                              , s = parseInt(e, 10)
                              , o = 1e3 * (isNaN(s) ? 60 : s);
                            if (r)
                                for (const t of r.split(";"))
                                    i[t] = n + o;
                            else
                                i.all = n + o
                        }
                    else
                        o ? i.all = n + function(t, e=Date.now()) {
                            const r = parseInt(`${t}`, 10);
                            if (!isNaN(r))
                                return 1e3 * r;
                            const n = Date.parse(`${t}`);
                            return isNaN(n) ? _e : n - e
                        }(o, n) : 429 === e && (i.all = n + 6e4);
                    return i
                }(i, t),
                t)), (t => {
                    throw h("network_error"),
                    t
                }
                )))).then((t => t), (t => {
                    if (t instanceof at)
                        return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.error("Skipped sending event because buffer is full."),
                        h("queue_overflow"),
                        (0,
                        Y.WD)();
                    throw t
                }
                ))
            }
            return s.__sentry__baseTransport__ = !0,
            {
                send: s,
                flush: t => r.drain(t)
            }
        }
        function Ee(t, e) {
            if ("event" === e || "transaction" === e)
                return Array.isArray(t) ? t[1] : void 0
        }
        let Te;
        function we(t, e=function() {
            if (Te)
                return Te;
            if (C(Ct.fetch))
                return Te = Ct.fetch.bind(Ct);
            const t = Ct.document;
            let e = Ct.fetch;
            if (t && "function" == typeof t.createElement)
                try {
                    const r = t.createElement("iframe");
                    r.hidden = !0,
                    t.head.appendChild(r);
                    const n = r.contentWindow;
                    n && n.fetch && (e = n.fetch),
                    t.head.removeChild(r)
                } catch (t) {
                    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", t)
                }
            return Te = e.bind(Ct)
        }()) {
            let r = 0
              , i = 0;
            return be(t, (function(n) {
                const s = n.body.length;
                r += s,
                i++;
                const o = {
                    body: n.body,
                    method: "POST",
                    referrerPolicy: "origin",
                    headers: t.headers,
                    keepalive: r <= 6e4 && i < 15,
                    ...t.fetchOptions
                };
                try {
                    return e(t.url, o).then((t => (r -= s,
                    i--,
                    {
                        statusCode: t.status,
                        headers: {
                            "x-sentry-rate-limits": t.headers.get("X-Sentry-Rate-Limits"),
                            "retry-after": t.headers.get("Retry-After")
                        }
                    })))
                } catch (t) {
                    return Te = void 0,
                    r -= s,
                    i--,
                    (0,
                    Y.$2)(t)
                }
            }
            ))
        }
        const Se = 4;
        function Ae(t) {
            return be(t, (function(e) {
                return new Y.cW(( (r, n) => {
                    const i = new XMLHttpRequest;
                    i.onerror = n,
                    i.onreadystatechange = () => {
                        i.readyState === Se && r({
                            statusCode: i.status,
                            headers: {
                                "x-sentry-rate-limits": i.getResponseHeader("X-Sentry-Rate-Limits"),
                                "retry-after": i.getResponseHeader("Retry-After")
                            }
                        })
                    }
                    ,
                    i.open("POST", t.url);
                    for (const e in t.headers)
                        Object.prototype.hasOwnProperty.call(t.headers, e) && i.setRequestHeader(e, t.headers[e]);
                    i.send(e.body)
                }
                ))
            }
            ))
        }
        const Ce = [new h, new d, new Yt, new kt, new jt, new ne, new se, new ie];
        function Re(t={}) {
            void 0 === t.defaultIntegrations && (t.defaultIntegrations = Ce),
            void 0 === t.release && ("string" == typeof __SENTRY_RELEASE__ && (t.release = __SENTRY_RELEASE__),
            Ct.SENTRY_RELEASE && Ct.SENTRY_RELEASE.id && (t.release = Ct.SENTRY_RELEASE.id)),
            void 0 === t.autoSessionTracking && (t.autoSessionTracking = !0),
            void 0 === t.sendClientReports && (t.sendClientReports = !0);
            const e = {
                ...t,
                stackParser: (r = t.stackParser || ve,
                Array.isArray(r) ? b(...r) : r),
                integrations: g(t),
                transport: t.transport || (A() ? we : Ae)
            };
            var r;
            !function(t, e) {
                !0 === e.debug && ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__ ? n.kg.enable() : console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."));
                const r = (0,
                f.Gd)();
                r.getScope().update(e.initialScope);
                const i = new t(e);
                r.bindClient(i)
            }(Gt, e),
            t.autoSessionTracking && function() {
                if (void 0 === Ct.document)
                    return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && n.kg.warn("Session tracking in non-browser environment with @sentry/browser is not supported."));
                const t = (0,
                f.Gd)();
                t.captureSession && (Pe(t),
                B("history", ( ({from: t, to: e}) => {
                    void 0 !== t && t !== e && Pe((0,
                    f.Gd)())
                }
                )))
            }()
        }
        function Pe(t) {
            t.startSession({
                ignoreDuration: !0
            }),
            t.captureSession()
        }
    },
    51131: function(t, e, r) {
        "use strict";
        r.d(e, {
            J: function() {
                return n
            }
        });
        const n = "production"
    },
    64487: function(t, e, r) {
        "use strict";
        r.d(e, {
            $e: function() {
                return o
            },
            Tb: function() {
                return i
            },
            eN: function() {
                return s
            }
        });
        var n = r(95659);
        function i(t, e) {
            return (0,
            n.Gd)().captureException(t, {
                captureContext: e
            })
        }
        function s(t, e) {
            return (0,
            n.Gd)().captureEvent(t, e)
        }
        function o(t) {
            (0,
            n.Gd)().withScope(t)
        }
    },
    95659: function(t, e, r) {
        "use strict";
        r.d(e, {
            Gd: function() {
                return m
            }
        });
        var n = r(62844)
          , i = r(21170)
          , s = r(12343)
          , o = r(71235)
          , a = r(51131)
          , h = r(10350)
          , l = r(9015);
        const u = 4
          , c = 100;
        class d {
            constructor(t, e=new h.s, r=u) {
                this._version = r,
                this._stack = [{
                    scope: e
                }],
                t && this.bindClient(t)
            }
            isOlderThan(t) {
                return this._version < t
            }
            bindClient(t) {
                this.getStackTop().client = t,
                t && t.setupIntegrations && t.setupIntegrations()
            }
            pushScope() {
                const t = h.s.clone(this.getScope());
                return this.getStack().push({
                    client: this.getClient(),
                    scope: t
                }),
                t
            }
            popScope() {
                return !(this.getStack().length <= 1 || !this.getStack().pop())
            }
            withScope(t) {
                const e = this.pushScope();
                try {
                    t(e)
                } finally {
                    this.popScope()
                }
            }
            getClient() {
                return this.getStackTop().client
            }
            getScope() {
                return this.getStackTop().scope
            }
            getStack() {
                return this._stack
            }
            getStackTop() {
                return this._stack[this._stack.length - 1]
            }
            captureException(t, e) {
                const r = this._lastEventId = e && e.event_id ? e.event_id : (0,
                n.DM)()
                  , i = new Error("Sentry syntheticException");
                return this._withClient(( (n, s) => {
                    n.captureException(t, {
                        originalException: t,
                        syntheticException: i,
                        ...e,
                        event_id: r
                    }, s)
                }
                )),
                r
            }
            captureMessage(t, e, r) {
                const i = this._lastEventId = r && r.event_id ? r.event_id : (0,
                n.DM)()
                  , s = new Error(t);
                return this._withClient(( (n, o) => {
                    n.captureMessage(t, e, {
                        originalException: t,
                        syntheticException: s,
                        ...r,
                        event_id: i
                    }, o)
                }
                )),
                i
            }
            captureEvent(t, e) {
                const r = e && e.event_id ? e.event_id : (0,
                n.DM)();
                return t.type || (this._lastEventId = r),
                this._withClient(( (n, i) => {
                    n.captureEvent(t, {
                        ...e,
                        event_id: r
                    }, i)
                }
                )),
                r
            }
            lastEventId() {
                return this._lastEventId
            }
            addBreadcrumb(t, e) {
                const {scope: r, client: n} = this.getStackTop();
                if (!n)
                    return;
                const {beforeBreadcrumb: o=null, maxBreadcrumbs: a=c} = n.getOptions && n.getOptions() || {};
                if (a <= 0)
                    return;
                const h = {
                    timestamp: (0,
                    i.yW)(),
                    ...t
                }
                  , l = o ? (0,
                s.Cf)(( () => o(h, e))) : h;
                null !== l && (n.emit && n.emit("beforeAddBreadcrumb", l, e),
                r.addBreadcrumb(l, a))
            }
            setUser(t) {
                this.getScope().setUser(t)
            }
            setTags(t) {
                this.getScope().setTags(t)
            }
            setExtras(t) {
                this.getScope().setExtras(t)
            }
            setTag(t, e) {
                this.getScope().setTag(t, e)
            }
            setExtra(t, e) {
                this.getScope().setExtra(t, e)
            }
            setContext(t, e) {
                this.getScope().setContext(t, e)
            }
            configureScope(t) {
                const {scope: e, client: r} = this.getStackTop();
                r && t(e)
            }
            run(t) {
                const e = p(this);
                try {
                    t(this)
                } finally {
                    p(e)
                }
            }
            getIntegration(t) {
                const e = this.getClient();
                if (!e)
                    return null;
                try {
                    return e.getIntegration(t)
                } catch (e) {
                    return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && s.kg.warn(`Cannot retrieve integration ${t.id} from the current Hub`),
                    null
                }
            }
            startTransaction(t, e) {
                const r = this._callExtensionMethod("startTransaction", t, e);
                return "undefined" != typeof __SENTRY_DEBUG__ && !__SENTRY_DEBUG__ || r || console.warn("Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':\nSentry.addTracingExtensions();\nSentry.init({...});\n"),
                r
            }
            traceHeaders() {
                return this._callExtensionMethod("traceHeaders")
            }
            captureSession(t=!1) {
                if (t)
                    return this.endSession();
                this._sendSessionUpdate()
            }
            endSession() {
                const t = this.getStackTop().scope
                  , e = t.getSession();
                e && (0,
                l.RJ)(e),
                this._sendSessionUpdate(),
                t.setSession()
            }
            startSession(t) {
                const {scope: e, client: r} = this.getStackTop()
                  , {release: n, environment: i=a.J} = r && r.getOptions() || {}
                  , {userAgent: s} = o.n2.navigator || {}
                  , h = (0,
                l.Hv)({
                    release: n,
                    environment: i,
                    user: e.getUser(),
                    ...s && {
                        userAgent: s
                    },
                    ...t
                })
                  , u = e.getSession && e.getSession();
                return u && "ok" === u.status && (0,
                l.CT)(u, {
                    status: "exited"
                }),
                this.endSession(),
                e.setSession(h),
                h
            }
            shouldSendDefaultPii() {
                const t = this.getClient()
                  , e = t && t.getOptions();
                return Boolean(e && e.sendDefaultPii)
            }
            _sendSessionUpdate() {
                const {scope: t, client: e} = this.getStackTop()
                  , r = t.getSession();
                r && e && e.captureSession && e.captureSession(r)
            }
            _withClient(t) {
                const {scope: e, client: r} = this.getStackTop();
                r && t(r, e)
            }
            _callExtensionMethod(t, ...e) {
                const r = f().__SENTRY__;
                if (r && r.extensions && "function" == typeof r.extensions[t])
                    return r.extensions[t].apply(this, e);
                ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && s.kg.warn(`Extension method ${t} couldn't be found, doing nothing.`)
            }
        }
        function f() {
            return o.n2.__SENTRY__ = o.n2.__SENTRY__ || {
                extensions: {},
                hub: void 0
            },
            o.n2
        }
        function p(t) {
            const e = f()
              , r = g(e);
            return v(e, t),
            r
        }
        function m() {
            const t = f();
            if (t.__SENTRY__ && t.__SENTRY__.acs) {
                const e = t.__SENTRY__.acs.getCurrentHub();
                if (e)
                    return e
            }
            return function(t=f()) {
                return e = t,
                !!(e && e.__SENTRY__ && e.__SENTRY__.hub) && !g(t).isOlderThan(u) || v(t, new d),
                g(t);
                var e
            }(t)
        }
        function g(t) {
            return (0,
            o.YO)("hub", ( () => new d), t)
        }
        function v(t, e) {
            return !!t && ((t.__SENTRY__ = t.__SENTRY__ || {}).hub = e,
            !0)
        }
    },
    10350: function(t, e, r) {
        "use strict";
        r.d(e, {
            c: function() {
                return d
            },
            s: function() {
                return u
            }
        });
        var n = r(67597)
          , i = r(21170)
          , s = r(96893)
          , o = r(12343)
          , a = r(62844)
          , h = r(71235)
          , l = r(9015);
        class u {
            constructor() {
                this._notifyingListeners = !1,
                this._scopeListeners = [],
                this._eventProcessors = [],
                this._breadcrumbs = [],
                this._attachments = [],
                this._user = {},
                this._tags = {},
                this._extra = {},
                this._contexts = {},
                this._sdkProcessingMetadata = {},
                this._propagationContext = f()
            }
            static clone(t) {
                const e = new u;
                return t && (e._breadcrumbs = [...t._breadcrumbs],
                e._tags = {
                    ...t._tags
                },
                e._extra = {
                    ...t._extra
                },
                e._contexts = {
                    ...t._contexts
                },
                e._user = t._user,
                e._level = t._level,
                e._span = t._span,
                e._session = t._session,
                e._transactionName = t._transactionName,
                e._fingerprint = t._fingerprint,
                e._eventProcessors = [...t._eventProcessors],
                e._requestSession = t._requestSession,
                e._attachments = [...t._attachments],
                e._sdkProcessingMetadata = {
                    ...t._sdkProcessingMetadata
                },
                e._propagationContext = {
                    ...t._propagationContext
                }),
                e
            }
            addScopeListener(t) {
                this._scopeListeners.push(t)
            }
            addEventProcessor(t) {
                return this._eventProcessors.push(t),
                this
            }
            setUser(t) {
                return this._user = t || {},
                this._session && (0,
                l.CT)(this._session, {
                    user: t
                }),
                this._notifyScopeListeners(),
                this
            }
            getUser() {
                return this._user
            }
            getRequestSession() {
                return this._requestSession
            }
            setRequestSession(t) {
                return this._requestSession = t,
                this
            }
            setTags(t) {
                return this._tags = {
                    ...this._tags,
                    ...t
                },
                this._notifyScopeListeners(),
                this
            }
            setTag(t, e) {
                return this._tags = {
                    ...this._tags,
                    [t]: e
                },
                this._notifyScopeListeners(),
                this
            }
            setExtras(t) {
                return this._extra = {
                    ...this._extra,
                    ...t
                },
                this._notifyScopeListeners(),
                this
            }
            setExtra(t, e) {
                return this._extra = {
                    ...this._extra,
                    [t]: e
                },
                this._notifyScopeListeners(),
                this
            }
            setFingerprint(t) {
                return this._fingerprint = t,
                this._notifyScopeListeners(),
                this
            }
            setLevel(t) {
                return this._level = t,
                this._notifyScopeListeners(),
                this
            }
            setTransactionName(t) {
                return this._transactionName = t,
                this._notifyScopeListeners(),
                this
            }
            setContext(t, e) {
                return null === e ? delete this._contexts[t] : this._contexts[t] = e,
                this._notifyScopeListeners(),
                this
            }
            setSpan(t) {
                return this._span = t,
                this._notifyScopeListeners(),
                this
            }
            getSpan() {
                return this._span
            }
            getTransaction() {
                const t = this.getSpan();
                return t && t.transaction
            }
            setSession(t) {
                return t ? this._session = t : delete this._session,
                this._notifyScopeListeners(),
                this
            }
            getSession() {
                return this._session
            }
            update(t) {
                if (!t)
                    return this;
                if ("function" == typeof t) {
                    const e = t(this);
                    return e instanceof u ? e : this
                }
                return t instanceof u ? (this._tags = {
                    ...this._tags,
                    ...t._tags
                },
                this._extra = {
                    ...this._extra,
                    ...t._extra
                },
                this._contexts = {
                    ...this._contexts,
                    ...t._contexts
                },
                t._user && Object.keys(t._user).length && (this._user = t._user),
                t._level && (this._level = t._level),
                t._fingerprint && (this._fingerprint = t._fingerprint),
                t._requestSession && (this._requestSession = t._requestSession),
                t._propagationContext && (this._propagationContext = t._propagationContext)) : (0,
                n.PO)(t) && (this._tags = {
                    ...this._tags,
                    ...t.tags
                },
                this._extra = {
                    ...this._extra,
                    ...t.extra
                },
                this._contexts = {
                    ...this._contexts,
                    ...t.contexts
                },
                t.user && (this._user = t.user),
                t.level && (this._level = t.level),
                t.fingerprint && (this._fingerprint = t.fingerprint),
                t.requestSession && (this._requestSession = t.requestSession),
                t.propagationContext && (this._propagationContext = t.propagationContext)),
                this
            }
            clear() {
                return this._breadcrumbs = [],
                this._tags = {},
                this._extra = {},
                this._user = {},
                this._contexts = {},
                this._level = void 0,
                this._transactionName = void 0,
                this._fingerprint = void 0,
                this._requestSession = void 0,
                this._span = void 0,
                this._session = void 0,
                this._notifyScopeListeners(),
                this._attachments = [],
                this._propagationContext = f(),
                this
            }
            addBreadcrumb(t, e) {
                const r = "number" == typeof e ? e : 100;
                if (r <= 0)
                    return this;
                const n = {
                    timestamp: (0,
                    i.yW)(),
                    ...t
                };
                return this._breadcrumbs = [...this._breadcrumbs, n].slice(-r),
                this._notifyScopeListeners(),
                this
            }
            getLastBreadcrumb() {
                return this._breadcrumbs[this._breadcrumbs.length - 1]
            }
            clearBreadcrumbs() {
                return this._breadcrumbs = [],
                this._notifyScopeListeners(),
                this
            }
            addAttachment(t) {
                return this._attachments.push(t),
                this
            }
            getAttachments() {
                return this._attachments
            }
            clearAttachments() {
                return this._attachments = [],
                this
            }
            applyToEvent(t, e={}) {
                if (this._extra && Object.keys(this._extra).length && (t.extra = {
                    ...this._extra,
                    ...t.extra
                }),
                this._tags && Object.keys(this._tags).length && (t.tags = {
                    ...this._tags,
                    ...t.tags
                }),
                this._user && Object.keys(this._user).length && (t.user = {
                    ...this._user,
                    ...t.user
                }),
                this._contexts && Object.keys(this._contexts).length && (t.contexts = {
                    ...this._contexts,
                    ...t.contexts
                }),
                this._level && (t.level = this._level),
                this._transactionName && (t.transaction = this._transactionName),
                this._span) {
                    t.contexts = {
                        trace: this._span.getTraceContext(),
                        ...t.contexts
                    };
                    const e = this._span.transaction;
                    if (e) {
                        t.sdkProcessingMetadata = {
                            dynamicSamplingContext: e.getDynamicSamplingContext(),
                            ...t.sdkProcessingMetadata
                        };
                        const r = e.name;
                        r && (t.tags = {
                            transaction: r,
                            ...t.tags
                        })
                    }
                }
                return this._applyFingerprint(t),
                t.breadcrumbs = [...t.breadcrumbs || [], ...this._breadcrumbs],
                t.breadcrumbs = t.breadcrumbs.length > 0 ? t.breadcrumbs : void 0,
                t.sdkProcessingMetadata = {
                    ...t.sdkProcessingMetadata,
                    ...this._sdkProcessingMetadata,
                    propagationContext: this._propagationContext
                },
                this._notifyEventProcessors([...c(), ...this._eventProcessors], t, e)
            }
            setSDKProcessingMetadata(t) {
                return this._sdkProcessingMetadata = {
                    ...this._sdkProcessingMetadata,
                    ...t
                },
                this
            }
            setPropagationContext(t) {
                return this._propagationContext = t,
                this
            }
            getPropagationContext() {
                return this._propagationContext
            }
            _notifyEventProcessors(t, e, r, i=0) {
                return new s.cW(( (s, a) => {
                    const h = t[i];
                    if (null === e || "function" != typeof h)
                        s(e);
                    else {
                        const l = h({
                            ...e
                        }, r);
                        ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && h.id && null === l && o.kg.log(`Event processor "${h.id}" dropped event`),
                        (0,
                        n.J8)(l) ? l.then((e => this._notifyEventProcessors(t, e, r, i + 1).then(s))).then(null, a) : this._notifyEventProcessors(t, l, r, i + 1).then(s).then(null, a)
                    }
                }
                ))
            }
            _notifyScopeListeners() {
                this._notifyingListeners || (this._notifyingListeners = !0,
                this._scopeListeners.forEach((t => {
                    t(this)
                }
                )),
                this._notifyingListeners = !1)
            }
            _applyFingerprint(t) {
                t.fingerprint = t.fingerprint ? (0,
                a.lE)(t.fingerprint) : [],
                this._fingerprint && (t.fingerprint = t.fingerprint.concat(this._fingerprint)),
                t.fingerprint && !t.fingerprint.length && delete t.fingerprint
            }
        }
        function c() {
            return (0,
            h.YO)("globalEventProcessors", ( () => []))
        }
        function d(t) {
            c().push(t)
        }
        function f() {
            return {
                traceId: (0,
                a.DM)(),
                spanId: (0,
                a.DM)().substring(16),
                sampled: !1
            }
        }
    },
    9015: function(t, e, r) {
        "use strict";
        r.d(e, {
            CT: function() {
                return a
            },
            Hv: function() {
                return o
            },
            RJ: function() {
                return h
            }
        });
        var n = r(21170)
          , i = r(62844)
          , s = r(20535);
        function o(t) {
            const e = (0,
            n.ph)()
              , r = {
                sid: (0,
                i.DM)(),
                init: !0,
                timestamp: e,
                started: e,
                duration: 0,
                status: "ok",
                errors: 0,
                ignoreDuration: !1,
                toJSON: () => function(t) {
                    return (0,
                    s.Jr)({
                        sid: `${t.sid}`,
                        init: t.init,
                        started: new Date(1e3 * t.started).toISOString(),
                        timestamp: new Date(1e3 * t.timestamp).toISOString(),
                        status: t.status,
                        errors: t.errors,
                        did: "number" == typeof t.did || "string" == typeof t.did ? `${t.did}` : void 0,
                        duration: t.duration,
                        attrs: {
                            release: t.release,
                            environment: t.environment,
                            ip_address: t.ipAddress,
                            user_agent: t.userAgent
                        }
                    })
                }(r)
            };
            return t && a(r, t),
            r
        }
        function a(t, e={}) {
            if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address),
            t.did || e.did || (t.did = e.user.id || e.user.email || e.user.username)),
            t.timestamp = e.timestamp || (0,
            n.ph)(),
            e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration),
            e.sid && (t.sid = 32 === e.sid.length ? e.sid : (0,
            i.DM)()),
            void 0 !== e.init && (t.init = e.init),
            !t.did && e.did && (t.did = `${e.did}`),
            "number" == typeof e.started && (t.started = e.started),
            t.ignoreDuration)
                t.duration = void 0;
            else if ("number" == typeof e.duration)
                t.duration = e.duration;
            else {
                const e = t.timestamp - t.started;
                t.duration = e >= 0 ? e : 0
            }
            e.release && (t.release = e.release),
            e.environment && (t.environment = e.environment),
            !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress),
            !t.userAgent && e.userAgent && (t.userAgent = e.userAgent),
            "number" == typeof e.errors && (t.errors = e.errors),
            e.status && (t.status = e.status)
        }
        function h(t, e) {
            let r = {};
            e ? r = {
                status: e
            } : "ok" === t.status && (r = {
                status: "exited"
            }),
            a(t, r)
        }
    },
    58464: function(t, e, r) {
        "use strict";
        r.d(e, {
            Rt: function() {
                return o
            },
            l4: function() {
                return h
            }
        });
        var n = r(67597);
        const i = (0,
        r(71235).Rf)()
          , s = 80;
        function o(t, e={}) {
            try {
                let r = t;
                const n = 5
                  , i = [];
                let o = 0
                  , h = 0;
                const l = " > "
                  , u = l.length;
                let c;
                const d = Array.isArray(e) ? e : e.keyAttrs
                  , f = !Array.isArray(e) && e.maxStringLength || s;
                for (; r && o++ < n && (c = a(r, d),
                !("html" === c || o > 1 && h + i.length * u + c.length >= f)); )
                    i.push(c),
                    h += c.length,
                    r = r.parentNode;
                return i.reverse().join(l)
            } catch (t) {
                return "<unknown>"
            }
        }
        function a(t, e) {
            const r = t
              , i = [];
            let s, o, a, h, l;
            if (!r || !r.tagName)
                return "";
            i.push(r.tagName.toLowerCase());
            const u = e && e.length ? e.filter((t => r.getAttribute(t))).map((t => [t, r.getAttribute(t)])) : null;
            if (u && u.length)
                u.forEach((t => {
                    i.push(`[${t[0]}="${t[1]}"]`)
                }
                ));
            else if (r.id && i.push(`#${r.id}`),
            s = r.className,
            s && (0,
            n.HD)(s))
                for (o = s.split(/\s+/),
                l = 0; l < o.length; l++)
                    i.push(`.${o[l]}`);
            const c = ["aria-label", "type", "name", "title", "alt"];
            for (l = 0; l < c.length; l++)
                a = c[l],
                h = r.getAttribute(a),
                h && i.push(`[${a}="${h}"]`);
            return i.join("")
        }
        function h() {
            try {
                return i.document.location.href
            } catch (t) {
                return ""
            }
        }
    },
    68518: function(t, e, r) {
        "use strict";
        function n() {
            return "undefined" != typeof __SENTRY_BROWSER_BUNDLE__ && !!__SENTRY_BROWSER_BUNDLE__
        }
        function i() {
            return "npm"
        }
        r.d(e, {
            S: function() {
                return i
            },
            n: function() {
                return n
            }
        })
    },
    67597: function(t, e, r) {
        "use strict";
        r.d(e, {
            Cy: function() {
                return g
            },
            HD: function() {
                return l
            },
            J8: function() {
                return m
            },
            Kj: function() {
                return p
            },
            PO: function() {
                return c
            },
            TX: function() {
                return a
            },
            V9: function() {
                return y
            },
            VW: function() {
                return o
            },
            VZ: function() {
                return i
            },
            cO: function() {
                return d
            },
            fm: function() {
                return h
            },
            i2: function() {
                return v
            },
            kK: function() {
                return f
            },
            pt: function() {
                return u
            }
        });
        const n = Object.prototype.toString;
        function i(t) {
            switch (n.call(t)) {
            case "[object Error]":
            case "[object Exception]":
            case "[object DOMException]":
                return !0;
            default:
                return y(t, Error)
            }
        }
        function s(t, e) {
            return n.call(t) === `[object ${e}]`
        }
        function o(t) {
            return s(t, "ErrorEvent")
        }
        function a(t) {
            return s(t, "DOMError")
        }
        function h(t) {
            return s(t, "DOMException")
        }
        function l(t) {
            return s(t, "String")
        }
        function u(t) {
            return null === t || "object" != typeof t && "function" != typeof t
        }
        function c(t) {
            return s(t, "Object")
        }
        function d(t) {
            return "undefined" != typeof Event && y(t, Event)
        }
        function f(t) {
            return "undefined" != typeof Element && y(t, Element)
        }
        function p(t) {
            return s(t, "RegExp")
        }
        function m(t) {
            return Boolean(t && t.then && "function" == typeof t.then)
        }
        function g(t) {
            return c(t) && "nativeEvent"in t && "preventDefault"in t && "stopPropagation"in t
        }
        function v(t) {
            return "number" == typeof t && t != t
        }
        function y(t, e) {
            try {
                return t instanceof e
            } catch (t) {
                return !1
            }
        }
    },
    12343: function(t, e, r) {
        "use strict";
        r.d(e, {
            Cf: function() {
                return s
            },
            RU: function() {
                return i
            },
            kg: function() {
                return a
            }
        });
        var n = r(71235);
        const i = ["debug", "info", "warn", "error", "log", "assert", "trace"];
        function s(t) {
            if (!("console"in n.n2))
                return t();
            const e = n.n2.console
              , r = {};
            i.forEach((t => {
                const n = e[t] && e[t].__sentry_original__;
                t in e && n && (r[t] = e[t],
                e[t] = n)
            }
            ));
            try {
                return t()
            } finally {
                Object.keys(r).forEach((t => {
                    e[t] = r[t]
                }
                ))
            }
        }
        function o() {
            let t = !1;
            const e = {
                enable: () => {
                    t = !0
                }
                ,
                disable: () => {
                    t = !1
                }
            };
            return "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__ ? i.forEach((r => {
                e[r] = (...e) => {
                    t && s(( () => {
                        n.n2.console[r](`Sentry Logger [${r}]:`, ...e)
                    }
                    ))
                }
            }
            )) : i.forEach((t => {
                e[t] = () => {}
            }
            )),
            e
        }
        let a;
        a = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__ ? (0,
        n.YO)("logger", o) : o()
    },
    62844: function(t, e, r) {
        "use strict";
        r.d(e, {
            DM: function() {
                return s
            },
            Db: function() {
                return h
            },
            EG: function() {
                return l
            },
            YO: function() {
                return u
            },
            jH: function() {
                return a
            },
            lE: function() {
                return c
            }
        });
        var n = r(20535)
          , i = r(71235);
        function s() {
            const t = i.n2
              , e = t.crypto || t.msCrypto;
            if (e && e.randomUUID)
                return e.randomUUID().replace(/-/g, "");
            const r = e && e.getRandomValues ? () => e.getRandomValues(new Uint8Array(1))[0] : () => 16 * Math.random();
            return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (t => (t ^ (15 & r()) >> t / 4).toString(16)))
        }
        function o(t) {
            return t.exception && t.exception.values ? t.exception.values[0] : void 0
        }
        function a(t) {
            const {message: e, event_id: r} = t;
            if (e)
                return e;
            const n = o(t);
            return n ? n.type && n.value ? `${n.type}: ${n.value}` : n.type || n.value || r || "<unknown>" : r || "<unknown>"
        }
        function h(t, e, r) {
            const n = t.exception = t.exception || {}
              , i = n.values = n.values || []
              , s = i[0] = i[0] || {};
            s.value || (s.value = e || ""),
            s.type || (s.type = r || "Error")
        }
        function l(t, e) {
            const r = o(t);
            if (!r)
                return;
            const n = r.mechanism;
            if (r.mechanism = {
                type: "generic",
                handled: !0,
                ...n,
                ...e
            },
            e && "data"in e) {
                const t = {
                    ...n && n.data,
                    ...e.data
                };
                r.mechanism.data = t
            }
        }
        function u(t) {
            if (t && t.__sentry_captured__)
                return !0;
            try {
                (0,
                n.xp)(t, "__sentry_captured__", !0)
            } catch (t) {}
            return !1
        }
        function c(t) {
            return Array.isArray(t) ? t : [t]
        }
    },
    61422: function(t, e, r) {
        "use strict";
        r.d(e, {
            KV: function() {
                return i
            },
            l$: function() {
                return s
            }
        });
        var n = r(68518);
        function i() {
            return !(0,
            n.n)() && "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0)
        }
        function s(t, e) {
            return t.require(e)
        }
        t = r.hmd(t)
    },
    20535: function(t, e, r) {
        "use strict";
        r.d(e, {
            $Q: function() {
                return h
            },
            HK: function() {
                return l
            },
            Jr: function() {
                return m
            },
            Sh: function() {
                return c
            },
            _j: function() {
                return u
            },
            hl: function() {
                return o
            },
            xp: function() {
                return a
            },
            zf: function() {
                return p
            }
        });
        var n = r(58464)
          , i = r(67597)
          , s = r(57321);
        function o(t, e, r) {
            if (!(e in t))
                return;
            const n = t[e]
              , i = r(n);
            if ("function" == typeof i)
                try {
                    h(i, n)
                } catch (t) {}
            t[e] = i
        }
        function a(t, e, r) {
            Object.defineProperty(t, e, {
                value: r,
                writable: !0,
                configurable: !0
            })
        }
        function h(t, e) {
            const r = e.prototype || {};
            t.prototype = e.prototype = r,
            a(t, "__sentry_original__", e)
        }
        function l(t) {
            return t.__sentry_original__
        }
        function u(t) {
            return Object.keys(t).map((e => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`)).join("&")
        }
        function c(t) {
            if ((0,
            i.VZ)(t))
                return {
                    message: t.message,
                    name: t.name,
                    stack: t.stack,
                    ...f(t)
                };
            if ((0,
            i.cO)(t)) {
                const e = {
                    type: t.type,
                    target: d(t.target),
                    currentTarget: d(t.currentTarget),
                    ...f(t)
                };
                return "undefined" != typeof CustomEvent && (0,
                i.V9)(t, CustomEvent) && (e.detail = t.detail),
                e
            }
            return t
        }
        function d(t) {
            try {
                return (0,
                i.kK)(t) ? (0,
                n.Rt)(t) : Object.prototype.toString.call(t)
            } catch (t) {
                return "<unknown>"
            }
        }
        function f(t) {
            if ("object" == typeof t && null !== t) {
                const e = {};
                for (const r in t)
                    Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
                return e
            }
            return {}
        }
        function p(t, e=40) {
            const r = Object.keys(c(t));
            if (r.sort(),
            !r.length)
                return "[object has no keys]";
            if (r[0].length >= e)
                return (0,
                s.$G)(r[0], e);
            for (let t = r.length; t > 0; t--) {
                const n = r.slice(0, t).join(", ");
                if (!(n.length > e))
                    return t === r.length ? n : (0,
                    s.$G)(n, e)
            }
            return ""
        }
        function m(t) {
            return g(t, new Map)
        }
        function g(t, e) {
            if ((0,
            i.PO)(t)) {
                const r = e.get(t);
                if (void 0 !== r)
                    return r;
                const n = {};
                e.set(t, n);
                for (const r of Object.keys(t))
                    void 0 !== t[r] && (n[r] = g(t[r], e));
                return n
            }
            if (Array.isArray(t)) {
                const r = e.get(t);
                if (void 0 !== r)
                    return r;
                const n = [];
                return e.set(t, n),
                t.forEach((t => {
                    n.push(g(t, e))
                }
                )),
                n
            }
            return t
        }
    },
    57321: function(t, e, r) {
        "use strict";
        r.d(e, {
            $G: function() {
                return i
            },
            U0: function() {
                return o
            },
            nK: function() {
                return s
            }
        });
        var n = r(67597);
        function i(t, e=0) {
            return "string" != typeof t || 0 === e || t.length <= e ? t : `${t.slice(0, e)}...`
        }
        function s(t, e) {
            if (!Array.isArray(t))
                return "";
            const r = [];
            for (let e = 0; e < t.length; e++) {
                const n = t[e];
                try {
                    r.push(String(n))
                } catch (t) {
                    r.push("[value cannot be serialized]")
                }
            }
            return r.join(e)
        }
        function o(t, e=[], r=!1) {
            return e.some((e => function(t, e, r=!1) {
                return !!(0,
                n.HD)(t) && ((0,
                n.Kj)(e) ? e.test(t) : !!(0,
                n.HD)(e) && (r ? t === e : t.includes(e)))
            }(t, e, r)))
        }
    },
    96893: function(t, e, r) {
        "use strict";
        r.d(e, {
            $2: function() {
                return o
            },
            WD: function() {
                return s
            },
            cW: function() {
                return a
            }
        });
        var n, i = r(67597);
        function s(t) {
            return new a((e => {
                e(t)
            }
            ))
        }
        function o(t) {
            return new a(( (e, r) => {
                r(t)
            }
            ))
        }
        !function(t) {
            t[t.PENDING = 0] = "PENDING",
            t[t.RESOLVED = 1] = "RESOLVED",
            t[t.REJECTED = 2] = "REJECTED"
        }(n || (n = {}));
        class a {
            constructor(t) {
                a.prototype.__init.call(this),
                a.prototype.__init2.call(this),
                a.prototype.__init3.call(this),
                a.prototype.__init4.call(this),
                this._state = n.PENDING,
                this._handlers = [];
                try {
                    t(this._resolve, this._reject)
                } catch (t) {
                    this._reject(t)
                }
            }
            then(t, e) {
                return new a(( (r, n) => {
                    this._handlers.push([!1, e => {
                        if (t)
                            try {
                                r(t(e))
                            } catch (t) {
                                n(t)
                            }
                        else
                            r(e)
                    }
                    , t => {
                        if (e)
                            try {
                                r(e(t))
                            } catch (t) {
                                n(t)
                            }
                        else
                            n(t)
                    }
                    ]),
                    this._executeHandlers()
                }
                ))
            }
            catch(t) {
                return this.then((t => t), t)
            }
            finally(t) {
                return new a(( (e, r) => {
                    let n, i;
                    return this.then((e => {
                        i = !1,
                        n = e,
                        t && t()
                    }
                    ), (e => {
                        i = !0,
                        n = e,
                        t && t()
                    }
                    )).then(( () => {
                        i ? r(n) : e(n)
                    }
                    ))
                }
                ))
            }
            __init() {
                this._resolve = t => {
                    this._setResult(n.RESOLVED, t)
                }
            }
            __init2() {
                this._reject = t => {
                    this._setResult(n.REJECTED, t)
                }
            }
            __init3() {
                this._setResult = (t, e) => {
                    this._state === n.PENDING && ((0,
                    i.J8)(e) ? e.then(this._resolve, this._reject) : (this._state = t,
                    this._value = e,
                    this._executeHandlers()))
                }
            }
            __init4() {
                this._executeHandlers = () => {
                    if (this._state === n.PENDING)
                        return;
                    const t = this._handlers.slice();
                    this._handlers = [],
                    t.forEach((t => {
                        t[0] || (this._state === n.RESOLVED && t[1](this._value),
                        this._state === n.REJECTED && t[2](this._value),
                        t[0] = !0)
                    }
                    ))
                }
            }
        }
    },
    21170: function(t, e, r) {
        "use strict";
        r.d(e, {
            ph: function() {
                return u
            },
            yW: function() {
                return l
            }
        });
        var n = r(61422)
          , i = r(71235);
        t = r.hmd(t);
        const s = (0,
        i.Rf)()
          , o = {
            nowSeconds: () => Date.now() / 1e3
        }
          , a = (0,
        n.KV)() ? function() {
            try {
                return (0,
                n.l$)(t, "perf_hooks").performance
            } catch (t) {
                return
            }
        }() : function() {
            const {performance: t} = s;
            if (t && t.now)
                return {
                    now: () => t.now(),
                    timeOrigin: Date.now() - t.now()
                }
        }()
          , h = void 0 === a ? o : {
            nowSeconds: () => (a.timeOrigin + a.now()) / 1e3
        }
          , l = o.nowSeconds.bind(o)
          , u = h.nowSeconds.bind(h);
        let c;
        ( () => {
            const {performance: t} = s;
            if (!t || !t.now)
                return void (c = "none");
            const e = 36e5
              , r = t.now()
              , n = Date.now()
              , i = t.timeOrigin ? Math.abs(t.timeOrigin + r - n) : e
              , o = i < e
              , a = t.timing && t.timing.navigationStart
              , h = "number" == typeof a ? Math.abs(a + r - n) : e;
            o || h < e ? i <= h ? (c = "timeOrigin",
            t.timeOrigin) : c = "navigationStart" : c = "dateNow"
        }
        )()
    },
    71235: function(t, e, r) {
        "use strict";
        function n(t) {
            return t && t.Math == Math ? t : void 0
        }
        r.d(e, {
            Rf: function() {
                return s
            },
            YO: function() {
                return o
            },
            n2: function() {
                return i
            }
        });
        const i = "object" == typeof globalThis && n(globalThis) || "object" == typeof window && n(window) || "object" == typeof self && n(self) || "object" == typeof r.g && n(r.g) || function() {
            return this
        }() || {};
        function s() {
            return i
        }
        function o(t, e, r) {
            const n = r || i
              , s = n.__SENTRY__ = n.__SENTRY__ || {};
            return s[t] || (s[t] = e())
        }
    },
    21924: function(t, e, r) {
        "use strict";
        var n = r(40210)
          , i = r(55559)
          , s = i(n("String.prototype.indexOf"));
        t.exports = function(t, e) {
            var r = n(t, !!e);
            return "function" == typeof r && s(t, ".prototype.") > -1 ? i(r) : r
        }
    },
    55559: function(t, e, r) {
        "use strict";
        var n = r(58612)
          , i = r(40210)
          , s = i("%Function.prototype.apply%")
          , o = i("%Function.prototype.call%")
          , a = i("%Reflect.apply%", !0) || n.call(o, s)
          , h = i("%Object.getOwnPropertyDescriptor%", !0)
          , l = i("%Object.defineProperty%", !0)
          , u = i("%Math.max%");
        if (l)
            try {
                l({}, "a", {
                    value: 1
                })
            } catch (t) {
                l = null
            }
        t.exports = function(t) {
            var e = a(n, o, arguments);
            return h && l && h(e, "length").configurable && l(e, "length", {
                value: 1 + u(0, t.length - (arguments.length - 1))
            }),
            e
        }
        ;
        var c = function() {
            return a(n, s, arguments)
        };
        l ? l(t.exports, "apply", {
            value: c
        }) : t.exports.apply = c
    },
    19662: function(t, e, r) {
        "use strict";
        var n = r(60614)
          , i = r(66330)
          , s = TypeError;
        t.exports = function(t) {
            if (n(t))
                return t;
            throw s(i(t) + " is not a function")
        }
    },
    96077: function(t, e, r) {
        "use strict";
        var n = r(60614)
          , i = String
          , s = TypeError;
        t.exports = function(t) {
            if ("object" == typeof t || n(t))
                return t;
            throw s("Can't set " + i(t) + " as a prototype")
        }
    },
    51223: function(t, e, r) {
        "use strict";
        var n = r(5112)
          , i = r(70030)
          , s = r(3070).f
          , o = n("unscopables")
          , a = Array.prototype;
        void 0 === a[o] && s(a, o, {
            configurable: !0,
            value: i(null)
        }),
        t.exports = function(t) {
            a[o][t] = !0
        }
    },
    31530: function(t, e, r) {
        "use strict";
        var n = r(28710).charAt;
        t.exports = function(t, e, r) {
            return e + (r ? n(t, e).length : 1)
        }
    },
    25787: function(t, e, r) {
        "use strict";
        var n = r(47976)
          , i = TypeError;
        t.exports = function(t, e) {
            if (n(e, t))
                return t;
            throw i("Incorrect invocation")
        }
    },
    19670: function(t, e, r) {
        "use strict";
        var n = r(70111)
          , i = String
          , s = TypeError;
        t.exports = function(t) {
            if (n(t))
                return t;
            throw s(i(t) + " is not an object")
        }
    },
    48457: function(t, e, r) {
        "use strict";
        var n = r(49974)
          , i = r(46916)
          , s = r(47908)
          , o = r(53411)
          , a = r(97659)
          , h = r(4411)
          , l = r(26244)
          , u = r(86135)
          , c = r(18554)
          , d = r(71246)
          , f = Array;
        t.exports = function(t) {
            var e = s(t)
              , r = h(this)
              , p = arguments.length
              , m = p > 1 ? arguments[1] : void 0
              , g = void 0 !== m;
            g && (m = n(m, p > 2 ? arguments[2] : void 0));
            var v, y, _, x, b, E, T = d(e), w = 0;
            if (!T || this === f && a(T))
                for (v = l(e),
                y = r ? new this(v) : f(v); v > w; w++)
                    E = g ? m(e[w], w) : e[w],
                    u(y, w, E);
            else
                for (b = (x = c(e, T)).next,
                y = r ? new this : []; !(_ = i(b, x)).done; w++)
                    E = g ? o(x, m, [_.value, w], !0) : _.value,
                    u(y, w, E);
            return y.length = w,
            y
        }
    },
    41318: function(t, e, r) {
        "use strict";
        var n = r(45656)
          , i = r(51400)
          , s = r(26244)
          , o = function(t) {
            return function(e, r, o) {
                var a, h = n(e), l = s(h), u = i(o, l);
                if (t && r != r) {
                    for (; l > u; )
                        if ((a = h[u++]) != a)
                            return !0
                } else
                    for (; l > u; u++)
                        if ((t || u in h) && h[u] === r)
                            return t || u || 0;
                return !t && -1
            }
        };
        t.exports = {
            includes: o(!0),
            indexOf: o(!1)
        }
    },
    41589: function(t, e, r) {
        "use strict";
        var n = r(51400)
          , i = r(26244)
          , s = r(86135)
          , o = Array
          , a = Math.max;
        t.exports = function(t, e, r) {
            for (var h = i(t), l = n(e, h), u = n(void 0 === r ? h : r, h), c = o(a(u - l, 0)), d = 0; l < u; l++,
            d++)
                s(c, d, t[l]);
            return c.length = d,
            c
        }
    },
    94362: function(t, e, r) {
        "use strict";
        var n = r(41589)
          , i = Math.floor
          , s = function(t, e) {
            var r = t.length
              , h = i(r / 2);
            return r < 8 ? o(t, e) : a(t, s(n(t, 0, h), e), s(n(t, h), e), e)
        }
          , o = function(t, e) {
            for (var r, n, i = t.length, s = 1; s < i; ) {
                for (n = s,
                r = t[s]; n && e(t[n - 1], r) > 0; )
                    t[n] = t[--n];
                n !== s++ && (t[n] = r)
            }
            return t
        }
          , a = function(t, e, r, n) {
            for (var i = e.length, s = r.length, o = 0, a = 0; o < i || a < s; )
                t[o + a] = o < i && a < s ? n(e[o], r[a]) <= 0 ? e[o++] : r[a++] : o < i ? e[o++] : r[a++];
            return t
        };
        t.exports = s
    },
    53411: function(t, e, r) {
        "use strict";
        var n = r(19670)
          , i = r(99212);
        t.exports = function(t, e, r, s) {
            try {
                return s ? e(n(r)[0], r[1]) : e(r)
            } catch (e) {
                i(t, "throw", e)
            }
        }
    },
    84326: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = n({}.toString)
          , s = n("".slice);
        t.exports = function(t) {
            return s(i(t), 8, -1)
        }
    },
    70648: function(t, e, r) {
        "use strict";
        var n = r(51694)
          , i = r(60614)
          , s = r(84326)
          , o = r(5112)("toStringTag")
          , a = Object
          , h = "Arguments" === s(function() {
            return arguments
        }());
        t.exports = n ? s : function(t) {
            var e, r, n;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (r = function(t, e) {
                try {
                    return t[e]
                } catch (t) {}
            }(e = a(t), o)) ? r : h ? s(e) : "Object" === (n = s(e)) && i(e.callee) ? "Arguments" : n
        }
    },
    99920: function(t, e, r) {
        "use strict";
        var n = r(92597)
          , i = r(53887)
          , s = r(31236)
          , o = r(3070);
        t.exports = function(t, e, r) {
            for (var a = i(e), h = o.f, l = s.f, u = 0; u < a.length; u++) {
                var c = a[u];
                n(t, c) || r && n(r, c) || h(t, c, l(e, c))
            }
        }
    },
    49920: function(t, e, r) {
        "use strict";
        var n = r(47293);
        t.exports = !n((function() {
            function t() {}
            return t.prototype.constructor = null,
            Object.getPrototypeOf(new t) !== t.prototype
        }
        ))
    },
    76178: function(t) {
        "use strict";
        t.exports = function(t, e) {
            return {
                value: t,
                done: e
            }
        }
    },
    68880: function(t, e, r) {
        "use strict";
        var n = r(19781)
          , i = r(3070)
          , s = r(79114);
        t.exports = n ? function(t, e, r) {
            return i.f(t, e, s(1, r))
        }
        : function(t, e, r) {
            return t[e] = r,
            t
        }
    },
    79114: function(t) {
        "use strict";
        t.exports = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
    },
    86135: function(t, e, r) {
        "use strict";
        var n = r(34948)
          , i = r(3070)
          , s = r(79114);
        t.exports = function(t, e, r) {
            var o = n(e);
            o in t ? i.f(t, o, s(0, r)) : t[o] = r
        }
    },
    47045: function(t, e, r) {
        "use strict";
        var n = r(56339)
          , i = r(3070);
        t.exports = function(t, e, r) {
            return r.get && n(r.get, e, {
                getter: !0
            }),
            r.set && n(r.set, e, {
                setter: !0
            }),
            i.f(t, e, r)
        }
    },
    98052: function(t, e, r) {
        "use strict";
        var n = r(60614)
          , i = r(3070)
          , s = r(56339)
          , o = r(13072);
        t.exports = function(t, e, r, a) {
            a || (a = {});
            var h = a.enumerable
              , l = void 0 !== a.name ? a.name : e;
            if (n(r) && s(r, l, a),
            a.global)
                h ? t[e] = r : o(e, r);
            else {
                try {
                    a.unsafe ? t[e] && (h = !0) : delete t[e]
                } catch (t) {}
                h ? t[e] = r : i.f(t, e, {
                    value: r,
                    enumerable: !1,
                    configurable: !a.nonConfigurable,
                    writable: !a.nonWritable
                })
            }
            return t
        }
    },
    89190: function(t, e, r) {
        "use strict";
        var n = r(98052);
        t.exports = function(t, e, r) {
            for (var i in e)
                n(t, i, e[i], r);
            return t
        }
    },
    13072: function(t, e, r) {
        "use strict";
        var n = r(17854)
          , i = Object.defineProperty;
        t.exports = function(t, e) {
            try {
                i(n, t, {
                    value: e,
                    configurable: !0,
                    writable: !0
                })
            } catch (r) {
                n[t] = e
            }
            return e
        }
    },
    19781: function(t, e, r) {
        "use strict";
        var n = r(47293);
        t.exports = !n((function() {
            return 7 !== Object.defineProperty({}, 1, {
                get: function() {
                    return 7
                }
            })[1]
        }
        ))
    },
    4154: function(t) {
        "use strict";
        var e = "object" == typeof document && document.all
          , r = void 0 === e && void 0 !== e;
        t.exports = {
            all: e,
            IS_HTMLDDA: r
        }
    },
    80317: function(t, e, r) {
        "use strict";
        var n = r(17854)
          , i = r(70111)
          , s = n.document
          , o = i(s) && i(s.createElement);
        t.exports = function(t) {
            return o ? s.createElement(t) : {}
        }
    },
    48324: function(t) {
        "use strict";
        t.exports = {
            CSSRuleList: 0,
            CSSStyleDeclaration: 0,
            CSSValueList: 0,
            ClientRectList: 0,
            DOMRectList: 0,
            DOMStringList: 0,
            DOMTokenList: 1,
            DataTransferItemList: 0,
            FileList: 0,
            HTMLAllCollection: 0,
            HTMLCollection: 0,
            HTMLFormElement: 0,
            HTMLSelectElement: 0,
            MediaList: 0,
            MimeTypeArray: 0,
            NamedNodeMap: 0,
            NodeList: 1,
            PaintRequestList: 0,
            Plugin: 0,
            PluginArray: 0,
            SVGLengthList: 0,
            SVGNumberList: 0,
            SVGPathSegList: 0,
            SVGPointList: 0,
            SVGStringList: 0,
            SVGTransformList: 0,
            SourceBufferList: 0,
            StyleSheetList: 0,
            TextTrackCueList: 0,
            TextTrackList: 0,
            TouchList: 0
        }
    },
    98509: function(t, e, r) {
        "use strict";
        var n = r(80317)("span").classList
          , i = n && n.constructor && n.constructor.prototype;
        t.exports = i === Object.prototype ? void 0 : i
    },
    88113: function(t) {
        "use strict";
        t.exports = "undefined" != typeof navigator && String(navigator.userAgent) || ""
    },
    7392: function(t, e, r) {
        "use strict";
        var n, i, s = r(17854), o = r(88113), a = s.process, h = s.Deno, l = a && a.versions || h && h.version, u = l && l.v8;
        u && (i = (n = u.split("."))[0] > 0 && n[0] < 4 ? 1 : +(n[0] + n[1])),
        !i && o && (!(n = o.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = o.match(/Chrome\/(\d+)/)) && (i = +n[1]),
        t.exports = i
    },
    80748: function(t) {
        "use strict";
        t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
    },
    82109: function(t, e, r) {
        "use strict";
        var n = r(17854)
          , i = r(31236).f
          , s = r(68880)
          , o = r(98052)
          , a = r(13072)
          , h = r(99920)
          , l = r(54705);
        t.exports = function(t, e) {
            var r, u, c, d, f, p = t.target, m = t.global, g = t.stat;
            if (r = m ? n : g ? n[p] || a(p, {}) : (n[p] || {}).prototype)
                for (u in e) {
                    if (d = e[u],
                    c = t.dontCallGetSet ? (f = i(r, u)) && f.value : r[u],
                    !l(m ? u : p + (g ? "." : "#") + u, t.forced) && void 0 !== c) {
                        if (typeof d == typeof c)
                            continue;
                        h(d, c)
                    }
                    (t.sham || c && c.sham) && s(d, "sham", !0),
                    o(r, u, d, t)
                }
        }
    },
    47293: function(t) {
        "use strict";
        t.exports = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
    },
    27007: function(t, e, r) {
        "use strict";
        r(74916);
        var n = r(21470)
          , i = r(98052)
          , s = r(22261)
          , o = r(47293)
          , a = r(5112)
          , h = r(68880)
          , l = a("species")
          , u = RegExp.prototype;
        t.exports = function(t, e, r, c) {
            var d = a(t)
              , f = !o((function() {
                var e = {};
                return e[d] = function() {
                    return 7
                }
                ,
                7 !== ""[t](e)
            }
            ))
              , p = f && !o((function() {
                var e = !1
                  , r = /a/;
                return "split" === t && ((r = {}).constructor = {},
                r.constructor[l] = function() {
                    return r
                }
                ,
                r.flags = "",
                r[d] = /./[d]),
                r.exec = function() {
                    return e = !0,
                    null
                }
                ,
                r[d](""),
                !e
            }
            ));
            if (!f || !p || r) {
                var m = n(/./[d])
                  , g = e(d, ""[t], (function(t, e, r, i, o) {
                    var a = n(t)
                      , h = e.exec;
                    return h === s || h === u.exec ? f && !o ? {
                        done: !0,
                        value: m(e, r, i)
                    } : {
                        done: !0,
                        value: a(r, e, i)
                    } : {
                        done: !1
                    }
                }
                ));
                i(String.prototype, t, g[0]),
                i(u, d, g[1])
            }
            c && h(u[d], "sham", !0)
        }
    },
    22104: function(t, e, r) {
        "use strict";
        var n = r(34374)
          , i = Function.prototype
          , s = i.apply
          , o = i.call;
        t.exports = "object" == typeof Reflect && Reflect.apply || (n ? o.bind(s) : function() {
            return o.apply(s, arguments)
        }
        )
    },
    49974: function(t, e, r) {
        "use strict";
        var n = r(21470)
          , i = r(19662)
          , s = r(34374)
          , o = n(n.bind);
        t.exports = function(t, e) {
            return i(t),
            void 0 === e ? t : s ? o(t, e) : function() {
                return t.apply(e, arguments)
            }
        }
    },
    34374: function(t, e, r) {
        "use strict";
        var n = r(47293);
        t.exports = !n((function() {
            var t = function() {}
            .bind();
            return "function" != typeof t || t.hasOwnProperty("prototype")
        }
        ))
    },
    46916: function(t, e, r) {
        "use strict";
        var n = r(34374)
          , i = Function.prototype.call;
        t.exports = n ? i.bind(i) : function() {
            return i.apply(i, arguments)
        }
    },
    76530: function(t, e, r) {
        "use strict";
        var n = r(19781)
          , i = r(92597)
          , s = Function.prototype
          , o = n && Object.getOwnPropertyDescriptor
          , a = i(s, "name")
          , h = a && "something" === function() {}
        .name
          , l = a && (!n || n && o(s, "name").configurable);
        t.exports = {
            EXISTS: a,
            PROPER: h,
            CONFIGURABLE: l
        }
    },
    75668: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = r(19662);
        t.exports = function(t, e, r) {
            try {
                return n(i(Object.getOwnPropertyDescriptor(t, e)[r]))
            } catch (t) {}
        }
    },
    21470: function(t, e, r) {
        "use strict";
        var n = r(84326)
          , i = r(1702);
        t.exports = function(t) {
            if ("Function" === n(t))
                return i(t)
        }
    },
    1702: function(t, e, r) {
        "use strict";
        var n = r(34374)
          , i = Function.prototype
          , s = i.call
          , o = n && i.bind.bind(s, s);
        t.exports = n ? o : function(t) {
            return function() {
                return s.apply(t, arguments)
            }
        }
    },
    35005: function(t, e, r) {
        "use strict";
        var n = r(17854)
          , i = r(60614);
        t.exports = function(t, e) {
            return arguments.length < 2 ? (r = n[t],
            i(r) ? r : void 0) : n[t] && n[t][e];
            var r
        }
    },
    71246: function(t, e, r) {
        "use strict";
        var n = r(70648)
          , i = r(58173)
          , s = r(68554)
          , o = r(97497)
          , a = r(5112)("iterator");
        t.exports = function(t) {
            if (!s(t))
                return i(t, a) || i(t, "@@iterator") || o[n(t)]
        }
    },
    18554: function(t, e, r) {
        "use strict";
        var n = r(46916)
          , i = r(19662)
          , s = r(19670)
          , o = r(66330)
          , a = r(71246)
          , h = TypeError;
        t.exports = function(t, e) {
            var r = arguments.length < 2 ? a(t) : e;
            if (i(r))
                return s(n(r, t));
            throw h(o(t) + " is not iterable")
        }
    },
    58173: function(t, e, r) {
        "use strict";
        var n = r(19662)
          , i = r(68554);
        t.exports = function(t, e) {
            var r = t[e];
            return i(r) ? void 0 : n(r)
        }
    },
    10647: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = r(47908)
          , s = Math.floor
          , o = n("".charAt)
          , a = n("".replace)
          , h = n("".slice)
          , l = /\$([$&'`]|\d{1,2}|<[^>]*>)/g
          , u = /\$([$&'`]|\d{1,2})/g;
        t.exports = function(t, e, r, n, c, d) {
            var f = r + t.length
              , p = n.length
              , m = u;
            return void 0 !== c && (c = i(c),
            m = l),
            a(d, m, (function(i, a) {
                var l;
                switch (o(a, 0)) {
                case "$":
                    return "$";
                case "&":
                    return t;
                case "`":
                    return h(e, 0, r);
                case "'":
                    return h(e, f);
                case "<":
                    l = c[h(a, 1, -1)];
                    break;
                default:
                    var u = +a;
                    if (0 === u)
                        return i;
                    if (u > p) {
                        var d = s(u / 10);
                        return 0 === d ? i : d <= p ? void 0 === n[d - 1] ? o(a, 1) : n[d - 1] + o(a, 1) : i
                    }
                    l = n[u - 1]
                }
                return void 0 === l ? "" : l
            }
            ))
        }
    },
    17854: function(t, e, r) {
        "use strict";
        var n = function(t) {
            return t && t.Math === Math && t
        };
        t.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof r.g && r.g) || function() {
            return this
        }() || this || Function("return this")()
    },
    92597: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = r(47908)
          , s = n({}.hasOwnProperty);
        t.exports = Object.hasOwn || function(t, e) {
            return s(i(t), e)
        }
    },
    3501: function(t) {
        "use strict";
        t.exports = {}
    },
    60490: function(t, e, r) {
        "use strict";
        var n = r(35005);
        t.exports = n("document", "documentElement")
    },
    64664: function(t, e, r) {
        "use strict";
        var n = r(19781)
          , i = r(47293)
          , s = r(80317);
        t.exports = !n && !i((function() {
            return 7 !== Object.defineProperty(s("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        }
        ))
    },
    68361: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = r(47293)
          , s = r(84326)
          , o = Object
          , a = n("".split);
        t.exports = i((function() {
            return !o("z").propertyIsEnumerable(0)
        }
        )) ? function(t) {
            return "String" === s(t) ? a(t, "") : o(t)
        }
        : o
    },
    42788: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = r(60614)
          , s = r(5465)
          , o = n(Function.toString);
        i(s.inspectSource) || (s.inspectSource = function(t) {
            return o(t)
        }
        ),
        t.exports = s.inspectSource
    },
    29909: function(t, e, r) {
        "use strict";
        var n, i, s, o = r(94811), a = r(17854), h = r(70111), l = r(68880), u = r(92597), c = r(5465), d = r(6200), f = r(3501), p = "Object already initialized", m = a.TypeError, g = a.WeakMap;
        if (o || c.state) {
            var v = c.state || (c.state = new g);
            v.get = v.get,
            v.has = v.has,
            v.set = v.set,
            n = function(t, e) {
                if (v.has(t))
                    throw m(p);
                return e.facade = t,
                v.set(t, e),
                e
            }
            ,
            i = function(t) {
                return v.get(t) || {}
            }
            ,
            s = function(t) {
                return v.has(t)
            }
        } else {
            var y = d("state");
            f[y] = !0,
            n = function(t, e) {
                if (u(t, y))
                    throw m(p);
                return e.facade = t,
                l(t, y, e),
                e
            }
            ,
            i = function(t) {
                return u(t, y) ? t[y] : {}
            }
            ,
            s = function(t) {
                return u(t, y)
            }
        }
        t.exports = {
            set: n,
            get: i,
            has: s,
            enforce: function(t) {
                return s(t) ? i(t) : n(t, {})
            },
            getterFor: function(t) {
                return function(e) {
                    var r;
                    if (!h(e) || (r = i(e)).type !== t)
                        throw m("Incompatible receiver, " + t + " required");
                    return r
                }
            }
        }
    },
    97659: function(t, e, r) {
        "use strict";
        var n = r(5112)
          , i = r(97497)
          , s = n("iterator")
          , o = Array.prototype;
        t.exports = function(t) {
            return void 0 !== t && (i.Array === t || o[s] === t)
        }
    },
    60614: function(t, e, r) {
        "use strict";
        var n = r(4154)
          , i = n.all;
        t.exports = n.IS_HTMLDDA ? function(t) {
            return "function" == typeof t || t === i
        }
        : function(t) {
            return "function" == typeof t
        }
    },
    4411: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = r(47293)
          , s = r(60614)
          , o = r(70648)
          , a = r(35005)
          , h = r(42788)
          , l = function() {}
          , u = []
          , c = a("Reflect", "construct")
          , d = /^\s*(?:class|function)\b/
          , f = n(d.exec)
          , p = !d.exec(l)
          , m = function(t) {
            if (!s(t))
                return !1;
            try {
                return c(l, u, t),
                !0
            } catch (t) {
                return !1
            }
        }
          , g = function(t) {
            if (!s(t))
                return !1;
            switch (o(t)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
                return !1
            }
            try {
                return p || !!f(d, h(t))
            } catch (t) {
                return !0
            }
        };
        g.sham = !0,
        t.exports = !c || i((function() {
            var t;
            return m(m.call) || !m(Object) || !m((function() {
                t = !0
            }
            )) || t
        }
        )) ? g : m
    },
    54705: function(t, e, r) {
        "use strict";
        var n = r(47293)
          , i = r(60614)
          , s = /#|\.prototype\./
          , o = function(t, e) {
            var r = h[a(t)];
            return r === u || r !== l && (i(e) ? n(e) : !!e)
        }
          , a = o.normalize = function(t) {
            return String(t).replace(s, ".").toLowerCase()
        }
          , h = o.data = {}
          , l = o.NATIVE = "N"
          , u = o.POLYFILL = "P";
        t.exports = o
    },
    68554: function(t) {
        "use strict";
        t.exports = function(t) {
            return null == t
        }
    },
    70111: function(t, e, r) {
        "use strict";
        var n = r(60614)
          , i = r(4154)
          , s = i.all;
        t.exports = i.IS_HTMLDDA ? function(t) {
            return "object" == typeof t ? null !== t : n(t) || t === s
        }
        : function(t) {
            return "object" == typeof t ? null !== t : n(t)
        }
    },
    31913: function(t) {
        "use strict";
        t.exports = !1
    },
    52190: function(t, e, r) {
        "use strict";
        var n = r(35005)
          , i = r(60614)
          , s = r(47976)
          , o = r(43307)
          , a = Object;
        t.exports = o ? function(t) {
            return "symbol" == typeof t
        }
        : function(t) {
            var e = n("Symbol");
            return i(e) && s(e.prototype, a(t))
        }
    },
    99212: function(t, e, r) {
        "use strict";
        var n = r(46916)
          , i = r(19670)
          , s = r(58173);
        t.exports = function(t, e, r) {
            var o, a;
            i(t);
            try {
                if (!(o = s(t, "return"))) {
                    if ("throw" === e)
                        throw r;
                    return r
                }
                o = n(o, t)
            } catch (t) {
                a = !0,
                o = t
            }
            if ("throw" === e)
                throw r;
            if (a)
                throw o;
            return i(o),
            r
        }
    },
    63061: function(t, e, r) {
        "use strict";
        var n = r(13383).IteratorPrototype
          , i = r(70030)
          , s = r(79114)
          , o = r(58003)
          , a = r(97497)
          , h = function() {
            return this
        };
        t.exports = function(t, e, r, l) {
            var u = e + " Iterator";
            return t.prototype = i(n, {
                next: s(+!l, r)
            }),
            o(t, u, !1, !0),
            a[u] = h,
            t
        }
    },
    51656: function(t, e, r) {
        "use strict";
        var n = r(82109)
          , i = r(46916)
          , s = r(31913)
          , o = r(76530)
          , a = r(60614)
          , h = r(63061)
          , l = r(79518)
          , u = r(27674)
          , c = r(58003)
          , d = r(68880)
          , f = r(98052)
          , p = r(5112)
          , m = r(97497)
          , g = r(13383)
          , v = o.PROPER
          , y = o.CONFIGURABLE
          , _ = g.IteratorPrototype
          , x = g.BUGGY_SAFARI_ITERATORS
          , b = p("iterator")
          , E = "keys"
          , T = "values"
          , w = "entries"
          , S = function() {
            return this
        };
        t.exports = function(t, e, r, o, p, g, A) {
            h(r, e, o);
            var C, R, P, I = function(t) {
                if (t === p && k)
                    return k;
                if (!x && t in O)
                    return O[t];
                switch (t) {
                case E:
                case T:
                case w:
                    return function() {
                        return new r(this,t)
                    }
                }
                return function() {
                    return new r(this)
                }
            }, M = e + " Iterator", D = !1, O = t.prototype, B = O[b] || O["@@iterator"] || p && O[p], k = !x && B || I(p), L = "Array" === e && O.entries || B;
            if (L && (C = l(L.call(new t))) !== Object.prototype && C.next && (s || l(C) === _ || (u ? u(C, _) : a(C[b]) || f(C, b, S)),
            c(C, M, !0, !0),
            s && (m[M] = S)),
            v && p === T && B && B.name !== T && (!s && y ? d(O, "name", T) : (D = !0,
            k = function() {
                return i(B, this)
            }
            )),
            p)
                if (R = {
                    values: I(T),
                    keys: g ? k : I(E),
                    entries: I(w)
                },
                A)
                    for (P in R)
                        (x || D || !(P in O)) && f(O, P, R[P]);
                else
                    n({
                        target: e,
                        proto: !0,
                        forced: x || D
                    }, R);
            return s && !A || O[b] === k || f(O, b, k, {
                name: p
            }),
            m[e] = k,
            R
        }
    },
    13383: function(t, e, r) {
        "use strict";
        var n, i, s, o = r(47293), a = r(60614), h = r(70111), l = r(70030), u = r(79518), c = r(98052), d = r(5112), f = r(31913), p = d("iterator"), m = !1;
        [].keys && ("next"in (s = [].keys()) ? (i = u(u(s))) !== Object.prototype && (n = i) : m = !0),
        !h(n) || o((function() {
            var t = {};
            return n[p].call(t) !== t
        }
        )) ? n = {} : f && (n = l(n)),
        a(n[p]) || c(n, p, (function() {
            return this
        }
        )),
        t.exports = {
            IteratorPrototype: n,
            BUGGY_SAFARI_ITERATORS: m
        }
    },
    97497: function(t) {
        "use strict";
        t.exports = {}
    },
    26244: function(t, e, r) {
        "use strict";
        var n = r(17466);
        t.exports = function(t) {
            return n(t.length)
        }
    },
    56339: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = r(47293)
          , s = r(60614)
          , o = r(92597)
          , a = r(19781)
          , h = r(76530).CONFIGURABLE
          , l = r(42788)
          , u = r(29909)
          , c = u.enforce
          , d = u.get
          , f = String
          , p = Object.defineProperty
          , m = n("".slice)
          , g = n("".replace)
          , v = n([].join)
          , y = a && !i((function() {
            return 8 !== p((function() {}
            ), "length", {
                value: 8
            }).length
        }
        ))
          , _ = String(String).split("String")
          , x = t.exports = function(t, e, r) {
            "Symbol(" === m(f(e), 0, 7) && (e = "[" + g(f(e), /^Symbol\(([^)]*)\)/, "$1") + "]"),
            r && r.getter && (e = "get " + e),
            r && r.setter && (e = "set " + e),
            (!o(t, "name") || h && t.name !== e) && (a ? p(t, "name", {
                value: e,
                configurable: !0
            }) : t.name = e),
            y && r && o(r, "arity") && t.length !== r.arity && p(t, "length", {
                value: r.arity
            });
            try {
                r && o(r, "constructor") && r.constructor ? a && p(t, "prototype", {
                    writable: !1
                }) : t.prototype && (t.prototype = void 0)
            } catch (t) {}
            var n = c(t);
            return o(n, "source") || (n.source = v(_, "string" == typeof e ? e : "")),
            t
        }
        ;
        Function.prototype.toString = x((function() {
            return s(this) && d(this).source || l(this)
        }
        ), "toString")
    },
    74758: function(t) {
        "use strict";
        var e = Math.ceil
          , r = Math.floor;
        t.exports = Math.trunc || function(t) {
            var n = +t;
            return (n > 0 ? r : e)(n)
        }
    },
    21574: function(t, e, r) {
        "use strict";
        var n = r(19781)
          , i = r(1702)
          , s = r(46916)
          , o = r(47293)
          , a = r(81956)
          , h = r(25181)
          , l = r(55296)
          , u = r(47908)
          , c = r(68361)
          , d = Object.assign
          , f = Object.defineProperty
          , p = i([].concat);
        t.exports = !d || o((function() {
            if (n && 1 !== d({
                b: 1
            }, d(f({}, "a", {
                enumerable: !0,
                get: function() {
                    f(this, "b", {
                        value: 3,
                        enumerable: !1
                    })
                }
            }), {
                b: 2
            })).b)
                return !0;
            var t = {}
              , e = {}
              , r = Symbol("assign detection")
              , i = "abcdefghijklmnopqrst";
            return t[r] = 7,
            i.split("").forEach((function(t) {
                e[t] = t
            }
            )),
            7 !== d({}, t)[r] || a(d({}, e)).join("") !== i
        }
        )) ? function(t, e) {
            for (var r = u(t), i = arguments.length, o = 1, d = h.f, f = l.f; i > o; )
                for (var m, g = c(arguments[o++]), v = d ? p(a(g), d(g)) : a(g), y = v.length, _ = 0; y > _; )
                    m = v[_++],
                    n && !s(f, g, m) || (r[m] = g[m]);
            return r
        }
        : d
    },
    70030: function(t, e, r) {
        "use strict";
        var n, i = r(19670), s = r(36048), o = r(80748), a = r(3501), h = r(60490), l = r(80317), u = r(6200), c = "prototype", d = "script", f = u("IE_PROTO"), p = function() {}, m = function(t) {
            return "<" + d + ">" + t + "</" + d + ">"
        }, g = function(t) {
            t.write(m("")),
            t.close();
            var e = t.parentWindow.Object;
            return t = null,
            e
        }, v = function() {
            try {
                n = new ActiveXObject("htmlfile")
            } catch (t) {}
            var t, e, r;
            v = "undefined" != typeof document ? document.domain && n ? g(n) : (e = l("iframe"),
            r = "java" + d + ":",
            e.style.display = "none",
            h.appendChild(e),
            e.src = String(r),
            (t = e.contentWindow.document).open(),
            t.write(m("document.F=Object")),
            t.close(),
            t.F) : g(n);
            for (var i = o.length; i--; )
                delete v[c][o[i]];
            return v()
        };
        a[f] = !0,
        t.exports = Object.create || function(t, e) {
            var r;
            return null !== t ? (p[c] = i(t),
            r = new p,
            p[c] = null,
            r[f] = t) : r = v(),
            void 0 === e ? r : s.f(r, e)
        }
    },
    36048: function(t, e, r) {
        "use strict";
        var n = r(19781)
          , i = r(3353)
          , s = r(3070)
          , o = r(19670)
          , a = r(45656)
          , h = r(81956);
        e.f = n && !i ? Object.defineProperties : function(t, e) {
            o(t);
            for (var r, n = a(e), i = h(e), l = i.length, u = 0; l > u; )
                s.f(t, r = i[u++], n[r]);
            return t
        }
    },
    3070: function(t, e, r) {
        "use strict";
        var n = r(19781)
          , i = r(64664)
          , s = r(3353)
          , o = r(19670)
          , a = r(34948)
          , h = TypeError
          , l = Object.defineProperty
          , u = Object.getOwnPropertyDescriptor
          , c = "enumerable"
          , d = "configurable"
          , f = "writable";
        e.f = n ? s ? function(t, e, r) {
            if (o(t),
            e = a(e),
            o(r),
            "function" == typeof t && "prototype" === e && "value"in r && f in r && !r[f]) {
                var n = u(t, e);
                n && n[f] && (t[e] = r.value,
                r = {
                    configurable: d in r ? r[d] : n[d],
                    enumerable: c in r ? r[c] : n[c],
                    writable: !1
                })
            }
            return l(t, e, r)
        }
        : l : function(t, e, r) {
            if (o(t),
            e = a(e),
            o(r),
            i)
                try {
                    return l(t, e, r)
                } catch (t) {}
            if ("get"in r || "set"in r)
                throw h("Accessors not supported");
            return "value"in r && (t[e] = r.value),
            t
        }
    },
    31236: function(t, e, r) {
        "use strict";
        var n = r(19781)
          , i = r(46916)
          , s = r(55296)
          , o = r(79114)
          , a = r(45656)
          , h = r(34948)
          , l = r(92597)
          , u = r(64664)
          , c = Object.getOwnPropertyDescriptor;
        e.f = n ? c : function(t, e) {
            if (t = a(t),
            e = h(e),
            u)
                try {
                    return c(t, e)
                } catch (t) {}
            if (l(t, e))
                return o(!i(s.f, t, e), t[e])
        }
    },
    8006: function(t, e, r) {
        "use strict";
        var n = r(16324)
          , i = r(80748).concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(t) {
            return n(t, i)
        }
    },
    25181: function(t, e) {
        "use strict";
        e.f = Object.getOwnPropertySymbols
    },
    79518: function(t, e, r) {
        "use strict";
        var n = r(92597)
          , i = r(60614)
          , s = r(47908)
          , o = r(6200)
          , a = r(49920)
          , h = o("IE_PROTO")
          , l = Object
          , u = l.prototype;
        t.exports = a ? l.getPrototypeOf : function(t) {
            var e = s(t);
            if (n(e, h))
                return e[h];
            var r = e.constructor;
            return i(r) && e instanceof r ? r.prototype : e instanceof l ? u : null
        }
    },
    47976: function(t, e, r) {
        "use strict";
        var n = r(1702);
        t.exports = n({}.isPrototypeOf)
    },
    16324: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = r(92597)
          , s = r(45656)
          , o = r(41318).indexOf
          , a = r(3501)
          , h = n([].push);
        t.exports = function(t, e) {
            var r, n = s(t), l = 0, u = [];
            for (r in n)
                !i(a, r) && i(n, r) && h(u, r);
            for (; e.length > l; )
                i(n, r = e[l++]) && (~o(u, r) || h(u, r));
            return u
        }
    },
    81956: function(t, e, r) {
        "use strict";
        var n = r(16324)
          , i = r(80748);
        t.exports = Object.keys || function(t) {
            return n(t, i)
        }
    },
    55296: function(t, e) {
        "use strict";
        var r = {}.propertyIsEnumerable
          , n = Object.getOwnPropertyDescriptor
          , i = n && !r.call({
            1: 2
        }, 1);
        e.f = i ? function(t) {
            var e = n(this, t);
            return !!e && e.enumerable
        }
        : r
    },
    27674: function(t, e, r) {
        "use strict";
        var n = r(75668)
          , i = r(19670)
          , s = r(96077);
        t.exports = Object.setPrototypeOf || ("__proto__"in {} ? function() {
            var t, e = !1, r = {};
            try {
                (t = n(Object.prototype, "__proto__", "set"))(r, []),
                e = r instanceof Array
            } catch (t) {}
            return function(r, n) {
                return i(r),
                s(n),
                e ? t(r, n) : r.__proto__ = n,
                r
            }
        }() : void 0)
    },
    92140: function(t, e, r) {
        "use strict";
        var n = r(46916)
          , i = r(60614)
          , s = r(70111)
          , o = TypeError;
        t.exports = function(t, e) {
            var r, a;
            if ("string" === e && i(r = t.toString) && !s(a = n(r, t)))
                return a;
            if (i(r = t.valueOf) && !s(a = n(r, t)))
                return a;
            if ("string" !== e && i(r = t.toString) && !s(a = n(r, t)))
                return a;
            throw o("Can't convert object to primitive value")
        }
    },
    53887: function(t, e, r) {
        "use strict";
        var n = r(35005)
          , i = r(1702)
          , s = r(8006)
          , o = r(25181)
          , a = r(19670)
          , h = i([].concat);
        t.exports = n("Reflect", "ownKeys") || function(t) {
            var e = s.f(a(t))
              , r = o.f;
            return r ? h(e, r(t)) : e
        }
    },
    97651: function(t, e, r) {
        "use strict";
        var n = r(46916)
          , i = r(19670)
          , s = r(60614)
          , o = r(84326)
          , a = r(22261)
          , h = TypeError;
        t.exports = function(t, e) {
            var r = t.exec;
            if (s(r)) {
                var l = n(r, t, e);
                return null !== l && i(l),
                l
            }
            if ("RegExp" === o(t))
                return n(a, t, e);
            throw h("RegExp#exec called on incompatible receiver")
        }
    },
    22261: function(t, e, r) {
        "use strict";
        var n, i, s = r(46916), o = r(1702), a = r(41340), h = r(67066), l = r(52999), u = r(72309), c = r(70030), d = r(29909).get, f = r(9441), p = r(38173), m = u("native-string-replace", String.prototype.replace), g = RegExp.prototype.exec, v = g, y = o("".charAt), _ = o("".indexOf), x = o("".replace), b = o("".slice), E = (i = /b*/g,
        s(g, n = /a/, "a"),
        s(g, i, "a"),
        0 !== n.lastIndex || 0 !== i.lastIndex), T = l.BROKEN_CARET, w = void 0 !== /()??/.exec("")[1];
        (E || w || T || f || p) && (v = function(t) {
            var e, r, n, i, o, l, u, f = this, p = d(f), S = a(t), A = p.raw;
            if (A)
                return A.lastIndex = f.lastIndex,
                e = s(v, A, S),
                f.lastIndex = A.lastIndex,
                e;
            var C = p.groups
              , R = T && f.sticky
              , P = s(h, f)
              , I = f.source
              , M = 0
              , D = S;
            if (R && (P = x(P, "y", ""),
            -1 === _(P, "g") && (P += "g"),
            D = b(S, f.lastIndex),
            f.lastIndex > 0 && (!f.multiline || f.multiline && "\n" !== y(S, f.lastIndex - 1)) && (I = "(?: " + I + ")",
            D = " " + D,
            M++),
            r = new RegExp("^(?:" + I + ")",P)),
            w && (r = new RegExp("^" + I + "$(?!\\s)",P)),
            E && (n = f.lastIndex),
            i = s(g, R ? r : f, D),
            R ? i ? (i.input = b(i.input, M),
            i[0] = b(i[0], M),
            i.index = f.lastIndex,
            f.lastIndex += i[0].length) : f.lastIndex = 0 : E && i && (f.lastIndex = f.global ? i.index + i[0].length : n),
            w && i && i.length > 1 && s(m, i[0], r, (function() {
                for (o = 1; o < arguments.length - 2; o++)
                    void 0 === arguments[o] && (i[o] = void 0)
            }
            )),
            i && C)
                for (i.groups = l = c(null),
                o = 0; o < C.length; o++)
                    l[(u = C[o])[0]] = i[u[1]];
            return i
        }
        ),
        t.exports = v
    },
    67066: function(t, e, r) {
        "use strict";
        var n = r(19670);
        t.exports = function() {
            var t = n(this)
              , e = "";
            return t.hasIndices && (e += "d"),
            t.global && (e += "g"),
            t.ignoreCase && (e += "i"),
            t.multiline && (e += "m"),
            t.dotAll && (e += "s"),
            t.unicode && (e += "u"),
            t.unicodeSets && (e += "v"),
            t.sticky && (e += "y"),
            e
        }
    },
    52999: function(t, e, r) {
        "use strict";
        var n = r(47293)
          , i = r(17854).RegExp
          , s = n((function() {
            var t = i("a", "y");
            return t.lastIndex = 2,
            null !== t.exec("abcd")
        }
        ))
          , o = s || n((function() {
            return !i("a", "y").sticky
        }
        ))
          , a = s || n((function() {
            var t = i("^r", "gy");
            return t.lastIndex = 2,
            null !== t.exec("str")
        }
        ));
        t.exports = {
            BROKEN_CARET: a,
            MISSED_STICKY: o,
            UNSUPPORTED_Y: s
        }
    },
    9441: function(t, e, r) {
        "use strict";
        var n = r(47293)
          , i = r(17854).RegExp;
        t.exports = n((function() {
            var t = i(".", "s");
            return !(t.dotAll && t.exec("\n") && "s" === t.flags)
        }
        ))
    },
    38173: function(t, e, r) {
        "use strict";
        var n = r(47293)
          , i = r(17854).RegExp;
        t.exports = n((function() {
            var t = i("(?<a>b)", "g");
            return "b" !== t.exec("b").groups.a || "bc" !== "b".replace(t, "$<a>c")
        }
        ))
    },
    84488: function(t, e, r) {
        "use strict";
        var n = r(68554)
          , i = TypeError;
        t.exports = function(t) {
            if (n(t))
                throw i("Can't call method on " + t);
            return t
        }
    },
    58003: function(t, e, r) {
        "use strict";
        var n = r(3070).f
          , i = r(92597)
          , s = r(5112)("toStringTag");
        t.exports = function(t, e, r) {
            t && !r && (t = t.prototype),
            t && !i(t, s) && n(t, s, {
                configurable: !0,
                value: e
            })
        }
    },
    6200: function(t, e, r) {
        "use strict";
        var n = r(72309)
          , i = r(69711)
          , s = n("keys");
        t.exports = function(t) {
            return s[t] || (s[t] = i(t))
        }
    },
    5465: function(t, e, r) {
        "use strict";
        var n = r(17854)
          , i = r(13072)
          , s = "__core-js_shared__"
          , o = n[s] || i(s, {});
        t.exports = o
    },
    72309: function(t, e, r) {
        "use strict";
        var n = r(31913)
          , i = r(5465);
        (t.exports = function(t, e) {
            return i[t] || (i[t] = void 0 !== e ? e : {})
        }
        )("versions", []).push({
            version: "3.32.1",
            mode: n ? "pure" : "global",
            copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
            license: "https://github.com/zloirock/core-js/blob/v3.32.1/LICENSE",
            source: "https://github.com/zloirock/core-js"
        })
    },
    28710: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = r(19303)
          , s = r(41340)
          , o = r(84488)
          , a = n("".charAt)
          , h = n("".charCodeAt)
          , l = n("".slice)
          , u = function(t) {
            return function(e, r) {
                var n, u, c = s(o(e)), d = i(r), f = c.length;
                return d < 0 || d >= f ? t ? "" : void 0 : (n = h(c, d)) < 55296 || n > 56319 || d + 1 === f || (u = h(c, d + 1)) < 56320 || u > 57343 ? t ? a(c, d) : n : t ? l(c, d, d + 2) : u - 56320 + (n - 55296 << 10) + 65536
            }
        };
        t.exports = {
            codeAt: u(!1),
            charAt: u(!0)
        }
    },
    33197: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = 2147483647
          , s = /[^\0-\u007E]/
          , o = /[.\u3002\uFF0E\uFF61]/g
          , a = "Overflow: input needs wider integers to process"
          , h = RangeError
          , l = n(o.exec)
          , u = Math.floor
          , c = String.fromCharCode
          , d = n("".charCodeAt)
          , f = n([].join)
          , p = n([].push)
          , m = n("".replace)
          , g = n("".split)
          , v = n("".toLowerCase)
          , y = function(t) {
            return t + 22 + 75 * (t < 26)
        }
          , _ = function(t, e, r) {
            var n = 0;
            for (t = r ? u(t / 700) : t >> 1,
            t += u(t / e); t > 455; )
                t = u(t / 35),
                n += 36;
            return u(n + 36 * t / (t + 38))
        }
          , x = function(t) {
            var e = [];
            t = function(t) {
                for (var e = [], r = 0, n = t.length; r < n; ) {
                    var i = d(t, r++);
                    if (i >= 55296 && i <= 56319 && r < n) {
                        var s = d(t, r++);
                        56320 == (64512 & s) ? p(e, ((1023 & i) << 10) + (1023 & s) + 65536) : (p(e, i),
                        r--)
                    } else
                        p(e, i)
                }
                return e
            }(t);
            var r, n, s = t.length, o = 128, l = 0, m = 72;
            for (r = 0; r < t.length; r++)
                (n = t[r]) < 128 && p(e, c(n));
            var g = e.length
              , v = g;
            for (g && p(e, "-"); v < s; ) {
                var x = i;
                for (r = 0; r < t.length; r++)
                    (n = t[r]) >= o && n < x && (x = n);
                var b = v + 1;
                if (x - o > u((i - l) / b))
                    throw h(a);
                for (l += (x - o) * b,
                o = x,
                r = 0; r < t.length; r++) {
                    if ((n = t[r]) < o && ++l > i)
                        throw h(a);
                    if (n === o) {
                        for (var E = l, T = 36; ; ) {
                            var w = T <= m ? 1 : T >= m + 26 ? 26 : T - m;
                            if (E < w)
                                break;
                            var S = E - w
                              , A = 36 - w;
                            p(e, c(y(w + S % A))),
                            E = u(S / A),
                            T += 36
                        }
                        p(e, c(y(E))),
                        m = _(l, b, v === g),
                        l = 0,
                        v++
                    }
                }
                l++,
                o++
            }
            return f(e, "")
        };
        t.exports = function(t) {
            var e, r, n = [], i = g(m(v(t), o, "."), ".");
            for (e = 0; e < i.length; e++)
                r = i[e],
                p(n, l(s, r) ? "xn--" + x(r) : r);
            return f(n, ".")
        }
    },
    36293: function(t, e, r) {
        "use strict";
        var n = r(7392)
          , i = r(47293)
          , s = r(17854).String;
        t.exports = !!Object.getOwnPropertySymbols && !i((function() {
            var t = Symbol("symbol detection");
            return !s(t) || !(Object(t)instanceof Symbol) || !Symbol.sham && n && n < 41
        }
        ))
    },
    51400: function(t, e, r) {
        "use strict";
        var n = r(19303)
          , i = Math.max
          , s = Math.min;
        t.exports = function(t, e) {
            var r = n(t);
            return r < 0 ? i(r + e, 0) : s(r, e)
        }
    },
    45656: function(t, e, r) {
        "use strict";
        var n = r(68361)
          , i = r(84488);
        t.exports = function(t) {
            return n(i(t))
        }
    },
    19303: function(t, e, r) {
        "use strict";
        var n = r(74758);
        t.exports = function(t) {
            var e = +t;
            return e != e || 0 === e ? 0 : n(e)
        }
    },
    17466: function(t, e, r) {
        "use strict";
        var n = r(19303)
          , i = Math.min;
        t.exports = function(t) {
            return t > 0 ? i(n(t), 9007199254740991) : 0
        }
    },
    47908: function(t, e, r) {
        "use strict";
        var n = r(84488)
          , i = Object;
        t.exports = function(t) {
            return i(n(t))
        }
    },
    57593: function(t, e, r) {
        "use strict";
        var n = r(46916)
          , i = r(70111)
          , s = r(52190)
          , o = r(58173)
          , a = r(92140)
          , h = r(5112)
          , l = TypeError
          , u = h("toPrimitive");
        t.exports = function(t, e) {
            if (!i(t) || s(t))
                return t;
            var r, h = o(t, u);
            if (h) {
                if (void 0 === e && (e = "default"),
                r = n(h, t, e),
                !i(r) || s(r))
                    return r;
                throw l("Can't convert object to primitive value")
            }
            return void 0 === e && (e = "number"),
            a(t, e)
        }
    },
    34948: function(t, e, r) {
        "use strict";
        var n = r(57593)
          , i = r(52190);
        t.exports = function(t) {
            var e = n(t, "string");
            return i(e) ? e : e + ""
        }
    },
    51694: function(t, e, r) {
        "use strict";
        var n = {};
        n[r(5112)("toStringTag")] = "z",
        t.exports = "[object z]" === String(n)
    },
    41340: function(t, e, r) {
        "use strict";
        var n = r(70648)
          , i = String;
        t.exports = function(t) {
            if ("Symbol" === n(t))
                throw TypeError("Cannot convert a Symbol value to a string");
            return i(t)
        }
    },
    66330: function(t) {
        "use strict";
        var e = String;
        t.exports = function(t) {
            try {
                return e(t)
            } catch (t) {
                return "Object"
            }
        }
    },
    69711: function(t, e, r) {
        "use strict";
        var n = r(1702)
          , i = 0
          , s = Math.random()
          , o = n(1..toString);
        t.exports = function(t) {
            return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++i + s, 36)
        }
    },
    85143: function(t, e, r) {
        "use strict";
        var n = r(47293)
          , i = r(5112)
          , s = r(19781)
          , o = r(31913)
          , a = i("iterator");
        t.exports = !n((function() {
            var t = new URL("b?a=1&b=2&c=3","http://a")
              , e = t.searchParams
              , r = new URLSearchParams("a=1&a=2&b=3")
              , n = "";
            return t.pathname = "c%20d",
            e.forEach((function(t, r) {
                e.delete("b"),
                n += r + t
            }
            )),
            r.delete("a", 2),
            r.delete("b", void 0),
            o && (!t.toJSON || !r.has("a", 1) || r.has("a", 2) || !r.has("a", void 0) || r.has("b")) || !e.size && (o || !s) || !e.sort || "http://a/c%20d?a=1&c=3" !== t.href || "3" !== e.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !e[a] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://тест").host || "#%D0%B1" !== new URL("http://a#б").hash || "a1c3" !== n || "x" !== new URL("http://x",void 0).host
        }
        ))
    },
    43307: function(t, e, r) {
        "use strict";
        var n = r(36293);
        t.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator
    },
    3353: function(t, e, r) {
        "use strict";
        var n = r(19781)
          , i = r(47293);
        t.exports = n && i((function() {
            return 42 !== Object.defineProperty((function() {}
            ), "prototype", {
                value: 42,
                writable: !1
            }).prototype
        }
        ))
    },
    48053: function(t) {
        "use strict";
        var e = TypeError;
        t.exports = function(t, r) {
            if (t < r)
                throw e("Not enough arguments");
            return t
        }
    },
    94811: function(t, e, r) {
        "use strict";
        var n = r(17854)
          , i = r(60614)
          , s = n.WeakMap;
        t.exports = i(s) && /native code/.test(String(s))
    },
    5112: function(t, e, r) {
        "use strict";
        var n = r(17854)
          , i = r(72309)
          , s = r(92597)
          , o = r(69711)
          , a = r(36293)
          , h = r(43307)
          , l = n.Symbol
          , u = i("wks")
          , c = h ? l.for || l : l && l.withoutSetter || o;
        t.exports = function(t) {
            return s(u, t) || (u[t] = a && s(l, t) ? l[t] : c("Symbol." + t)),
            u[t]
        }
    },
    66992: function(t, e, r) {
        "use strict";
        var n = r(45656)
          , i = r(51223)
          , s = r(97497)
          , o = r(29909)
          , a = r(3070).f
          , h = r(51656)
          , l = r(76178)
          , u = r(31913)
          , c = r(19781)
          , d = "Array Iterator"
          , f = o.set
          , p = o.getterFor(d);
        t.exports = h(Array, "Array", (function(t, e) {
            f(this, {
                type: d,
                target: n(t),
                index: 0,
                kind: e
            })
        }
        ), (function() {
            var t = p(this)
              , e = t.target
              , r = t.kind
              , n = t.index++;
            if (!e || n >= e.length)
                return t.target = void 0,
                l(void 0, !0);
            switch (r) {
            case "keys":
                return l(n, !1);
            case "values":
                return l(e[n], !1)
            }
            return l([n, e[n]], !1)
        }
        ), "values");
        var m = s.Arguments = s.Array;
        if (i("keys"),
        i("values"),
        i("entries"),
        !u && c && "values" !== m.name)
            try {
                a(m, "name", {
                    value: "values"
                })
            } catch (t) {}
    },
    74916: function(t, e, r) {
        "use strict";
        var n = r(82109)
          , i = r(22261);
        n({
            target: "RegExp",
            proto: !0,
            forced: /./.exec !== i
        }, {
            exec: i
        })
    },
    78783: function(t, e, r) {
        "use strict";
        var n = r(28710).charAt
          , i = r(41340)
          , s = r(29909)
          , o = r(51656)
          , a = r(76178)
          , h = "String Iterator"
          , l = s.set
          , u = s.getterFor(h);
        o(String, "String", (function(t) {
            l(this, {
                type: h,
                string: i(t),
                index: 0
            })
        }
        ), (function() {
            var t, e = u(this), r = e.string, i = e.index;
            return i >= r.length ? a(void 0, !0) : (t = n(r, i),
            e.index += t.length,
            a(t, !1))
        }
        ))
    },
    15306: function(t, e, r) {
        "use strict";
        var n = r(22104)
          , i = r(46916)
          , s = r(1702)
          , o = r(27007)
          , a = r(47293)
          , h = r(19670)
          , l = r(60614)
          , u = r(68554)
          , c = r(19303)
          , d = r(17466)
          , f = r(41340)
          , p = r(84488)
          , m = r(31530)
          , g = r(58173)
          , v = r(10647)
          , y = r(97651)
          , _ = r(5112)("replace")
          , x = Math.max
          , b = Math.min
          , E = s([].concat)
          , T = s([].push)
          , w = s("".indexOf)
          , S = s("".slice)
          , A = "$0" === "a".replace(/./, "$0")
          , C = !!/./[_] && "" === /./[_]("a", "$0");
        o("replace", (function(t, e, r) {
            var s = C ? "$" : "$0";
            return [function(t, r) {
                var n = p(this)
                  , s = u(t) ? void 0 : g(t, _);
                return s ? i(s, t, n, r) : i(e, f(n), t, r)
            }
            , function(t, i) {
                var o = h(this)
                  , a = f(t);
                if ("string" == typeof i && -1 === w(i, s) && -1 === w(i, "$<")) {
                    var u = r(e, o, a, i);
                    if (u.done)
                        return u.value
                }
                var p = l(i);
                p || (i = f(i));
                var g, _ = o.global;
                _ && (g = o.unicode,
                o.lastIndex = 0);
                for (var A, C = []; null !== (A = y(o, a)) && (T(C, A),
                _); )
                    "" === f(A[0]) && (o.lastIndex = m(a, d(o.lastIndex), g));
                for (var R, P = "", I = 0, M = 0; M < C.length; M++) {
                    for (var D, O = f((A = C[M])[0]), B = x(b(c(A.index), a.length), 0), k = [], L = 1; L < A.length; L++)
                        T(k, void 0 === (R = A[L]) ? R : String(R));
                    var N = A.groups;
                    if (p) {
                        var F = E([O], k, B, a);
                        void 0 !== N && T(F, N),
                        D = f(n(i, void 0, F))
                    } else
                        D = v(O, a, B, k, N, i);
                    B >= I && (P += S(a, I, B) + D,
                    I = B + O.length)
                }
                return P + S(a, I)
            }
            ]
        }
        ), !!a((function() {
            var t = /./;
            return t.exec = function() {
                var t = [];
                return t.groups = {
                    a: "7"
                },
                t
            }
            ,
            "7" !== "".replace(t, "$<a>")
        }
        )) || !A || C)
    },
    33948: function(t, e, r) {
        "use strict";
        var n = r(17854)
          , i = r(48324)
          , s = r(98509)
          , o = r(66992)
          , a = r(68880)
          , h = r(5112)
          , l = h("iterator")
          , u = h("toStringTag")
          , c = o.values
          , d = function(t, e) {
            if (t) {
                if (t[l] !== c)
                    try {
                        a(t, l, c)
                    } catch (e) {
                        t[l] = c
                    }
                if (t[u] || a(t, u, e),
                i[e])
                    for (var r in o)
                        if (t[r] !== o[r])
                            try {
                                a(t, r, o[r])
                            } catch (e) {
                                t[r] = o[r]
                            }
            }
        };
        for (var f in i)
            d(n[f] && n[f].prototype, f);
        d(s, "DOMTokenList")
    },
    65556: function(t, e, r) {
        "use strict";
        r(66992);
        var n = r(82109)
          , i = r(17854)
          , s = r(46916)
          , o = r(1702)
          , a = r(19781)
          , h = r(85143)
          , l = r(98052)
          , u = r(47045)
          , c = r(89190)
          , d = r(58003)
          , f = r(63061)
          , p = r(29909)
          , m = r(25787)
          , g = r(60614)
          , v = r(92597)
          , y = r(49974)
          , _ = r(70648)
          , x = r(19670)
          , b = r(70111)
          , E = r(41340)
          , T = r(70030)
          , w = r(79114)
          , S = r(18554)
          , A = r(71246)
          , C = r(48053)
          , R = r(5112)
          , P = r(94362)
          , I = R("iterator")
          , M = "URLSearchParams"
          , D = M + "Iterator"
          , O = p.set
          , B = p.getterFor(M)
          , k = p.getterFor(D)
          , L = Object.getOwnPropertyDescriptor
          , N = function(t) {
            if (!a)
                return i[t];
            var e = L(i, t);
            return e && e.value
        }
          , F = N("fetch")
          , U = N("Request")
          , G = N("Headers")
          , j = U && U.prototype
          , z = G && G.prototype
          , H = i.RegExp
          , $ = i.TypeError
          , X = i.decodeURIComponent
          , V = i.encodeURIComponent
          , W = o("".charAt)
          , Y = o([].join)
          , q = o([].push)
          , K = o("".replace)
          , Z = o([].shift)
          , J = o([].splice)
          , Q = o("".split)
          , tt = o("".slice)
          , et = /\+/g
          , rt = Array(4)
          , nt = function(t) {
            return rt[t - 1] || (rt[t - 1] = H("((?:%[\\da-f]{2}){" + t + "})", "gi"))
        }
          , it = function(t) {
            try {
                return X(t)
            } catch (e) {
                return t
            }
        }
          , st = function(t) {
            var e = K(t, et, " ")
              , r = 4;
            try {
                return X(e)
            } catch (t) {
                for (; r; )
                    e = K(e, nt(r--), it);
                return e
            }
        }
          , ot = /[!'()~]|%20/g
          , at = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+"
        }
          , ht = function(t) {
            return at[t]
        }
          , lt = function(t) {
            return K(V(t), ot, ht)
        }
          , ut = f((function(t, e) {
            O(this, {
                type: D,
                iterator: S(B(t).entries),
                kind: e
            })
        }
        ), "Iterator", (function() {
            var t = k(this)
              , e = t.kind
              , r = t.iterator.next()
              , n = r.value;
            return r.done || (r.value = "keys" === e ? n.key : "values" === e ? n.value : [n.key, n.value]),
            r
        }
        ), !0)
          , ct = function(t) {
            this.entries = [],
            this.url = null,
            void 0 !== t && (b(t) ? this.parseObject(t) : this.parseQuery("string" == typeof t ? "?" === W(t, 0) ? tt(t, 1) : t : E(t)))
        };
        ct.prototype = {
            type: M,
            bindURL: function(t) {
                this.url = t,
                this.update()
            },
            parseObject: function(t) {
                var e, r, n, i, o, a, h, l = A(t);
                if (l)
                    for (r = (e = S(t, l)).next; !(n = s(r, e)).done; ) {
                        if (o = (i = S(x(n.value))).next,
                        (a = s(o, i)).done || (h = s(o, i)).done || !s(o, i).done)
                            throw $("Expected sequence with length 2");
                        q(this.entries, {
                            key: E(a.value),
                            value: E(h.value)
                        })
                    }
                else
                    for (var u in t)
                        v(t, u) && q(this.entries, {
                            key: u,
                            value: E(t[u])
                        })
            },
            parseQuery: function(t) {
                if (t)
                    for (var e, r, n = Q(t, "&"), i = 0; i < n.length; )
                        (e = n[i++]).length && (r = Q(e, "="),
                        q(this.entries, {
                            key: st(Z(r)),
                            value: st(Y(r, "="))
                        }))
            },
            serialize: function() {
                for (var t, e = this.entries, r = [], n = 0; n < e.length; )
                    t = e[n++],
                    q(r, lt(t.key) + "=" + lt(t.value));
                return Y(r, "&")
            },
            update: function() {
                this.entries.length = 0,
                this.parseQuery(this.url.query)
            },
            updateURL: function() {
                this.url && this.url.update()
            }
        };
        var dt = function() {
            m(this, ft);
            var t = O(this, new ct(arguments.length > 0 ? arguments[0] : void 0));
            a || (this.size = t.entries.length)
        }
          , ft = dt.prototype;
        if (c(ft, {
            append: function(t, e) {
                var r = B(this);
                C(arguments.length, 2),
                q(r.entries, {
                    key: E(t),
                    value: E(e)
                }),
                a || this.length++,
                r.updateURL()
            },
            delete: function(t) {
                for (var e = B(this), r = C(arguments.length, 1), n = e.entries, i = E(t), s = r < 2 ? void 0 : arguments[1], o = void 0 === s ? s : E(s), h = 0; h < n.length; ) {
                    var l = n[h];
                    if (l.key !== i || void 0 !== o && l.value !== o)
                        h++;
                    else if (J(n, h, 1),
                    void 0 !== o)
                        break
                }
                a || (this.size = n.length),
                e.updateURL()
            },
            get: function(t) {
                var e = B(this).entries;
                C(arguments.length, 1);
                for (var r = E(t), n = 0; n < e.length; n++)
                    if (e[n].key === r)
                        return e[n].value;
                return null
            },
            getAll: function(t) {
                var e = B(this).entries;
                C(arguments.length, 1);
                for (var r = E(t), n = [], i = 0; i < e.length; i++)
                    e[i].key === r && q(n, e[i].value);
                return n
            },
            has: function(t) {
                for (var e = B(this).entries, r = C(arguments.length, 1), n = E(t), i = r < 2 ? void 0 : arguments[1], s = void 0 === i ? i : E(i), o = 0; o < e.length; ) {
                    var a = e[o++];
                    if (a.key === n && (void 0 === s || a.value === s))
                        return !0
                }
                return !1
            },
            set: function(t, e) {
                var r = B(this);
                C(arguments.length, 1);
                for (var n, i = r.entries, s = !1, o = E(t), h = E(e), l = 0; l < i.length; l++)
                    (n = i[l]).key === o && (s ? J(i, l--, 1) : (s = !0,
                    n.value = h));
                s || q(i, {
                    key: o,
                    value: h
                }),
                a || (this.size = i.length),
                r.updateURL()
            },
            sort: function() {
                var t = B(this);
                P(t.entries, (function(t, e) {
                    return t.key > e.key ? 1 : -1
                }
                )),
                t.updateURL()
            },
            forEach: function(t) {
                for (var e, r = B(this).entries, n = y(t, arguments.length > 1 ? arguments[1] : void 0), i = 0; i < r.length; )
                    n((e = r[i++]).value, e.key, this)
            },
            keys: function() {
                return new ut(this,"keys")
            },
            values: function() {
                return new ut(this,"values")
            },
            entries: function() {
                return new ut(this,"entries")
            }
        }, {
            enumerable: !0
        }),
        l(ft, I, ft.entries, {
            name: "entries"
        }),
        l(ft, "toString", (function() {
            return B(this).serialize()
        }
        ), {
            enumerable: !0
        }),
        a && u(ft, "size", {
            get: function() {
                return B(this).entries.length
            },
            configurable: !0,
            enumerable: !0
        }),
        d(dt, M),
        n({
            global: !0,
            constructor: !0,
            forced: !h
        }, {
            URLSearchParams: dt
        }),
        !h && g(G)) {
            var pt = o(z.has)
              , mt = o(z.set)
              , gt = function(t) {
                if (b(t)) {
                    var e, r = t.body;
                    if (_(r) === M)
                        return e = t.headers ? new G(t.headers) : new G,
                        pt(e, "content-type") || mt(e, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"),
                        T(t, {
                            body: w(0, E(r)),
                            headers: w(0, e)
                        })
                }
                return t
            };
            if (g(F) && n({
                global: !0,
                enumerable: !0,
                dontCallGetSet: !0,
                forced: !0
            }, {
                fetch: function(t) {
                    return F(t, arguments.length > 1 ? gt(arguments[1]) : {})
                }
            }),
            g(U)) {
                var vt = function(t) {
                    return m(this, j),
                    new U(t,arguments.length > 1 ? gt(arguments[1]) : {})
                };
                j.constructor = vt,
                vt.prototype = j,
                n({
                    global: !0,
                    constructor: !0,
                    dontCallGetSet: !0,
                    forced: !0
                }, {
                    Request: vt
                })
            }
        }
        t.exports = {
            URLSearchParams: dt,
            getState: B
        }
    },
    41637: function(t, e, r) {
        "use strict";
        r(65556)
    },
    68789: function(t, e, r) {
        "use strict";
        r(78783);
        var n, i = r(82109), s = r(19781), o = r(85143), a = r(17854), h = r(49974), l = r(1702), u = r(98052), c = r(47045), d = r(25787), f = r(92597), p = r(21574), m = r(48457), g = r(41589), v = r(28710).codeAt, y = r(33197), _ = r(41340), x = r(58003), b = r(48053), E = r(65556), T = r(29909), w = T.set, S = T.getterFor("URL"), A = E.URLSearchParams, C = E.getState, R = a.URL, P = a.TypeError, I = a.parseInt, M = Math.floor, D = Math.pow, O = l("".charAt), B = l(/./.exec), k = l([].join), L = l(1..toString), N = l([].pop), F = l([].push), U = l("".replace), G = l([].shift), j = l("".split), z = l("".slice), H = l("".toLowerCase), $ = l([].unshift), X = "Invalid scheme", V = "Invalid host", W = "Invalid port", Y = /[a-z]/i, q = /[\d+-.a-z]/i, K = /\d/, Z = /^0x/i, J = /^[0-7]+$/, Q = /^\d+$/, tt = /^[\da-f]+$/i, et = /[\0\t\n\r #%/:<>?@[\\\]^|]/, rt = /[\0\t\n\r #/:<>?@[\\\]^|]/, nt = /^[\u0000-\u0020]+/, it = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/, st = /[\t\n\r]/g, ot = function(t) {
            var e, r, n, i;
            if ("number" == typeof t) {
                for (e = [],
                r = 0; r < 4; r++)
                    $(e, t % 256),
                    t = M(t / 256);
                return k(e, ".")
            }
            if ("object" == typeof t) {
                for (e = "",
                n = function(t) {
                    for (var e = null, r = 1, n = null, i = 0, s = 0; s < 8; s++)
                        0 !== t[s] ? (i > r && (e = n,
                        r = i),
                        n = null,
                        i = 0) : (null === n && (n = s),
                        ++i);
                    return i > r && (e = n,
                    r = i),
                    e
                }(t),
                r = 0; r < 8; r++)
                    i && 0 === t[r] || (i && (i = !1),
                    n === r ? (e += r ? ":" : "::",
                    i = !0) : (e += L(t[r], 16),
                    r < 7 && (e += ":")));
                return "[" + e + "]"
            }
            return t
        }, at = {}, ht = p({}, at, {
            " ": 1,
            '"': 1,
            "<": 1,
            ">": 1,
            "`": 1
        }), lt = p({}, ht, {
            "#": 1,
            "?": 1,
            "{": 1,
            "}": 1
        }), ut = p({}, lt, {
            "/": 1,
            ":": 1,
            ";": 1,
            "=": 1,
            "@": 1,
            "[": 1,
            "\\": 1,
            "]": 1,
            "^": 1,
            "|": 1
        }), ct = function(t, e) {
            var r = v(t, 0);
            return r > 32 && r < 127 && !f(e, t) ? t : encodeURIComponent(t)
        }, dt = {
            ftp: 21,
            file: null,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        }, ft = function(t, e) {
            var r;
            return 2 === t.length && B(Y, O(t, 0)) && (":" === (r = O(t, 1)) || !e && "|" === r)
        }, pt = function(t) {
            var e;
            return t.length > 1 && ft(z(t, 0, 2)) && (2 === t.length || "/" === (e = O(t, 2)) || "\\" === e || "?" === e || "#" === e)
        }, mt = function(t) {
            return "." === t || "%2e" === H(t)
        }, gt = {}, vt = {}, yt = {}, _t = {}, xt = {}, bt = {}, Et = {}, Tt = {}, wt = {}, St = {}, At = {}, Ct = {}, Rt = {}, Pt = {}, It = {}, Mt = {}, Dt = {}, Ot = {}, Bt = {}, kt = {}, Lt = {}, Nt = function(t, e, r) {
            var n, i, s, o = _(t);
            if (e) {
                if (i = this.parse(o))
                    throw P(i);
                this.searchParams = null
            } else {
                if (void 0 !== r && (n = new Nt(r,!0)),
                i = this.parse(o, null, n))
                    throw P(i);
                (s = C(new A)).bindURL(this),
                this.searchParams = s
            }
        };
        Nt.prototype = {
            type: "URL",
            parse: function(t, e, r) {
                var i, s, o, a, h, l = this, u = e || gt, c = 0, d = "", p = !1, v = !1, y = !1;
                for (t = _(t),
                e || (l.scheme = "",
                l.username = "",
                l.password = "",
                l.host = null,
                l.port = null,
                l.path = [],
                l.query = null,
                l.fragment = null,
                l.cannotBeABaseURL = !1,
                t = U(t, nt, ""),
                t = U(t, it, "$1")),
                t = U(t, st, ""),
                i = m(t); c <= i.length; ) {
                    switch (s = i[c],
                    u) {
                    case gt:
                        if (!s || !B(Y, s)) {
                            if (e)
                                return X;
                            u = yt;
                            continue
                        }
                        d += H(s),
                        u = vt;
                        break;
                    case vt:
                        if (s && (B(q, s) || "+" === s || "-" === s || "." === s))
                            d += H(s);
                        else {
                            if (":" !== s) {
                                if (e)
                                    return X;
                                d = "",
                                u = yt,
                                c = 0;
                                continue
                            }
                            if (e && (l.isSpecial() !== f(dt, d) || "file" === d && (l.includesCredentials() || null !== l.port) || "file" === l.scheme && !l.host))
                                return;
                            if (l.scheme = d,
                            e)
                                return void (l.isSpecial() && dt[l.scheme] === l.port && (l.port = null));
                            d = "",
                            "file" === l.scheme ? u = Pt : l.isSpecial() && r && r.scheme === l.scheme ? u = _t : l.isSpecial() ? u = Tt : "/" === i[c + 1] ? (u = xt,
                            c++) : (l.cannotBeABaseURL = !0,
                            F(l.path, ""),
                            u = Bt)
                        }
                        break;
                    case yt:
                        if (!r || r.cannotBeABaseURL && "#" !== s)
                            return X;
                        if (r.cannotBeABaseURL && "#" === s) {
                            l.scheme = r.scheme,
                            l.path = g(r.path),
                            l.query = r.query,
                            l.fragment = "",
                            l.cannotBeABaseURL = !0,
                            u = Lt;
                            break
                        }
                        u = "file" === r.scheme ? Pt : bt;
                        continue;
                    case _t:
                        if ("/" !== s || "/" !== i[c + 1]) {
                            u = bt;
                            continue
                        }
                        u = wt,
                        c++;
                        break;
                    case xt:
                        if ("/" === s) {
                            u = St;
                            break
                        }
                        u = Ot;
                        continue;
                    case bt:
                        if (l.scheme = r.scheme,
                        s === n)
                            l.username = r.username,
                            l.password = r.password,
                            l.host = r.host,
                            l.port = r.port,
                            l.path = g(r.path),
                            l.query = r.query;
                        else if ("/" === s || "\\" === s && l.isSpecial())
                            u = Et;
                        else if ("?" === s)
                            l.username = r.username,
                            l.password = r.password,
                            l.host = r.host,
                            l.port = r.port,
                            l.path = g(r.path),
                            l.query = "",
                            u = kt;
                        else {
                            if ("#" !== s) {
                                l.username = r.username,
                                l.password = r.password,
                                l.host = r.host,
                                l.port = r.port,
                                l.path = g(r.path),
                                l.path.length--,
                                u = Ot;
                                continue
                            }
                            l.username = r.username,
                            l.password = r.password,
                            l.host = r.host,
                            l.port = r.port,
                            l.path = g(r.path),
                            l.query = r.query,
                            l.fragment = "",
                            u = Lt
                        }
                        break;
                    case Et:
                        if (!l.isSpecial() || "/" !== s && "\\" !== s) {
                            if ("/" !== s) {
                                l.username = r.username,
                                l.password = r.password,
                                l.host = r.host,
                                l.port = r.port,
                                u = Ot;
                                continue
                            }
                            u = St
                        } else
                            u = wt;
                        break;
                    case Tt:
                        if (u = wt,
                        "/" !== s || "/" !== O(d, c + 1))
                            continue;
                        c++;
                        break;
                    case wt:
                        if ("/" !== s && "\\" !== s) {
                            u = St;
                            continue
                        }
                        break;
                    case St:
                        if ("@" === s) {
                            p && (d = "%40" + d),
                            p = !0,
                            o = m(d);
                            for (var x = 0; x < o.length; x++) {
                                var b = o[x];
                                if (":" !== b || y) {
                                    var E = ct(b, ut);
                                    y ? l.password += E : l.username += E
                                } else
                                    y = !0
                            }
                            d = ""
                        } else if (s === n || "/" === s || "?" === s || "#" === s || "\\" === s && l.isSpecial()) {
                            if (p && "" === d)
                                return "Invalid authority";
                            c -= m(d).length + 1,
                            d = "",
                            u = At
                        } else
                            d += s;
                        break;
                    case At:
                    case Ct:
                        if (e && "file" === l.scheme) {
                            u = Mt;
                            continue
                        }
                        if (":" !== s || v) {
                            if (s === n || "/" === s || "?" === s || "#" === s || "\\" === s && l.isSpecial()) {
                                if (l.isSpecial() && "" === d)
                                    return V;
                                if (e && "" === d && (l.includesCredentials() || null !== l.port))
                                    return;
                                if (a = l.parseHost(d))
                                    return a;
                                if (d = "",
                                u = Dt,
                                e)
                                    return;
                                continue
                            }
                            "[" === s ? v = !0 : "]" === s && (v = !1),
                            d += s
                        } else {
                            if ("" === d)
                                return V;
                            if (a = l.parseHost(d))
                                return a;
                            if (d = "",
                            u = Rt,
                            e === Ct)
                                return
                        }
                        break;
                    case Rt:
                        if (!B(K, s)) {
                            if (s === n || "/" === s || "?" === s || "#" === s || "\\" === s && l.isSpecial() || e) {
                                if ("" !== d) {
                                    var T = I(d, 10);
                                    if (T > 65535)
                                        return W;
                                    l.port = l.isSpecial() && T === dt[l.scheme] ? null : T,
                                    d = ""
                                }
                                if (e)
                                    return;
                                u = Dt;
                                continue
                            }
                            return W
                        }
                        d += s;
                        break;
                    case Pt:
                        if (l.scheme = "file",
                        "/" === s || "\\" === s)
                            u = It;
                        else {
                            if (!r || "file" !== r.scheme) {
                                u = Ot;
                                continue
                            }
                            switch (s) {
                            case n:
                                l.host = r.host,
                                l.path = g(r.path),
                                l.query = r.query;
                                break;
                            case "?":
                                l.host = r.host,
                                l.path = g(r.path),
                                l.query = "",
                                u = kt;
                                break;
                            case "#":
                                l.host = r.host,
                                l.path = g(r.path),
                                l.query = r.query,
                                l.fragment = "",
                                u = Lt;
                                break;
                            default:
                                pt(k(g(i, c), "")) || (l.host = r.host,
                                l.path = g(r.path),
                                l.shortenPath()),
                                u = Ot;
                                continue
                            }
                        }
                        break;
                    case It:
                        if ("/" === s || "\\" === s) {
                            u = Mt;
                            break
                        }
                        r && "file" === r.scheme && !pt(k(g(i, c), "")) && (ft(r.path[0], !0) ? F(l.path, r.path[0]) : l.host = r.host),
                        u = Ot;
                        continue;
                    case Mt:
                        if (s === n || "/" === s || "\\" === s || "?" === s || "#" === s) {
                            if (!e && ft(d))
                                u = Ot;
                            else if ("" === d) {
                                if (l.host = "",
                                e)
                                    return;
                                u = Dt
                            } else {
                                if (a = l.parseHost(d))
                                    return a;
                                if ("localhost" === l.host && (l.host = ""),
                                e)
                                    return;
                                d = "",
                                u = Dt
                            }
                            continue
                        }
                        d += s;
                        break;
                    case Dt:
                        if (l.isSpecial()) {
                            if (u = Ot,
                            "/" !== s && "\\" !== s)
                                continue
                        } else if (e || "?" !== s)
                            if (e || "#" !== s) {
                                if (s !== n && (u = Ot,
                                "/" !== s))
                                    continue
                            } else
                                l.fragment = "",
                                u = Lt;
                        else
                            l.query = "",
                            u = kt;
                        break;
                    case Ot:
                        if (s === n || "/" === s || "\\" === s && l.isSpecial() || !e && ("?" === s || "#" === s)) {
                            if (".." === (h = H(h = d)) || "%2e." === h || ".%2e" === h || "%2e%2e" === h ? (l.shortenPath(),
                            "/" === s || "\\" === s && l.isSpecial() || F(l.path, "")) : mt(d) ? "/" === s || "\\" === s && l.isSpecial() || F(l.path, "") : ("file" === l.scheme && !l.path.length && ft(d) && (l.host && (l.host = ""),
                            d = O(d, 0) + ":"),
                            F(l.path, d)),
                            d = "",
                            "file" === l.scheme && (s === n || "?" === s || "#" === s))
                                for (; l.path.length > 1 && "" === l.path[0]; )
                                    G(l.path);
                            "?" === s ? (l.query = "",
                            u = kt) : "#" === s && (l.fragment = "",
                            u = Lt)
                        } else
                            d += ct(s, lt);
                        break;
                    case Bt:
                        "?" === s ? (l.query = "",
                        u = kt) : "#" === s ? (l.fragment = "",
                        u = Lt) : s !== n && (l.path[0] += ct(s, at));
                        break;
                    case kt:
                        e || "#" !== s ? s !== n && ("'" === s && l.isSpecial() ? l.query += "%27" : l.query += "#" === s ? "%23" : ct(s, at)) : (l.fragment = "",
                        u = Lt);
                        break;
                    case Lt:
                        s !== n && (l.fragment += ct(s, ht))
                    }
                    c++
                }
            },
            parseHost: function(t) {
                var e, r, n;
                if ("[" === O(t, 0)) {
                    if ("]" !== O(t, t.length - 1))
                        return V;
                    if (e = function(t) {
                        var e, r, n, i, s, o, a, h = [0, 0, 0, 0, 0, 0, 0, 0], l = 0, u = null, c = 0, d = function() {
                            return O(t, c)
                        };
                        if (":" === d()) {
                            if (":" !== O(t, 1))
                                return;
                            c += 2,
                            u = ++l
                        }
                        for (; d(); ) {
                            if (8 === l)
                                return;
                            if (":" !== d()) {
                                for (e = r = 0; r < 4 && B(tt, d()); )
                                    e = 16 * e + I(d(), 16),
                                    c++,
                                    r++;
                                if ("." === d()) {
                                    if (0 === r)
                                        return;
                                    if (c -= r,
                                    l > 6)
                                        return;
                                    for (n = 0; d(); ) {
                                        if (i = null,
                                        n > 0) {
                                            if (!("." === d() && n < 4))
                                                return;
                                            c++
                                        }
                                        if (!B(K, d()))
                                            return;
                                        for (; B(K, d()); ) {
                                            if (s = I(d(), 10),
                                            null === i)
                                                i = s;
                                            else {
                                                if (0 === i)
                                                    return;
                                                i = 10 * i + s
                                            }
                                            if (i > 255)
                                                return;
                                            c++
                                        }
                                        h[l] = 256 * h[l] + i,
                                        2 != ++n && 4 !== n || l++
                                    }
                                    if (4 !== n)
                                        return;
                                    break
                                }
                                if (":" === d()) {
                                    if (c++,
                                    !d())
                                        return
                                } else if (d())
                                    return;
                                h[l++] = e
                            } else {
                                if (null !== u)
                                    return;
                                c++,
                                u = ++l
                            }
                        }
                        if (null !== u)
                            for (o = l - u,
                            l = 7; 0 !== l && o > 0; )
                                a = h[l],
                                h[l--] = h[u + o - 1],
                                h[u + --o] = a;
                        else if (8 !== l)
                            return;
                        return h
                    }(z(t, 1, -1)),
                    !e)
                        return V;
                    this.host = e
                } else if (this.isSpecial()) {
                    if (t = y(t),
                    B(et, t))
                        return V;
                    if (e = function(t) {
                        var e, r, n, i, s, o, a, h = j(t, ".");
                        if (h.length && "" === h[h.length - 1] && h.length--,
                        (e = h.length) > 4)
                            return t;
                        for (r = [],
                        n = 0; n < e; n++) {
                            if ("" === (i = h[n]))
                                return t;
                            if (s = 10,
                            i.length > 1 && "0" === O(i, 0) && (s = B(Z, i) ? 16 : 8,
                            i = z(i, 8 === s ? 1 : 2)),
                            "" === i)
                                o = 0;
                            else {
                                if (!B(10 === s ? Q : 8 === s ? J : tt, i))
                                    return t;
                                o = I(i, s)
                            }
                            F(r, o)
                        }
                        for (n = 0; n < e; n++)
                            if (o = r[n],
                            n === e - 1) {
                                if (o >= D(256, 5 - e))
                                    return null
                            } else if (o > 255)
                                return null;
                        for (a = N(r),
                        n = 0; n < r.length; n++)
                            a += r[n] * D(256, 3 - n);
                        return a
                    }(t),
                    null === e)
                        return V;
                    this.host = e
                } else {
                    if (B(rt, t))
                        return V;
                    for (e = "",
                    r = m(t),
                    n = 0; n < r.length; n++)
                        e += ct(r[n], at);
                    this.host = e
                }
            },
            cannotHaveUsernamePasswordPort: function() {
                return !this.host || this.cannotBeABaseURL || "file" === this.scheme
            },
            includesCredentials: function() {
                return "" !== this.username || "" !== this.password
            },
            isSpecial: function() {
                return f(dt, this.scheme)
            },
            shortenPath: function() {
                var t = this.path
                  , e = t.length;
                !e || "file" === this.scheme && 1 === e && ft(t[0], !0) || t.length--
            },
            serialize: function() {
                var t = this
                  , e = t.scheme
                  , r = t.username
                  , n = t.password
                  , i = t.host
                  , s = t.port
                  , o = t.path
                  , a = t.query
                  , h = t.fragment
                  , l = e + ":";
                return null !== i ? (l += "//",
                t.includesCredentials() && (l += r + (n ? ":" + n : "") + "@"),
                l += ot(i),
                null !== s && (l += ":" + s)) : "file" === e && (l += "//"),
                l += t.cannotBeABaseURL ? o[0] : o.length ? "/" + k(o, "/") : "",
                null !== a && (l += "?" + a),
                null !== h && (l += "#" + h),
                l
            },
            setHref: function(t) {
                var e = this.parse(t);
                if (e)
                    throw P(e);
                this.searchParams.update()
            },
            getOrigin: function() {
                var t = this.scheme
                  , e = this.port;
                if ("blob" === t)
                    try {
                        return new Ft(t.path[0]).origin
                    } catch (t) {
                        return "null"
                    }
                return "file" !== t && this.isSpecial() ? t + "://" + ot(this.host) + (null !== e ? ":" + e : "") : "null"
            },
            getProtocol: function() {
                return this.scheme + ":"
            },
            setProtocol: function(t) {
                this.parse(_(t) + ":", gt)
            },
            getUsername: function() {
                return this.username
            },
            setUsername: function(t) {
                var e = m(_(t));
                if (!this.cannotHaveUsernamePasswordPort()) {
                    this.username = "";
                    for (var r = 0; r < e.length; r++)
                        this.username += ct(e[r], ut)
                }
            },
            getPassword: function() {
                return this.password
            },
            setPassword: function(t) {
                var e = m(_(t));
                if (!this.cannotHaveUsernamePasswordPort()) {
                    this.password = "";
                    for (var r = 0; r < e.length; r++)
                        this.password += ct(e[r], ut)
                }
            },
            getHost: function() {
                var t = this.host
                  , e = this.port;
                return null === t ? "" : null === e ? ot(t) : ot(t) + ":" + e
            },
            setHost: function(t) {
                this.cannotBeABaseURL || this.parse(t, At)
            },
            getHostname: function() {
                var t = this.host;
                return null === t ? "" : ot(t)
            },
            setHostname: function(t) {
                this.cannotBeABaseURL || this.parse(t, Ct)
            },
            getPort: function() {
                var t = this.port;
                return null === t ? "" : _(t)
            },
            setPort: function(t) {
                this.cannotHaveUsernamePasswordPort() || ("" === (t = _(t)) ? this.port = null : this.parse(t, Rt))
            },
            getPathname: function() {
                var t = this.path;
                return this.cannotBeABaseURL ? t[0] : t.length ? "/" + k(t, "/") : ""
            },
            setPathname: function(t) {
                this.cannotBeABaseURL || (this.path = [],
                this.parse(t, Dt))
            },
            getSearch: function() {
                var t = this.query;
                return t ? "?" + t : ""
            },
            setSearch: function(t) {
                "" === (t = _(t)) ? this.query = null : ("?" === O(t, 0) && (t = z(t, 1)),
                this.query = "",
                this.parse(t, kt)),
                this.searchParams.update()
            },
            getSearchParams: function() {
                return this.searchParams.facade
            },
            getHash: function() {
                var t = this.fragment;
                return t ? "#" + t : ""
            },
            setHash: function(t) {
                "" !== (t = _(t)) ? ("#" === O(t, 0) && (t = z(t, 1)),
                this.fragment = "",
                this.parse(t, Lt)) : this.fragment = null
            },
            update: function() {
                this.query = this.searchParams.serialize() || null
            }
        };
        var Ft = function(t) {
            var e = d(this, Ut)
              , r = b(arguments.length, 1) > 1 ? arguments[1] : void 0
              , n = w(e, new Nt(t,!1,r));
            s || (e.href = n.serialize(),
            e.origin = n.getOrigin(),
            e.protocol = n.getProtocol(),
            e.username = n.getUsername(),
            e.password = n.getPassword(),
            e.host = n.getHost(),
            e.hostname = n.getHostname(),
            e.port = n.getPort(),
            e.pathname = n.getPathname(),
            e.search = n.getSearch(),
            e.searchParams = n.getSearchParams(),
            e.hash = n.getHash())
        }
          , Ut = Ft.prototype
          , Gt = function(t, e) {
            return {
                get: function() {
                    return S(this)[t]()
                },
                set: e && function(t) {
                    return S(this)[e](t)
                }
                ,
                configurable: !0,
                enumerable: !0
            }
        };
        if (s && (c(Ut, "href", Gt("serialize", "setHref")),
        c(Ut, "origin", Gt("getOrigin")),
        c(Ut, "protocol", Gt("getProtocol", "setProtocol")),
        c(Ut, "username", Gt("getUsername", "setUsername")),
        c(Ut, "password", Gt("getPassword", "setPassword")),
        c(Ut, "host", Gt("getHost", "setHost")),
        c(Ut, "hostname", Gt("getHostname", "setHostname")),
        c(Ut, "port", Gt("getPort", "setPort")),
        c(Ut, "pathname", Gt("getPathname", "setPathname")),
        c(Ut, "search", Gt("getSearch", "setSearch")),
        c(Ut, "searchParams", Gt("getSearchParams")),
        c(Ut, "hash", Gt("getHash", "setHash"))),
        u(Ut, "toJSON", (function() {
            return S(this).serialize()
        }
        ), {
            enumerable: !0
        }),
        u(Ut, "toString", (function() {
            return S(this).serialize()
        }
        ), {
            enumerable: !0
        }),
        R) {
            var jt = R.createObjectURL
              , zt = R.revokeObjectURL;
            jt && u(Ft, "createObjectURL", h(jt, R)),
            zt && u(Ft, "revokeObjectURL", h(zt, R))
        }
        x(Ft, "URL"),
        i({
            global: !0,
            constructor: !0,
            forced: !o,
            sham: !s
        }, {
            URL: Ft
        })
    },
    60285: function(t, e, r) {
        "use strict";
        r(68789)
    },
    9187: function(t) {
        "use strict";
        function e(t, e, n) {
            n = n || 2;
            var s, o, a, h, c, d, p, m = e && e.length, g = m ? e[0] * n : t.length, v = r(t, 0, g, n, !0), y = [];
            if (!v || v.next === v.prev)
                return y;
            if (m && (v = function(t, e, n, i) {
                var s, o, a, h = [];
                for (s = 0,
                o = e.length; s < o; s++)
                    (a = r(t, e[s] * i, s < o - 1 ? e[s + 1] * i : t.length, i, !1)) === a.next && (a.steiner = !0),
                    h.push(f(a));
                for (h.sort(l),
                s = 0; s < h.length; s++)
                    n = u(h[s], n);
                return n
            }(t, e, v, n)),
            t.length > 80 * n) {
                s = a = t[0],
                o = h = t[1];
                for (var _ = n; _ < g; _ += n)
                    (c = t[_]) < s && (s = c),
                    (d = t[_ + 1]) < o && (o = d),
                    c > a && (a = c),
                    d > h && (h = d);
                p = 0 !== (p = Math.max(a - s, h - o)) ? 32767 / p : 0
            }
            return i(v, y, n, s, o, p, 0),
            y
        }
        function r(t, e, r, n, i) {
            var s, o;
            if (i === A(t, e, r, n) > 0)
                for (s = e; s < r; s += n)
                    o = T(s, t[s], t[s + 1], o);
            else
                for (s = r - n; s >= e; s -= n)
                    o = T(s, t[s], t[s + 1], o);
            return o && v(o, o.next) && (w(o),
            o = o.next),
            o
        }
        function n(t, e) {
            if (!t)
                return t;
            e || (e = t);
            var r, n = t;
            do {
                if (r = !1,
                n.steiner || !v(n, n.next) && 0 !== g(n.prev, n, n.next))
                    n = n.next;
                else {
                    if (w(n),
                    (n = e = n.prev) === n.next)
                        break;
                    r = !0
                }
            } while (r || n !== e);
            return e
        }
        function i(t, e, r, l, u, c, f) {
            if (t) {
                !f && c && function(t, e, r, n) {
                    var i = t;
                    do {
                        0 === i.z && (i.z = d(i.x, i.y, e, r, n)),
                        i.prevZ = i.prev,
                        i.nextZ = i.next,
                        i = i.next
                    } while (i !== t);
                    i.prevZ.nextZ = null,
                    i.prevZ = null,
                    function(t) {
                        var e, r, n, i, s, o, a, h, l = 1;
                        do {
                            for (r = t,
                            t = null,
                            s = null,
                            o = 0; r; ) {
                                for (o++,
                                n = r,
                                a = 0,
                                e = 0; e < l && (a++,
                                n = n.nextZ); e++)
                                    ;
                                for (h = l; a > 0 || h > 0 && n; )
                                    0 !== a && (0 === h || !n || r.z <= n.z) ? (i = r,
                                    r = r.nextZ,
                                    a--) : (i = n,
                                    n = n.nextZ,
                                    h--),
                                    s ? s.nextZ = i : t = i,
                                    i.prevZ = s,
                                    s = i;
                                r = n
                            }
                            s.nextZ = null,
                            l *= 2
                        } while (o > 1)
                    }(i)
                }(t, l, u, c);
                for (var p, m, g = t; t.prev !== t.next; )
                    if (p = t.prev,
                    m = t.next,
                    c ? o(t, l, u, c) : s(t))
                        e.push(p.i / r | 0),
                        e.push(t.i / r | 0),
                        e.push(m.i / r | 0),
                        w(t),
                        t = m.next,
                        g = m.next;
                    else if ((t = m) === g) {
                        f ? 1 === f ? i(t = a(n(t), e, r), e, r, l, u, c, 2) : 2 === f && h(t, e, r, l, u, c) : i(n(t), e, r, l, u, c, 1);
                        break
                    }
            }
        }
        function s(t) {
            var e = t.prev
              , r = t
              , n = t.next;
            if (g(e, r, n) >= 0)
                return !1;
            for (var i = e.x, s = r.x, o = n.x, a = e.y, h = r.y, l = n.y, u = i < s ? i < o ? i : o : s < o ? s : o, c = a < h ? a < l ? a : l : h < l ? h : l, d = i > s ? i > o ? i : o : s > o ? s : o, f = a > h ? a > l ? a : l : h > l ? h : l, m = n.next; m !== e; ) {
                if (m.x >= u && m.x <= d && m.y >= c && m.y <= f && p(i, a, s, h, o, l, m.x, m.y) && g(m.prev, m, m.next) >= 0)
                    return !1;
                m = m.next
            }
            return !0
        }
        function o(t, e, r, n) {
            var i = t.prev
              , s = t
              , o = t.next;
            if (g(i, s, o) >= 0)
                return !1;
            for (var a = i.x, h = s.x, l = o.x, u = i.y, c = s.y, f = o.y, m = a < h ? a < l ? a : l : h < l ? h : l, v = u < c ? u < f ? u : f : c < f ? c : f, y = a > h ? a > l ? a : l : h > l ? h : l, _ = u > c ? u > f ? u : f : c > f ? c : f, x = d(m, v, e, r, n), b = d(y, _, e, r, n), E = t.prevZ, T = t.nextZ; E && E.z >= x && T && T.z <= b; ) {
                if (E.x >= m && E.x <= y && E.y >= v && E.y <= _ && E !== i && E !== o && p(a, u, h, c, l, f, E.x, E.y) && g(E.prev, E, E.next) >= 0)
                    return !1;
                if (E = E.prevZ,
                T.x >= m && T.x <= y && T.y >= v && T.y <= _ && T !== i && T !== o && p(a, u, h, c, l, f, T.x, T.y) && g(T.prev, T, T.next) >= 0)
                    return !1;
                T = T.nextZ
            }
            for (; E && E.z >= x; ) {
                if (E.x >= m && E.x <= y && E.y >= v && E.y <= _ && E !== i && E !== o && p(a, u, h, c, l, f, E.x, E.y) && g(E.prev, E, E.next) >= 0)
                    return !1;
                E = E.prevZ
            }
            for (; T && T.z <= b; ) {
                if (T.x >= m && T.x <= y && T.y >= v && T.y <= _ && T !== i && T !== o && p(a, u, h, c, l, f, T.x, T.y) && g(T.prev, T, T.next) >= 0)
                    return !1;
                T = T.nextZ
            }
            return !0
        }
        function a(t, e, r) {
            var i = t;
            do {
                var s = i.prev
                  , o = i.next.next;
                !v(s, o) && y(s, i, i.next, o) && b(s, o) && b(o, s) && (e.push(s.i / r | 0),
                e.push(i.i / r | 0),
                e.push(o.i / r | 0),
                w(i),
                w(i.next),
                i = t = o),
                i = i.next
            } while (i !== t);
            return n(i)
        }
        function h(t, e, r, s, o, a) {
            var h = t;
            do {
                for (var l = h.next.next; l !== h.prev; ) {
                    if (h.i !== l.i && m(h, l)) {
                        var u = E(h, l);
                        return h = n(h, h.next),
                        u = n(u, u.next),
                        i(h, e, r, s, o, a, 0),
                        void i(u, e, r, s, o, a, 0)
                    }
                    l = l.next
                }
                h = h.next
            } while (h !== t)
        }
        function l(t, e) {
            return t.x - e.x
        }
        function u(t, e) {
            var r = function(t, e) {
                var r, n = e, i = t.x, s = t.y, o = -1 / 0;
                do {
                    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                        var a = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (a <= i && a > o && (o = a,
                        r = n.x < n.next.x ? n : n.next,
                        a === i))
                            return r
                    }
                    n = n.next
                } while (n !== e);
                if (!r)
                    return null;
                var h, l = r, u = r.x, d = r.y, f = 1 / 0;
                n = r;
                do {
                    i >= n.x && n.x >= u && i !== n.x && p(s < d ? i : o, s, u, d, s < d ? o : i, s, n.x, n.y) && (h = Math.abs(s - n.y) / (i - n.x),
                    b(n, t) && (h < f || h === f && (n.x > r.x || n.x === r.x && c(r, n))) && (r = n,
                    f = h)),
                    n = n.next
                } while (n !== l);
                return r
            }(t, e);
            if (!r)
                return e;
            var i = E(r, t);
            return n(i, i.next),
            n(r, r.next)
        }
        function c(t, e) {
            return g(t.prev, t, e.prev) < 0 && g(e.next, t, t.next) < 0
        }
        function d(t, e, r, n, i) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }
        function f(t) {
            var e = t
              , r = t;
            do {
                (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e),
                e = e.next
            } while (e !== t);
            return r
        }
        function p(t, e, r, n, i, s, o, a) {
            return (i - o) * (e - a) >= (t - o) * (s - a) && (t - o) * (n - a) >= (r - o) * (e - a) && (r - o) * (s - a) >= (i - o) * (n - a)
        }
        function m(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
                var r = t;
                do {
                    if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && y(r, r.next, t, e))
                        return !0;
                    r = r.next
                } while (r !== t);
                return !1
            }(t, e) && (b(t, e) && b(e, t) && function(t, e) {
                var r = t
                  , n = !1
                  , i = (t.x + e.x) / 2
                  , s = (t.y + e.y) / 2;
                do {
                    r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n),
                    r = r.next
                } while (r !== t);
                return n
            }(t, e) && (g(t.prev, t, e.prev) || g(t, e.prev, e)) || v(t, e) && g(t.prev, t, t.next) > 0 && g(e.prev, e, e.next) > 0)
        }
        function g(t, e, r) {
            return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y)
        }
        function v(t, e) {
            return t.x === e.x && t.y === e.y
        }
        function y(t, e, r, n) {
            var i = x(g(t, e, r))
              , s = x(g(t, e, n))
              , o = x(g(r, n, t))
              , a = x(g(r, n, e));
            return i !== s && o !== a || !(0 !== i || !_(t, r, e)) || !(0 !== s || !_(t, n, e)) || !(0 !== o || !_(r, t, n)) || !(0 !== a || !_(r, e, n))
        }
        function _(t, e, r) {
            return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y)
        }
        function x(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }
        function b(t, e) {
            return g(t.prev, t, t.next) < 0 ? g(t, e, t.next) >= 0 && g(t, t.prev, e) >= 0 : g(t, e, t.prev) < 0 || g(t, t.next, e) < 0
        }
        function E(t, e) {
            var r = new S(t.i,t.x,t.y)
              , n = new S(e.i,e.x,e.y)
              , i = t.next
              , s = e.prev;
            return t.next = e,
            e.prev = t,
            r.next = i,
            i.prev = r,
            n.next = r,
            r.prev = n,
            s.next = n,
            n.prev = s,
            n
        }
        function T(t, e, r, n) {
            var i = new S(t,e,r);
            return n ? (i.next = n.next,
            i.prev = n,
            n.next.prev = i,
            n.next = i) : (i.prev = i,
            i.next = i),
            i
        }
        function w(t) {
            t.next.prev = t.prev,
            t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        function S(t, e, r) {
            this.i = t,
            this.x = e,
            this.y = r,
            this.prev = null,
            this.next = null,
            this.z = 0,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        function A(t, e, r, n) {
            for (var i = 0, s = e, o = r - n; s < r; s += n)
                i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]),
                o = s;
            return i
        }
        t.exports = e,
        t.exports.default = e,
        e.deviation = function(t, e, r, n) {
            var i = e && e.length
              , s = i ? e[0] * r : t.length
              , o = Math.abs(A(t, 0, s, r));
            if (i)
                for (var a = 0, h = e.length; a < h; a++) {
                    var l = e[a] * r
                      , u = a < h - 1 ? e[a + 1] * r : t.length;
                    o -= Math.abs(A(t, l, u, r))
                }
            var c = 0;
            for (a = 0; a < n.length; a += 3) {
                var d = n[a] * r
                  , f = n[a + 1] * r
                  , p = n[a + 2] * r;
                c += Math.abs((t[d] - t[p]) * (t[f + 1] - t[d + 1]) - (t[d] - t[f]) * (t[p + 1] - t[d + 1]))
            }
            return 0 === o && 0 === c ? 0 : Math.abs((c - o) / o)
        }
        ,
        e.flatten = function(t) {
            for (var e = t[0][0].length, r = {
                vertices: [],
                holes: [],
                dimensions: e
            }, n = 0, i = 0; i < t.length; i++) {
                for (var s = 0; s < t[i].length; s++)
                    for (var o = 0; o < e; o++)
                        r.vertices.push(t[i][s][o]);
                i > 0 && (n += t[i - 1].length,
                r.holes.push(n))
            }
            return r
        }
    },
    26729: function(t) {
        "use strict";
        var e = Object.prototype.hasOwnProperty
          , r = "~";
        function n() {}
        function i(t, e, r) {
            this.fn = t,
            this.context = e,
            this.once = r || !1
        }
        function s(t, e, n, s, o) {
            if ("function" != typeof n)
                throw new TypeError("The listener must be a function");
            var a = new i(n,s || t,o)
              , h = r ? r + e : e;
            return t._events[h] ? t._events[h].fn ? t._events[h] = [t._events[h], a] : t._events[h].push(a) : (t._events[h] = a,
            t._eventsCount++),
            t
        }
        function o(t, e) {
            0 == --t._eventsCount ? t._events = new n : delete t._events[e]
        }
        function a() {
            this._events = new n,
            this._eventsCount = 0
        }
        Object.create && (n.prototype = Object.create(null),
        (new n).__proto__ || (r = !1)),
        a.prototype.eventNames = function() {
            var t, n, i = [];
            if (0 === this._eventsCount)
                return i;
            for (n in t = this._events)
                e.call(t, n) && i.push(r ? n.slice(1) : n);
            return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
        }
        ,
        a.prototype.listeners = function(t) {
            var e = r ? r + t : t
              , n = this._events[e];
            if (!n)
                return [];
            if (n.fn)
                return [n.fn];
            for (var i = 0, s = n.length, o = new Array(s); i < s; i++)
                o[i] = n[i].fn;
            return o
        }
        ,
        a.prototype.listenerCount = function(t) {
            var e = r ? r + t : t
              , n = this._events[e];
            return n ? n.fn ? 1 : n.length : 0
        }
        ,
        a.prototype.emit = function(t, e, n, i, s, o) {
            var a = r ? r + t : t;
            if (!this._events[a])
                return !1;
            var h, l, u = this._events[a], c = arguments.length;
            if (u.fn) {
                switch (u.once && this.removeListener(t, u.fn, void 0, !0),
                c) {
                case 1:
                    return u.fn.call(u.context),
                    !0;
                case 2:
                    return u.fn.call(u.context, e),
                    !0;
                case 3:
                    return u.fn.call(u.context, e, n),
                    !0;
                case 4:
                    return u.fn.call(u.context, e, n, i),
                    !0;
                case 5:
                    return u.fn.call(u.context, e, n, i, s),
                    !0;
                case 6:
                    return u.fn.call(u.context, e, n, i, s, o),
                    !0
                }
                for (l = 1,
                h = new Array(c - 1); l < c; l++)
                    h[l - 1] = arguments[l];
                u.fn.apply(u.context, h)
            } else {
                var d, f = u.length;
                for (l = 0; l < f; l++)
                    switch (u[l].once && this.removeListener(t, u[l].fn, void 0, !0),
                    c) {
                    case 1:
                        u[l].fn.call(u[l].context);
                        break;
                    case 2:
                        u[l].fn.call(u[l].context, e);
                        break;
                    case 3:
                        u[l].fn.call(u[l].context, e, n);
                        break;
                    case 4:
                        u[l].fn.call(u[l].context, e, n, i);
                        break;
                    default:
                        if (!h)
                            for (d = 1,
                            h = new Array(c - 1); d < c; d++)
                                h[d - 1] = arguments[d];
                        u[l].fn.apply(u[l].context, h)
                    }
            }
            return !0
        }
        ,
        a.prototype.on = function(t, e, r) {
            return s(this, t, e, r, !1)
        }
        ,
        a.prototype.once = function(t, e, r) {
            return s(this, t, e, r, !0)
        }
        ,
        a.prototype.removeListener = function(t, e, n, i) {
            var s = r ? r + t : t;
            if (!this._events[s])
                return this;
            if (!e)
                return o(this, s),
                this;
            var a = this._events[s];
            if (a.fn)
                a.fn !== e || i && !a.once || n && a.context !== n || o(this, s);
            else {
                for (var h = 0, l = [], u = a.length; h < u; h++)
                    (a[h].fn !== e || i && !a[h].once || n && a[h].context !== n) && l.push(a[h]);
                l.length ? this._events[s] = 1 === l.length ? l[0] : l : o(this, s)
            }
            return this
        }
        ,
        a.prototype.removeAllListeners = function(t) {
            var e;
            return t ? (e = r ? r + t : t,
            this._events[e] && o(this, e)) : (this._events = new n,
            this._eventsCount = 0),
            this
        }
        ,
        a.prototype.off = a.prototype.removeListener,
        a.prototype.addListener = a.prototype.on,
        a.prefixed = r,
        a.EventEmitter = a,
        t.exports = a
    },
    17648: function(t) {
        "use strict";
        var e = Array.prototype.slice
          , r = Object.prototype.toString;
        t.exports = function(t) {
            var n = this;
            if ("function" != typeof n || "[object Function]" !== r.call(n))
                throw new TypeError("Function.prototype.bind called on incompatible " + n);
            for (var i, s = e.call(arguments, 1), o = Math.max(0, n.length - s.length), a = [], h = 0; h < o; h++)
                a.push("$" + h);
            if (i = Function("binder", "return function (" + a.join(",") + "){ return binder.apply(this,arguments); }")((function() {
                if (this instanceof i) {
                    var r = n.apply(this, s.concat(e.call(arguments)));
                    return Object(r) === r ? r : this
                }
                return n.apply(t, s.concat(e.call(arguments)))
            }
            )),
            n.prototype) {
                var l = function() {};
                l.prototype = n.prototype,
                i.prototype = new l,
                l.prototype = null
            }
            return i
        }
    },
    58612: function(t, e, r) {
        "use strict";
        var n = r(17648);
        t.exports = Function.prototype.bind || n
    },
    40210: function(t, e, r) {
        "use strict";
        var n, i = SyntaxError, s = Function, o = TypeError, a = function(t) {
            try {
                return s('"use strict"; return (' + t + ").constructor;")()
            } catch (t) {}
        }, h = Object.getOwnPropertyDescriptor;
        if (h)
            try {
                h({}, "")
            } catch (t) {
                h = null
            }
        var l = function() {
            throw new o
        }
          , u = h ? function() {
            try {
                return l
            } catch (t) {
                try {
                    return h(arguments, "callee").get
                } catch (t) {
                    return l
                }
            }
        }() : l
          , c = r(41405)()
          , d = r(28185)()
          , f = Object.getPrototypeOf || (d ? function(t) {
            return t.__proto__
        }
        : null)
          , p = {}
          , m = "undefined" != typeof Uint8Array && f ? f(Uint8Array) : n
          , g = {
            "%AggregateError%": "undefined" == typeof AggregateError ? n : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? n : ArrayBuffer,
            "%ArrayIteratorPrototype%": c && f ? f([][Symbol.iterator]()) : n,
            "%AsyncFromSyncIteratorPrototype%": n,
            "%AsyncFunction%": p,
            "%AsyncGenerator%": p,
            "%AsyncGeneratorFunction%": p,
            "%AsyncIteratorPrototype%": p,
            "%Atomics%": "undefined" == typeof Atomics ? n : Atomics,
            "%BigInt%": "undefined" == typeof BigInt ? n : BigInt,
            "%BigInt64Array%": "undefined" == typeof BigInt64Array ? n : BigInt64Array,
            "%BigUint64Array%": "undefined" == typeof BigUint64Array ? n : BigUint64Array,
            "%Boolean%": Boolean,
            "%DataView%": "undefined" == typeof DataView ? n : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": Error,
            "%eval%": eval,
            "%EvalError%": EvalError,
            "%Float32Array%": "undefined" == typeof Float32Array ? n : Float32Array,
            "%Float64Array%": "undefined" == typeof Float64Array ? n : Float64Array,
            "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? n : FinalizationRegistry,
            "%Function%": s,
            "%GeneratorFunction%": p,
            "%Int8Array%": "undefined" == typeof Int8Array ? n : Int8Array,
            "%Int16Array%": "undefined" == typeof Int16Array ? n : Int16Array,
            "%Int32Array%": "undefined" == typeof Int32Array ? n : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": c && f ? f(f([][Symbol.iterator]())) : n,
            "%JSON%": "object" == typeof JSON ? JSON : n,
            "%Map%": "undefined" == typeof Map ? n : Map,
            "%MapIteratorPrototype%": "undefined" != typeof Map && c && f ? f((new Map)[Symbol.iterator]()) : n,
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": Object,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": "undefined" == typeof Promise ? n : Promise,
            "%Proxy%": "undefined" == typeof Proxy ? n : Proxy,
            "%RangeError%": RangeError,
            "%ReferenceError%": ReferenceError,
            "%Reflect%": "undefined" == typeof Reflect ? n : Reflect,
            "%RegExp%": RegExp,
            "%Set%": "undefined" == typeof Set ? n : Set,
            "%SetIteratorPrototype%": "undefined" != typeof Set && c && f ? f((new Set)[Symbol.iterator]()) : n,
            "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? n : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": c && f ? f(""[Symbol.iterator]()) : n,
            "%Symbol%": c ? Symbol : n,
            "%SyntaxError%": i,
            "%ThrowTypeError%": u,
            "%TypedArray%": m,
            "%TypeError%": o,
            "%Uint8Array%": "undefined" == typeof Uint8Array ? n : Uint8Array,
            "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? n : Uint8ClampedArray,
            "%Uint16Array%": "undefined" == typeof Uint16Array ? n : Uint16Array,
            "%Uint32Array%": "undefined" == typeof Uint32Array ? n : Uint32Array,
            "%URIError%": URIError,
            "%WeakMap%": "undefined" == typeof WeakMap ? n : WeakMap,
            "%WeakRef%": "undefined" == typeof WeakRef ? n : WeakRef,
            "%WeakSet%": "undefined" == typeof WeakSet ? n : WeakSet
        };
        if (f)
            try {
                null.error
            } catch (t) {
                var v = f(f(t));
                g["%Error.prototype%"] = v
            }
        var y = function t(e) {
            var r;
            if ("%AsyncFunction%" === e)
                r = a("async function () {}");
            else if ("%GeneratorFunction%" === e)
                r = a("function* () {}");
            else if ("%AsyncGeneratorFunction%" === e)
                r = a("async function* () {}");
            else if ("%AsyncGenerator%" === e) {
                var n = t("%AsyncGeneratorFunction%");
                n && (r = n.prototype)
            } else if ("%AsyncIteratorPrototype%" === e) {
                var i = t("%AsyncGenerator%");
                i && f && (r = f(i.prototype))
            }
            return g[e] = r,
            r
        }
          , _ = {
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"]
        }
          , x = r(58612)
          , b = r(17642)
          , E = x.call(Function.call, Array.prototype.concat)
          , T = x.call(Function.apply, Array.prototype.splice)
          , w = x.call(Function.call, String.prototype.replace)
          , S = x.call(Function.call, String.prototype.slice)
          , A = x.call(Function.call, RegExp.prototype.exec)
          , C = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
          , R = /\\(\\)?/g
          , P = function(t, e) {
            var r, n = t;
            if (b(_, n) && (n = "%" + (r = _[n])[0] + "%"),
            b(g, n)) {
                var s = g[n];
                if (s === p && (s = y(n)),
                void 0 === s && !e)
                    throw new o("intrinsic " + t + " exists, but is not available. Please file an issue!");
                return {
                    alias: r,
                    name: n,
                    value: s
                }
            }
            throw new i("intrinsic " + t + " does not exist!")
        };
        t.exports = function(t, e) {
            if ("string" != typeof t || 0 === t.length)
                throw new o("intrinsic name must be a non-empty string");
            if (arguments.length > 1 && "boolean" != typeof e)
                throw new o('"allowMissing" argument must be a boolean');
            if (null === A(/^%?[^%]*%?$/, t))
                throw new i("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
            var r = function(t) {
                var e = S(t, 0, 1)
                  , r = S(t, -1);
                if ("%" === e && "%" !== r)
                    throw new i("invalid intrinsic syntax, expected closing `%`");
                if ("%" === r && "%" !== e)
                    throw new i("invalid intrinsic syntax, expected opening `%`");
                var n = [];
                return w(t, C, (function(t, e, r, i) {
                    n[n.length] = r ? w(i, R, "$1") : e || t
                }
                )),
                n
            }(t)
              , n = r.length > 0 ? r[0] : ""
              , s = P("%" + n + "%", e)
              , a = s.name
              , l = s.value
              , u = !1
              , c = s.alias;
            c && (n = c[0],
            T(r, E([0, 1], c)));
            for (var d = 1, f = !0; d < r.length; d += 1) {
                var p = r[d]
                  , m = S(p, 0, 1)
                  , v = S(p, -1);
                if (('"' === m || "'" === m || "`" === m || '"' === v || "'" === v || "`" === v) && m !== v)
                    throw new i("property names with quotes must have matching quotes");
                if ("constructor" !== p && f || (u = !0),
                b(g, a = "%" + (n += "." + p) + "%"))
                    l = g[a];
                else if (null != l) {
                    if (!(p in l)) {
                        if (!e)
                            throw new o("base intrinsic for " + t + " exists, but the property is not available.");
                        return
                    }
                    if (h && d + 1 >= r.length) {
                        var y = h(l, p);
                        l = (f = !!y) && "get"in y && !("originalValue"in y.get) ? y.get : l[p]
                    } else
                        f = b(l, p),
                        l = l[p];
                    f && !u && (g[a] = l)
                }
            }
            return l
        }
    },
    28185: function(t) {
        "use strict";
        var e = {
            foo: {}
        }
          , r = Object;
        t.exports = function() {
            return {
                __proto__: e
            }.foo === e.foo && !({
                __proto__: null
            }instanceof r)
        }
    },
    41405: function(t, e, r) {
        "use strict";
        var n = "undefined" != typeof Symbol && Symbol
          , i = r(55419);
        t.exports = function() {
            return "function" == typeof n && "function" == typeof Symbol && "symbol" == typeof n("foo") && "symbol" == typeof Symbol("bar") && i()
        }
    },
    55419: function(t) {
        "use strict";
        t.exports = function() {
            if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
                return !1;
            if ("symbol" == typeof Symbol.iterator)
                return !0;
            var t = {}
              , e = Symbol("test")
              , r = Object(e);
            if ("string" == typeof e)
                return !1;
            if ("[object Symbol]" !== Object.prototype.toString.call(e))
                return !1;
            if ("[object Symbol]" !== Object.prototype.toString.call(r))
                return !1;
            for (e in t[e] = 42,
            t)
                return !1;
            if ("function" == typeof Object.keys && 0 !== Object.keys(t).length)
                return !1;
            if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t).length)
                return !1;
            var n = Object.getOwnPropertySymbols(t);
            if (1 !== n.length || n[0] !== e)
                return !1;
            if (!Object.prototype.propertyIsEnumerable.call(t, e))
                return !1;
            if ("function" == typeof Object.getOwnPropertyDescriptor) {
                var i = Object.getOwnPropertyDescriptor(t, e);
                if (42 !== i.value || !0 !== i.enumerable)
                    return !1
            }
            return !0
        }
    },
    17642: function(t, e, r) {
        "use strict";
        var n = r(58612);
        t.exports = n.call(Function.call, Object.prototype.hasOwnProperty)
    },
    70631: function(t, e, r) {
        var n = "function" == typeof Map && Map.prototype
          , i = Object.getOwnPropertyDescriptor && n ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null
          , s = n && i && "function" == typeof i.get ? i.get : null
          , o = n && Map.prototype.forEach
          , a = "function" == typeof Set && Set.prototype
          , h = Object.getOwnPropertyDescriptor && a ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null
          , l = a && h && "function" == typeof h.get ? h.get : null
          , u = a && Set.prototype.forEach
          , c = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null
          , d = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null
          , f = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null
          , p = Boolean.prototype.valueOf
          , m = Object.prototype.toString
          , g = Function.prototype.toString
          , v = String.prototype.match
          , y = String.prototype.slice
          , _ = String.prototype.replace
          , x = String.prototype.toUpperCase
          , b = String.prototype.toLowerCase
          , E = RegExp.prototype.test
          , T = Array.prototype.concat
          , w = Array.prototype.join
          , S = Array.prototype.slice
          , A = Math.floor
          , C = "function" == typeof BigInt ? BigInt.prototype.valueOf : null
          , R = Object.getOwnPropertySymbols
          , P = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null
          , I = "function" == typeof Symbol && "object" == typeof Symbol.iterator
          , M = "function" == typeof Symbol && Symbol.toStringTag && (Symbol.toStringTag,
        1) ? Symbol.toStringTag : null
          , D = Object.prototype.propertyIsEnumerable
          , O = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
            return t.__proto__
        }
        : null);
        function B(t, e) {
            if (t === 1 / 0 || t === -1 / 0 || t != t || t && t > -1e3 && t < 1e3 || E.call(/e/, e))
                return e;
            var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
            if ("number" == typeof t) {
                var n = t < 0 ? -A(-t) : A(t);
                if (n !== t) {
                    var i = String(n)
                      , s = y.call(e, i.length + 1);
                    return _.call(i, r, "$&_") + "." + _.call(_.call(s, /([0-9]{3})/g, "$&_"), /_$/, "")
                }
            }
            return _.call(e, r, "$&_")
        }
        var k = r(24654)
          , L = k.custom
          , N = z(L) ? L : null;
        function F(t, e, r) {
            var n = "double" === (r.quoteStyle || e) ? '"' : "'";
            return n + t + n
        }
        function U(t) {
            return _.call(String(t), /"/g, "&quot;")
        }
        function G(t) {
            return !("[object Array]" !== X(t) || M && "object" == typeof t && M in t)
        }
        function j(t) {
            return !("[object RegExp]" !== X(t) || M && "object" == typeof t && M in t)
        }
        function z(t) {
            if (I)
                return t && "object" == typeof t && t instanceof Symbol;
            if ("symbol" == typeof t)
                return !0;
            if (!t || "object" != typeof t || !P)
                return !1;
            try {
                return P.call(t),
                !0
            } catch (t) {}
            return !1
        }
        t.exports = function t(e, r, n, i) {
            var a = r || {};
            if ($(a, "quoteStyle") && "single" !== a.quoteStyle && "double" !== a.quoteStyle)
                throw new TypeError('option "quoteStyle" must be "single" or "double"');
            if ($(a, "maxStringLength") && ("number" == typeof a.maxStringLength ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : null !== a.maxStringLength))
                throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            var h = !$(a, "customInspect") || a.customInspect;
            if ("boolean" != typeof h && "symbol" !== h)
                throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
            if ($(a, "indent") && null !== a.indent && "\t" !== a.indent && !(parseInt(a.indent, 10) === a.indent && a.indent > 0))
                throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
            if ($(a, "numericSeparator") && "boolean" != typeof a.numericSeparator)
                throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
            var m = a.numericSeparator;
            if (void 0 === e)
                return "undefined";
            if (null === e)
                return "null";
            if ("boolean" == typeof e)
                return e ? "true" : "false";
            if ("string" == typeof e)
                return W(e, a);
            if ("number" == typeof e) {
                if (0 === e)
                    return 1 / 0 / e > 0 ? "0" : "-0";
                var x = String(e);
                return m ? B(e, x) : x
            }
            if ("bigint" == typeof e) {
                var E = String(e) + "n";
                return m ? B(e, E) : E
            }
            var A = void 0 === a.depth ? 5 : a.depth;
            if (void 0 === n && (n = 0),
            n >= A && A > 0 && "object" == typeof e)
                return G(e) ? "[Array]" : "[Object]";
            var R, L = function(t, e) {
                var r;
                if ("\t" === t.indent)
                    r = "\t";
                else {
                    if (!("number" == typeof t.indent && t.indent > 0))
                        return null;
                    r = w.call(Array(t.indent + 1), " ")
                }
                return {
                    base: r,
                    prev: w.call(Array(e + 1), r)
                }
            }(a, n);
            if (void 0 === i)
                i = [];
            else if (V(i, e) >= 0)
                return "[Circular]";
            function H(e, r, s) {
                if (r && (i = S.call(i)).push(r),
                s) {
                    var o = {
                        depth: a.depth
                    };
                    return $(a, "quoteStyle") && (o.quoteStyle = a.quoteStyle),
                    t(e, o, n + 1, i)
                }
                return t(e, a, n + 1, i)
            }
            if ("function" == typeof e && !j(e)) {
                var Y = function(t) {
                    if (t.name)
                        return t.name;
                    var e = v.call(g.call(t), /^function\s*([\w$]+)/);
                    return e ? e[1] : null
                }(e)
                  , tt = Q(e, H);
                return "[Function" + (Y ? ": " + Y : " (anonymous)") + "]" + (tt.length > 0 ? " { " + w.call(tt, ", ") + " }" : "")
            }
            if (z(e)) {
                var et = I ? _.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : P.call(e);
                return "object" != typeof e || I ? et : q(et)
            }
            if ((R = e) && "object" == typeof R && ("undefined" != typeof HTMLElement && R instanceof HTMLElement || "string" == typeof R.nodeName && "function" == typeof R.getAttribute)) {
                for (var rt = "<" + b.call(String(e.nodeName)), nt = e.attributes || [], it = 0; it < nt.length; it++)
                    rt += " " + nt[it].name + "=" + F(U(nt[it].value), "double", a);
                return rt += ">",
                e.childNodes && e.childNodes.length && (rt += "..."),
                rt + "</" + b.call(String(e.nodeName)) + ">"
            }
            if (G(e)) {
                if (0 === e.length)
                    return "[]";
                var st = Q(e, H);
                return L && !function(t) {
                    for (var e = 0; e < t.length; e++)
                        if (V(t[e], "\n") >= 0)
                            return !1;
                    return !0
                }(st) ? "[" + J(st, L) + "]" : "[ " + w.call(st, ", ") + " ]"
            }
            if (function(t) {
                return !("[object Error]" !== X(t) || M && "object" == typeof t && M in t)
            }(e)) {
                var ot = Q(e, H);
                return "cause"in Error.prototype || !("cause"in e) || D.call(e, "cause") ? 0 === ot.length ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + w.call(ot, ", ") + " }" : "{ [" + String(e) + "] " + w.call(T.call("[cause]: " + H(e.cause), ot), ", ") + " }"
            }
            if ("object" == typeof e && h) {
                if (N && "function" == typeof e[N] && k)
                    return k(e, {
                        depth: A - n
                    });
                if ("symbol" !== h && "function" == typeof e.inspect)
                    return e.inspect()
            }
            if (function(t) {
                if (!s || !t || "object" != typeof t)
                    return !1;
                try {
                    s.call(t);
                    try {
                        l.call(t)
                    } catch (t) {
                        return !0
                    }
                    return t instanceof Map
                } catch (t) {}
                return !1
            }(e)) {
                var at = [];
                return o && o.call(e, (function(t, r) {
                    at.push(H(r, e, !0) + " => " + H(t, e))
                }
                )),
                Z("Map", s.call(e), at, L)
            }
            if (function(t) {
                if (!l || !t || "object" != typeof t)
                    return !1;
                try {
                    l.call(t);
                    try {
                        s.call(t)
                    } catch (t) {
                        return !0
                    }
                    return t instanceof Set
                } catch (t) {}
                return !1
            }(e)) {
                var ht = [];
                return u && u.call(e, (function(t) {
                    ht.push(H(t, e))
                }
                )),
                Z("Set", l.call(e), ht, L)
            }
            if (function(t) {
                if (!c || !t || "object" != typeof t)
                    return !1;
                try {
                    c.call(t, c);
                    try {
                        d.call(t, d)
                    } catch (t) {
                        return !0
                    }
                    return t instanceof WeakMap
                } catch (t) {}
                return !1
            }(e))
                return K("WeakMap");
            if (function(t) {
                if (!d || !t || "object" != typeof t)
                    return !1;
                try {
                    d.call(t, d);
                    try {
                        c.call(t, c)
                    } catch (t) {
                        return !0
                    }
                    return t instanceof WeakSet
                } catch (t) {}
                return !1
            }(e))
                return K("WeakSet");
            if (function(t) {
                if (!f || !t || "object" != typeof t)
                    return !1;
                try {
                    return f.call(t),
                    !0
                } catch (t) {}
                return !1
            }(e))
                return K("WeakRef");
            if (function(t) {
                return !("[object Number]" !== X(t) || M && "object" == typeof t && M in t)
            }(e))
                return q(H(Number(e)));
            if (function(t) {
                if (!t || "object" != typeof t || !C)
                    return !1;
                try {
                    return C.call(t),
                    !0
                } catch (t) {}
                return !1
            }(e))
                return q(H(C.call(e)));
            if (function(t) {
                return !("[object Boolean]" !== X(t) || M && "object" == typeof t && M in t)
            }(e))
                return q(p.call(e));
            if (function(t) {
                return !("[object String]" !== X(t) || M && "object" == typeof t && M in t)
            }(e))
                return q(H(String(e)));
            if (!function(t) {
                return !("[object Date]" !== X(t) || M && "object" == typeof t && M in t)
            }(e) && !j(e)) {
                var lt = Q(e, H)
                  , ut = O ? O(e) === Object.prototype : e instanceof Object || e.constructor === Object
                  , ct = e instanceof Object ? "" : "null prototype"
                  , dt = !ut && M && Object(e) === e && M in e ? y.call(X(e), 8, -1) : ct ? "Object" : ""
                  , ft = (ut || "function" != typeof e.constructor ? "" : e.constructor.name ? e.constructor.name + " " : "") + (dt || ct ? "[" + w.call(T.call([], dt || [], ct || []), ": ") + "] " : "");
                return 0 === lt.length ? ft + "{}" : L ? ft + "{" + J(lt, L) + "}" : ft + "{ " + w.call(lt, ", ") + " }"
            }
            return String(e)
        }
        ;
        var H = Object.prototype.hasOwnProperty || function(t) {
            return t in this
        }
        ;
        function $(t, e) {
            return H.call(t, e)
        }
        function X(t) {
            return m.call(t)
        }
        function V(t, e) {
            if (t.indexOf)
                return t.indexOf(e);
            for (var r = 0, n = t.length; r < n; r++)
                if (t[r] === e)
                    return r;
            return -1
        }
        function W(t, e) {
            if (t.length > e.maxStringLength) {
                var r = t.length - e.maxStringLength
                  , n = "... " + r + " more character" + (r > 1 ? "s" : "");
                return W(y.call(t, 0, e.maxStringLength), e) + n
            }
            return F(_.call(_.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Y), "single", e)
        }
        function Y(t) {
            var e = t.charCodeAt(0)
              , r = {
                8: "b",
                9: "t",
                10: "n",
                12: "f",
                13: "r"
            }[e];
            return r ? "\\" + r : "\\x" + (e < 16 ? "0" : "") + x.call(e.toString(16))
        }
        function q(t) {
            return "Object(" + t + ")"
        }
        function K(t) {
            return t + " { ? }"
        }
        function Z(t, e, r, n) {
            return t + " (" + e + ") {" + (n ? J(r, n) : w.call(r, ", ")) + "}"
        }
        function J(t, e) {
            if (0 === t.length)
                return "";
            var r = "\n" + e.prev + e.base;
            return r + w.call(t, "," + r) + "\n" + e.prev
        }
        function Q(t, e) {
            var r = G(t)
              , n = [];
            if (r) {
                n.length = t.length;
                for (var i = 0; i < t.length; i++)
                    n[i] = $(t, i) ? e(t[i], t) : ""
            }
            var s, o = "function" == typeof R ? R(t) : [];
            if (I) {
                s = {};
                for (var a = 0; a < o.length; a++)
                    s["$" + o[a]] = o[a]
            }
            for (var h in t)
                $(t, h) && (r && String(Number(h)) === h && h < t.length || I && s["$" + h]instanceof Symbol || (E.call(/[^\w$]/, h) ? n.push(e(h, t) + ": " + e(t[h], t)) : n.push(h + ": " + e(t[h], t))));
            if ("function" == typeof R)
                for (var l = 0; l < o.length; l++)
                    D.call(t, o[l]) && n.push("[" + e(o[l]) + "]: " + e(t[o[l]], t));
            return n
        }
    },
    37478: function(t, e, r) {
        "use strict";
        var n = r(40210)
          , i = r(21924)
          , s = r(70631)
          , o = n("%TypeError%")
          , a = n("%WeakMap%", !0)
          , h = n("%Map%", !0)
          , l = i("WeakMap.prototype.get", !0)
          , u = i("WeakMap.prototype.set", !0)
          , c = i("WeakMap.prototype.has", !0)
          , d = i("Map.prototype.get", !0)
          , f = i("Map.prototype.set", !0)
          , p = i("Map.prototype.has", !0)
          , m = function(t, e) {
            for (var r, n = t; null !== (r = n.next); n = r)
                if (r.key === e)
                    return n.next = r.next,
                    r.next = t.next,
                    t.next = r,
                    r
        };
        t.exports = function() {
            var t, e, r, n = {
                assert: function(t) {
                    if (!n.has(t))
                        throw new o("Side channel does not contain " + s(t))
                },
                get: function(n) {
                    if (a && n && ("object" == typeof n || "function" == typeof n)) {
                        if (t)
                            return l(t, n)
                    } else if (h) {
                        if (e)
                            return d(e, n)
                    } else if (r)
                        return function(t, e) {
                            var r = m(t, e);
                            return r && r.value
                        }(r, n)
                },
                has: function(n) {
                    if (a && n && ("object" == typeof n || "function" == typeof n)) {
                        if (t)
                            return c(t, n)
                    } else if (h) {
                        if (e)
                            return p(e, n)
                    } else if (r)
                        return function(t, e) {
                            return !!m(t, e)
                        }(r, n);
                    return !1
                },
                set: function(n, i) {
                    a && n && ("object" == typeof n || "function" == typeof n) ? (t || (t = new a),
                    u(t, n, i)) : h ? (e || (e = new h),
                    f(e, n, i)) : (r || (r = {
                        key: {},
                        next: null
                    }),
                    function(t, e, r) {
                        var n = m(t, e);
                        n ? n.value = r : t.next = {
                            key: e,
                            next: t.next,
                            value: r
                        }
                    }(r, n, i))
                }
            };
            return n
        }
    },
    52511: function(t, e, r) {
        var n;
        t = r.nmd(t),
        function(i) {
            e && e.nodeType,
            t && t.nodeType;
            var s = "object" == typeof r.g && r.g;
            s.global !== s && s.window !== s && s.self;
            var o, a = 2147483647, h = 36, l = 26, u = 38, c = 700, d = /^xn--/, f = /[^\x20-\x7E]/, p = /[\x2E\u3002\uFF0E\uFF61]/g, m = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, g = h - 1, v = Math.floor, y = String.fromCharCode;
            function _(t) {
                throw new RangeError(m[t])
            }
            function x(t, e) {
                for (var r = t.length, n = []; r--; )
                    n[r] = e(t[r]);
                return n
            }
            function b(t, e) {
                var r = t.split("@")
                  , n = "";
                return r.length > 1 && (n = r[0] + "@",
                t = r[1]),
                n + x((t = t.replace(p, ".")).split("."), e).join(".")
            }
            function E(t) {
                for (var e, r, n = [], i = 0, s = t.length; i < s; )
                    (e = t.charCodeAt(i++)) >= 55296 && e <= 56319 && i < s ? 56320 == (64512 & (r = t.charCodeAt(i++))) ? n.push(((1023 & e) << 10) + (1023 & r) + 65536) : (n.push(e),
                    i--) : n.push(e);
                return n
            }
            function T(t) {
                return x(t, (function(t) {
                    var e = "";
                    return t > 65535 && (e += y((t -= 65536) >>> 10 & 1023 | 55296),
                    t = 56320 | 1023 & t),
                    e + y(t)
                }
                )).join("")
            }
            function w(t, e) {
                return t + 22 + 75 * (t < 26) - ((0 != e) << 5)
            }
            function S(t, e, r) {
                var n = 0;
                for (t = r ? v(t / c) : t >> 1,
                t += v(t / e); t > g * l >> 1; n += h)
                    t = v(t / g);
                return v(n + (g + 1) * t / (t + u))
            }
            function A(t) {
                var e, r, n, i, s, o, u, c, d, f, p, m = [], g = t.length, y = 0, x = 128, b = 72;
                for ((r = t.lastIndexOf("-")) < 0 && (r = 0),
                n = 0; n < r; ++n)
                    t.charCodeAt(n) >= 128 && _("not-basic"),
                    m.push(t.charCodeAt(n));
                for (i = r > 0 ? r + 1 : 0; i < g; ) {
                    for (s = y,
                    o = 1,
                    u = h; i >= g && _("invalid-input"),
                    ((c = (p = t.charCodeAt(i++)) - 48 < 10 ? p - 22 : p - 65 < 26 ? p - 65 : p - 97 < 26 ? p - 97 : h) >= h || c > v((a - y) / o)) && _("overflow"),
                    y += c * o,
                    !(c < (d = u <= b ? 1 : u >= b + l ? l : u - b)); u += h)
                        o > v(a / (f = h - d)) && _("overflow"),
                        o *= f;
                    b = S(y - s, e = m.length + 1, 0 == s),
                    v(y / e) > a - x && _("overflow"),
                    x += v(y / e),
                    y %= e,
                    m.splice(y++, 0, x)
                }
                return T(m)
            }
            function C(t) {
                var e, r, n, i, s, o, u, c, d, f, p, m, g, x, b, T = [];
                for (m = (t = E(t)).length,
                e = 128,
                r = 0,
                s = 72,
                o = 0; o < m; ++o)
                    (p = t[o]) < 128 && T.push(y(p));
                for (n = i = T.length,
                i && T.push("-"); n < m; ) {
                    for (u = a,
                    o = 0; o < m; ++o)
                        (p = t[o]) >= e && p < u && (u = p);
                    for (u - e > v((a - r) / (g = n + 1)) && _("overflow"),
                    r += (u - e) * g,
                    e = u,
                    o = 0; o < m; ++o)
                        if ((p = t[o]) < e && ++r > a && _("overflow"),
                        p == e) {
                            for (c = r,
                            d = h; !(c < (f = d <= s ? 1 : d >= s + l ? l : d - s)); d += h)
                                b = c - f,
                                x = h - f,
                                T.push(y(w(f + b % x, 0))),
                                c = v(b / x);
                            T.push(y(w(c, 0))),
                            s = S(r, g, n == i),
                            r = 0,
                            ++n
                        }
                    ++r,
                    ++e
                }
                return T.join("")
            }
            o = {
                version: "1.4.1",
                ucs2: {
                    decode: E,
                    encode: T
                },
                decode: A,
                encode: C,
                toASCII: function(t) {
                    return b(t, (function(t) {
                        return f.test(t) ? "xn--" + C(t) : t
                    }
                    ))
                },
                toUnicode: function(t) {
                    return b(t, (function(t) {
                        return d.test(t) ? A(t.slice(4).toLowerCase()) : t
                    }
                    ))
                }
            },
            void 0 === (n = function() {
                return o
            }
            .call(e, r, e, t)) || (t.exports = n)
        }()
    },
    39532: function(t) {
        "use strict";
        var e = String.prototype.replace
          , r = /%20/g
          , n = "RFC3986";
        t.exports = {
            default: n,
            formatters: {
                RFC1738: function(t) {
                    return e.call(t, r, "+")
                },
                RFC3986: function(t) {
                    return String(t)
                }
            },
            RFC1738: "RFC1738",
            RFC3986: n
        }
    },
    35984: function(t, e, r) {
        "use strict";
        var n = r(24730)
          , i = r(7325)
          , s = r(39532);
        t.exports = {
            formats: s,
            parse: i,
            stringify: n
        }
    },
    7325: function(t, e, r) {
        "use strict";
        var n = r(19368)
          , i = Object.prototype.hasOwnProperty
          , s = Array.isArray
          , o = {
            allowDots: !1,
            allowPrototypes: !1,
            allowSparse: !1,
            arrayLimit: 20,
            charset: "utf-8",
            charsetSentinel: !1,
            comma: !1,
            decoder: n.decode,
            delimiter: "&",
            depth: 5,
            ignoreQueryPrefix: !1,
            interpretNumericEntities: !1,
            parameterLimit: 1e3,
            parseArrays: !0,
            plainObjects: !1,
            strictNullHandling: !1
        }
          , a = function(t) {
            return t.replace(/&#(\d+);/g, (function(t, e) {
                return String.fromCharCode(parseInt(e, 10))
            }
            ))
        }
          , h = function(t, e) {
            return t && "string" == typeof t && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
        }
          , l = function(t, e, r, n) {
            if (t) {
                var s = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t
                  , o = /(\[[^[\]]*])/g
                  , a = r.depth > 0 && /(\[[^[\]]*])/.exec(s)
                  , l = a ? s.slice(0, a.index) : s
                  , u = [];
                if (l) {
                    if (!r.plainObjects && i.call(Object.prototype, l) && !r.allowPrototypes)
                        return;
                    u.push(l)
                }
                for (var c = 0; r.depth > 0 && null !== (a = o.exec(s)) && c < r.depth; ) {
                    if (c += 1,
                    !r.plainObjects && i.call(Object.prototype, a[1].slice(1, -1)) && !r.allowPrototypes)
                        return;
                    u.push(a[1])
                }
                return a && u.push("[" + s.slice(a.index) + "]"),
                function(t, e, r, n) {
                    for (var i = n ? e : h(e, r), s = t.length - 1; s >= 0; --s) {
                        var o, a = t[s];
                        if ("[]" === a && r.parseArrays)
                            o = [].concat(i);
                        else {
                            o = r.plainObjects ? Object.create(null) : {};
                            var l = "[" === a.charAt(0) && "]" === a.charAt(a.length - 1) ? a.slice(1, -1) : a
                              , u = parseInt(l, 10);
                            r.parseArrays || "" !== l ? !isNaN(u) && a !== l && String(u) === l && u >= 0 && r.parseArrays && u <= r.arrayLimit ? (o = [])[u] = i : "__proto__" !== l && (o[l] = i) : o = {
                                0: i
                            }
                        }
                        i = o
                    }
                    return i
                }(u, e, r, n)
            }
        };
        t.exports = function(t, e) {
            var r = function(t) {
                if (!t)
                    return o;
                if (null !== t.decoder && void 0 !== t.decoder && "function" != typeof t.decoder)
                    throw new TypeError("Decoder has to be a function.");
                if (void 0 !== t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset)
                    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
                var e = void 0 === t.charset ? o.charset : t.charset;
                return {
                    allowDots: void 0 === t.allowDots ? o.allowDots : !!t.allowDots,
                    allowPrototypes: "boolean" == typeof t.allowPrototypes ? t.allowPrototypes : o.allowPrototypes,
                    allowSparse: "boolean" == typeof t.allowSparse ? t.allowSparse : o.allowSparse,
                    arrayLimit: "number" == typeof t.arrayLimit ? t.arrayLimit : o.arrayLimit,
                    charset: e,
                    charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : o.charsetSentinel,
                    comma: "boolean" == typeof t.comma ? t.comma : o.comma,
                    decoder: "function" == typeof t.decoder ? t.decoder : o.decoder,
                    delimiter: "string" == typeof t.delimiter || n.isRegExp(t.delimiter) ? t.delimiter : o.delimiter,
                    depth: "number" == typeof t.depth || !1 === t.depth ? +t.depth : o.depth,
                    ignoreQueryPrefix: !0 === t.ignoreQueryPrefix,
                    interpretNumericEntities: "boolean" == typeof t.interpretNumericEntities ? t.interpretNumericEntities : o.interpretNumericEntities,
                    parameterLimit: "number" == typeof t.parameterLimit ? t.parameterLimit : o.parameterLimit,
                    parseArrays: !1 !== t.parseArrays,
                    plainObjects: "boolean" == typeof t.plainObjects ? t.plainObjects : o.plainObjects,
                    strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : o.strictNullHandling
                }
            }(e);
            if ("" === t || null == t)
                return r.plainObjects ? Object.create(null) : {};
            for (var u = "string" == typeof t ? function(t, e) {
                var r, l = {
                    __proto__: null
                }, u = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t, c = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit, d = u.split(e.delimiter, c), f = -1, p = e.charset;
                if (e.charsetSentinel)
                    for (r = 0; r < d.length; ++r)
                        0 === d[r].indexOf("utf8=") && ("utf8=%E2%9C%93" === d[r] ? p = "utf-8" : "utf8=%26%2310003%3B" === d[r] && (p = "iso-8859-1"),
                        f = r,
                        r = d.length);
                for (r = 0; r < d.length; ++r)
                    if (r !== f) {
                        var m, g, v = d[r], y = v.indexOf("]="), _ = -1 === y ? v.indexOf("=") : y + 1;
                        -1 === _ ? (m = e.decoder(v, o.decoder, p, "key"),
                        g = e.strictNullHandling ? null : "") : (m = e.decoder(v.slice(0, _), o.decoder, p, "key"),
                        g = n.maybeMap(h(v.slice(_ + 1), e), (function(t) {
                            return e.decoder(t, o.decoder, p, "value")
                        }
                        ))),
                        g && e.interpretNumericEntities && "iso-8859-1" === p && (g = a(g)),
                        v.indexOf("[]=") > -1 && (g = s(g) ? [g] : g),
                        i.call(l, m) ? l[m] = n.combine(l[m], g) : l[m] = g
                    }
                return l
            }(t, r) : t, c = r.plainObjects ? Object.create(null) : {}, d = Object.keys(u), f = 0; f < d.length; ++f) {
                var p = d[f]
                  , m = l(p, u[p], r, "string" == typeof t);
                c = n.merge(c, m, r)
            }
            return !0 === r.allowSparse ? c : n.compact(c)
        }
    },
    24730: function(t, e, r) {
        "use strict";
        var n = r(37478)
          , i = r(19368)
          , s = r(39532)
          , o = Object.prototype.hasOwnProperty
          , a = {
            brackets: function(t) {
                return t + "[]"
            },
            comma: "comma",
            indices: function(t, e) {
                return t + "[" + e + "]"
            },
            repeat: function(t) {
                return t
            }
        }
          , h = Array.isArray
          , l = Array.prototype.push
          , u = function(t, e) {
            l.apply(t, h(e) ? e : [e])
        }
          , c = Date.prototype.toISOString
          , d = s.default
          , f = {
            addQueryPrefix: !1,
            allowDots: !1,
            charset: "utf-8",
            charsetSentinel: !1,
            delimiter: "&",
            encode: !0,
            encoder: i.encode,
            encodeValuesOnly: !1,
            format: d,
            formatter: s.formatters[d],
            indices: !1,
            serializeDate: function(t) {
                return c.call(t)
            },
            skipNulls: !1,
            strictNullHandling: !1
        }
          , p = {}
          , m = function t(e, r, s, o, a, l, c, d, m, g, v, y, _, x, b, E) {
            for (var T, w = e, S = E, A = 0, C = !1; void 0 !== (S = S.get(p)) && !C; ) {
                var R = S.get(e);
                if (A += 1,
                void 0 !== R) {
                    if (R === A)
                        throw new RangeError("Cyclic object value");
                    C = !0
                }
                void 0 === S.get(p) && (A = 0)
            }
            if ("function" == typeof d ? w = d(r, w) : w instanceof Date ? w = v(w) : "comma" === s && h(w) && (w = i.maybeMap(w, (function(t) {
                return t instanceof Date ? v(t) : t
            }
            ))),
            null === w) {
                if (a)
                    return c && !x ? c(r, f.encoder, b, "key", y) : r;
                w = ""
            }
            if ("string" == typeof (T = w) || "number" == typeof T || "boolean" == typeof T || "symbol" == typeof T || "bigint" == typeof T || i.isBuffer(w))
                return c ? [_(x ? r : c(r, f.encoder, b, "key", y)) + "=" + _(c(w, f.encoder, b, "value", y))] : [_(r) + "=" + _(String(w))];
            var P, I = [];
            if (void 0 === w)
                return I;
            if ("comma" === s && h(w))
                x && c && (w = i.maybeMap(w, c)),
                P = [{
                    value: w.length > 0 ? w.join(",") || null : void 0
                }];
            else if (h(d))
                P = d;
            else {
                var M = Object.keys(w);
                P = m ? M.sort(m) : M
            }
            for (var D = o && h(w) && 1 === w.length ? r + "[]" : r, O = 0; O < P.length; ++O) {
                var B = P[O]
                  , k = "object" == typeof B && void 0 !== B.value ? B.value : w[B];
                if (!l || null !== k) {
                    var L = h(w) ? "function" == typeof s ? s(D, B) : D : D + (g ? "." + B : "[" + B + "]");
                    E.set(e, A);
                    var N = n();
                    N.set(p, E),
                    u(I, t(k, L, s, o, a, l, "comma" === s && x && h(w) ? null : c, d, m, g, v, y, _, x, b, N))
                }
            }
            return I
        };
        t.exports = function(t, e) {
            var r, i = t, l = function(t) {
                if (!t)
                    return f;
                if (null !== t.encoder && void 0 !== t.encoder && "function" != typeof t.encoder)
                    throw new TypeError("Encoder has to be a function.");
                var e = t.charset || f.charset;
                if (void 0 !== t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset)
                    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
                var r = s.default;
                if (void 0 !== t.format) {
                    if (!o.call(s.formatters, t.format))
                        throw new TypeError("Unknown format option provided.");
                    r = t.format
                }
                var n = s.formatters[r]
                  , i = f.filter;
                return ("function" == typeof t.filter || h(t.filter)) && (i = t.filter),
                {
                    addQueryPrefix: "boolean" == typeof t.addQueryPrefix ? t.addQueryPrefix : f.addQueryPrefix,
                    allowDots: void 0 === t.allowDots ? f.allowDots : !!t.allowDots,
                    charset: e,
                    charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : f.charsetSentinel,
                    delimiter: void 0 === t.delimiter ? f.delimiter : t.delimiter,
                    encode: "boolean" == typeof t.encode ? t.encode : f.encode,
                    encoder: "function" == typeof t.encoder ? t.encoder : f.encoder,
                    encodeValuesOnly: "boolean" == typeof t.encodeValuesOnly ? t.encodeValuesOnly : f.encodeValuesOnly,
                    filter: i,
                    format: r,
                    formatter: n,
                    serializeDate: "function" == typeof t.serializeDate ? t.serializeDate : f.serializeDate,
                    skipNulls: "boolean" == typeof t.skipNulls ? t.skipNulls : f.skipNulls,
                    sort: "function" == typeof t.sort ? t.sort : null,
                    strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : f.strictNullHandling
                }
            }(e);
            "function" == typeof l.filter ? i = (0,
            l.filter)("", i) : h(l.filter) && (r = l.filter);
            var c, d = [];
            if ("object" != typeof i || null === i)
                return "";
            c = e && e.arrayFormat in a ? e.arrayFormat : e && "indices"in e ? e.indices ? "indices" : "repeat" : "indices";
            var p = a[c];
            if (e && "commaRoundTrip"in e && "boolean" != typeof e.commaRoundTrip)
                throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
            var g = "comma" === p && e && e.commaRoundTrip;
            r || (r = Object.keys(i)),
            l.sort && r.sort(l.sort);
            for (var v = n(), y = 0; y < r.length; ++y) {
                var _ = r[y];
                l.skipNulls && null === i[_] || u(d, m(i[_], _, p, g, l.strictNullHandling, l.skipNulls, l.encode ? l.encoder : null, l.filter, l.sort, l.allowDots, l.serializeDate, l.format, l.formatter, l.encodeValuesOnly, l.charset, v))
            }
            var x = d.join(l.delimiter)
              , b = !0 === l.addQueryPrefix ? "?" : "";
            return l.charsetSentinel && ("iso-8859-1" === l.charset ? b += "utf8=%26%2310003%3B&" : b += "utf8=%E2%9C%93&"),
            x.length > 0 ? b + x : ""
        }
    },
    19368: function(t, e, r) {
        "use strict";
        var n = r(39532)
          , i = Object.prototype.hasOwnProperty
          , s = Array.isArray
          , o = function() {
            for (var t = [], e = 0; e < 256; ++e)
                t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
            return t
        }()
          , a = function(t, e) {
            for (var r = e && e.plainObjects ? Object.create(null) : {}, n = 0; n < t.length; ++n)
                void 0 !== t[n] && (r[n] = t[n]);
            return r
        };
        t.exports = {
            arrayToObject: a,
            assign: function(t, e) {
                return Object.keys(e).reduce((function(t, r) {
                    return t[r] = e[r],
                    t
                }
                ), t)
            },
            combine: function(t, e) {
                return [].concat(t, e)
            },
            compact: function(t) {
                for (var e = [{
                    obj: {
                        o: t
                    },
                    prop: "o"
                }], r = [], n = 0; n < e.length; ++n)
                    for (var i = e[n], o = i.obj[i.prop], a = Object.keys(o), h = 0; h < a.length; ++h) {
                        var l = a[h]
                          , u = o[l];
                        "object" == typeof u && null !== u && -1 === r.indexOf(u) && (e.push({
                            obj: o,
                            prop: l
                        }),
                        r.push(u))
                    }
                return function(t) {
                    for (; t.length > 1; ) {
                        var e = t.pop()
                          , r = e.obj[e.prop];
                        if (s(r)) {
                            for (var n = [], i = 0; i < r.length; ++i)
                                void 0 !== r[i] && n.push(r[i]);
                            e.obj[e.prop] = n
                        }
                    }
                }(e),
                t
            },
            decode: function(t, e, r) {
                var n = t.replace(/\+/g, " ");
                if ("iso-8859-1" === r)
                    return n.replace(/%[0-9a-f]{2}/gi, unescape);
                try {
                    return decodeURIComponent(n)
                } catch (t) {
                    return n
                }
            },
            encode: function(t, e, r, i, s) {
                if (0 === t.length)
                    return t;
                var a = t;
                if ("symbol" == typeof t ? a = Symbol.prototype.toString.call(t) : "string" != typeof t && (a = String(t)),
                "iso-8859-1" === r)
                    return escape(a).replace(/%u[0-9a-f]{4}/gi, (function(t) {
                        return "%26%23" + parseInt(t.slice(2), 16) + "%3B"
                    }
                    ));
                for (var h = "", l = 0; l < a.length; ++l) {
                    var u = a.charCodeAt(l);
                    45 === u || 46 === u || 95 === u || 126 === u || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || s === n.RFC1738 && (40 === u || 41 === u) ? h += a.charAt(l) : u < 128 ? h += o[u] : u < 2048 ? h += o[192 | u >> 6] + o[128 | 63 & u] : u < 55296 || u >= 57344 ? h += o[224 | u >> 12] + o[128 | u >> 6 & 63] + o[128 | 63 & u] : (l += 1,
                    u = 65536 + ((1023 & u) << 10 | 1023 & a.charCodeAt(l)),
                    h += o[240 | u >> 18] + o[128 | u >> 12 & 63] + o[128 | u >> 6 & 63] + o[128 | 63 & u])
                }
                return h
            },
            isBuffer: function(t) {
                return !(!t || "object" != typeof t || !(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t)))
            },
            isRegExp: function(t) {
                return "[object RegExp]" === Object.prototype.toString.call(t)
            },
            maybeMap: function(t, e) {
                if (s(t)) {
                    for (var r = [], n = 0; n < t.length; n += 1)
                        r.push(e(t[n]));
                    return r
                }
                return e(t)
            },
            merge: function t(e, r, n) {
                if (!r)
                    return e;
                if ("object" != typeof r) {
                    if (s(e))
                        e.push(r);
                    else {
                        if (!e || "object" != typeof e)
                            return [e, r];
                        (n && (n.plainObjects || n.allowPrototypes) || !i.call(Object.prototype, r)) && (e[r] = !0)
                    }
                    return e
                }
                if (!e || "object" != typeof e)
                    return [e].concat(r);
                var o = e;
                return s(e) && !s(r) && (o = a(e, n)),
                s(e) && s(r) ? (r.forEach((function(r, s) {
                    if (i.call(e, s)) {
                        var o = e[s];
                        o && "object" == typeof o && r && "object" == typeof r ? e[s] = t(o, r, n) : e.push(r)
                    } else
                        e[s] = r
                }
                )),
                e) : Object.keys(r).reduce((function(e, s) {
                    var o = r[s];
                    return i.call(e, s) ? e[s] = t(e[s], o, n) : e[s] = o,
                    e
                }
                ), o)
            }
        }
    },
    8575: function(t, e, r) {
        "use strict";
        var n = r(52511);
        function i() {
            this.protocol = null,
            this.slashes = null,
            this.auth = null,
            this.host = null,
            this.port = null,
            this.hostname = null,
            this.hash = null,
            this.search = null,
            this.query = null,
            this.pathname = null,
            this.path = null,
            this.href = null
        }
        var s = /^([a-z0-9.+-]+:)/i
          , o = /:[0-9]*$/
          , a = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/
          , h = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"])
          , l = ["'"].concat(h)
          , u = ["%", "/", "?", ";", "#"].concat(l)
          , c = ["/", "?", "#"]
          , d = /^[+a-z0-9A-Z_-]{0,63}$/
          , f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
          , p = {
            javascript: !0,
            "javascript:": !0
        }
          , m = {
            javascript: !0,
            "javascript:": !0
        }
          , g = {
            http: !0,
            https: !0,
            ftp: !0,
            gopher: !0,
            file: !0,
            "http:": !0,
            "https:": !0,
            "ftp:": !0,
            "gopher:": !0,
            "file:": !0
        }
          , v = r(35984);
        function y(t, e, r) {
            if (t && "object" == typeof t && t instanceof i)
                return t;
            var n = new i;
            return n.parse(t, e, r),
            n
        }
        i.prototype.parse = function(t, e, r) {
            if ("string" != typeof t)
                throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
            var i = t.indexOf("?")
              , o = -1 !== i && i < t.indexOf("#") ? "?" : "#"
              , h = t.split(o);
            h[0] = h[0].replace(/\\/g, "/");
            var y = t = h.join(o);
            if (y = y.trim(),
            !r && 1 === t.split("#").length) {
                var _ = a.exec(y);
                if (_)
                    return this.path = y,
                    this.href = y,
                    this.pathname = _[1],
                    _[2] ? (this.search = _[2],
                    this.query = e ? v.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "",
                    this.query = {}),
                    this
            }
            var x = s.exec(y);
            if (x) {
                var b = (x = x[0]).toLowerCase();
                this.protocol = b,
                y = y.substr(x.length)
            }
            if (r || x || y.match(/^\/\/[^@/]+@[^@/]+/)) {
                var E = "//" === y.substr(0, 2);
                !E || x && m[x] || (y = y.substr(2),
                this.slashes = !0)
            }
            if (!m[x] && (E || x && !g[x])) {
                for (var T, w, S = -1, A = 0; A < c.length; A++)
                    -1 !== (C = y.indexOf(c[A])) && (-1 === S || C < S) && (S = C);
                for (-1 !== (w = -1 === S ? y.lastIndexOf("@") : y.lastIndexOf("@", S)) && (T = y.slice(0, w),
                y = y.slice(w + 1),
                this.auth = decodeURIComponent(T)),
                S = -1,
                A = 0; A < u.length; A++) {
                    var C;
                    -1 !== (C = y.indexOf(u[A])) && (-1 === S || C < S) && (S = C)
                }
                -1 === S && (S = y.length),
                this.host = y.slice(0, S),
                y = y.slice(S),
                this.parseHost(),
                this.hostname = this.hostname || "";
                var R = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                if (!R)
                    for (var P = this.hostname.split(/\./), I = (A = 0,
                    P.length); A < I; A++) {
                        var M = P[A];
                        if (M && !M.match(d)) {
                            for (var D = "", O = 0, B = M.length; O < B; O++)
                                M.charCodeAt(O) > 127 ? D += "x" : D += M[O];
                            if (!D.match(d)) {
                                var k = P.slice(0, A)
                                  , L = P.slice(A + 1)
                                  , N = M.match(f);
                                N && (k.push(N[1]),
                                L.unshift(N[2])),
                                L.length && (y = "/" + L.join(".") + y),
                                this.hostname = k.join(".");
                                break
                            }
                        }
                    }
                this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
                R || (this.hostname = n.toASCII(this.hostname));
                var F = this.port ? ":" + this.port : ""
                  , U = this.hostname || "";
                this.host = U + F,
                this.href += this.host,
                R && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
                "/" !== y[0] && (y = "/" + y))
            }
            if (!p[b])
                for (A = 0,
                I = l.length; A < I; A++) {
                    var G = l[A];
                    if (-1 !== y.indexOf(G)) {
                        var j = encodeURIComponent(G);
                        j === G && (j = escape(G)),
                        y = y.split(G).join(j)
                    }
                }
            var z = y.indexOf("#");
            -1 !== z && (this.hash = y.substr(z),
            y = y.slice(0, z));
            var H = y.indexOf("?");
            if (-1 !== H ? (this.search = y.substr(H),
            this.query = y.substr(H + 1),
            e && (this.query = v.parse(this.query)),
            y = y.slice(0, H)) : e && (this.search = "",
            this.query = {}),
            y && (this.pathname = y),
            g[b] && this.hostname && !this.pathname && (this.pathname = "/"),
            this.pathname || this.search) {
                F = this.pathname || "";
                var $ = this.search || "";
                this.path = F + $
            }
            return this.href = this.format(),
            this
        }
        ,
        i.prototype.format = function() {
            var t = this.auth || "";
            t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"),
            t += "@");
            var e = this.protocol || ""
              , r = this.pathname || ""
              , n = this.hash || ""
              , i = !1
              , s = "";
            this.host ? i = t + this.host : this.hostname && (i = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"),
            this.port && (i += ":" + this.port)),
            this.query && "object" == typeof this.query && Object.keys(this.query).length && (s = v.stringify(this.query));
            var o = this.search || s && "?" + s || "";
            return e && ":" !== e.substr(-1) && (e += ":"),
            this.slashes || (!e || g[e]) && !1 !== i ? (i = "//" + (i || ""),
            r && "/" !== r.charAt(0) && (r = "/" + r)) : i || (i = ""),
            n && "#" !== n.charAt(0) && (n = "#" + n),
            o && "?" !== o.charAt(0) && (o = "?" + o),
            e + i + (r = r.replace(/[?#]/g, (function(t) {
                return encodeURIComponent(t)
            }
            ))) + (o = o.replace("#", "%23")) + n
        }
        ,
        i.prototype.resolve = function(t) {
            return this.resolveObject(y(t, !1, !0)).format()
        }
        ,
        i.prototype.resolveObject = function(t) {
            if ("string" == typeof t) {
                var e = new i;
                e.parse(t, !1, !0),
                t = e
            }
            for (var r = new i, n = Object.keys(this), s = 0; s < n.length; s++) {
                var o = n[s];
                r[o] = this[o]
            }
            if (r.hash = t.hash,
            "" === t.href)
                return r.href = r.format(),
                r;
            if (t.slashes && !t.protocol) {
                for (var a = Object.keys(t), h = 0; h < a.length; h++) {
                    var l = a[h];
                    "protocol" !== l && (r[l] = t[l])
                }
                return g[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/",
                r.path = r.pathname),
                r.href = r.format(),
                r
            }
            if (t.protocol && t.protocol !== r.protocol) {
                if (!g[t.protocol]) {
                    for (var u = Object.keys(t), c = 0; c < u.length; c++) {
                        var d = u[c];
                        r[d] = t[d]
                    }
                    return r.href = r.format(),
                    r
                }
                if (r.protocol = t.protocol,
                t.host || m[t.protocol])
                    r.pathname = t.pathname;
                else {
                    for (var f = (t.pathname || "").split("/"); f.length && !(t.host = f.shift()); )
                        ;
                    t.host || (t.host = ""),
                    t.hostname || (t.hostname = ""),
                    "" !== f[0] && f.unshift(""),
                    f.length < 2 && f.unshift(""),
                    r.pathname = f.join("/")
                }
                if (r.search = t.search,
                r.query = t.query,
                r.host = t.host || "",
                r.auth = t.auth,
                r.hostname = t.hostname || t.host,
                r.port = t.port,
                r.pathname || r.search) {
                    var p = r.pathname || ""
                      , v = r.search || "";
                    r.path = p + v
                }
                return r.slashes = r.slashes || t.slashes,
                r.href = r.format(),
                r
            }
            var y = r.pathname && "/" === r.pathname.charAt(0)
              , _ = t.host || t.pathname && "/" === t.pathname.charAt(0)
              , x = _ || y || r.host && t.pathname
              , b = x
              , E = r.pathname && r.pathname.split("/") || []
              , T = (f = t.pathname && t.pathname.split("/") || [],
            r.protocol && !g[r.protocol]);
            if (T && (r.hostname = "",
            r.port = null,
            r.host && ("" === E[0] ? E[0] = r.host : E.unshift(r.host)),
            r.host = "",
            t.protocol && (t.hostname = null,
            t.port = null,
            t.host && ("" === f[0] ? f[0] = t.host : f.unshift(t.host)),
            t.host = null),
            x = x && ("" === f[0] || "" === E[0])),
            _)
                r.host = t.host || "" === t.host ? t.host : r.host,
                r.hostname = t.hostname || "" === t.hostname ? t.hostname : r.hostname,
                r.search = t.search,
                r.query = t.query,
                E = f;
            else if (f.length)
                E || (E = []),
                E.pop(),
                E = E.concat(f),
                r.search = t.search,
                r.query = t.query;
            else if (null != t.search)
                return T && (r.host = E.shift(),
                r.hostname = r.host,
                (R = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = R.shift(),
                r.hostname = R.shift(),
                r.host = r.hostname)),
                r.search = t.search,
                r.query = t.query,
                null === r.pathname && null === r.search || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")),
                r.href = r.format(),
                r;
            if (!E.length)
                return r.pathname = null,
                r.search ? r.path = "/" + r.search : r.path = null,
                r.href = r.format(),
                r;
            for (var w = E.slice(-1)[0], S = (r.host || t.host || E.length > 1) && ("." === w || ".." === w) || "" === w, A = 0, C = E.length; C >= 0; C--)
                "." === (w = E[C]) ? E.splice(C, 1) : ".." === w ? (E.splice(C, 1),
                A++) : A && (E.splice(C, 1),
                A--);
            if (!x && !b)
                for (; A--; A)
                    E.unshift("..");
            !x || "" === E[0] || E[0] && "/" === E[0].charAt(0) || E.unshift(""),
            S && "/" !== E.join("/").substr(-1) && E.push("");
            var R, P = "" === E[0] || E[0] && "/" === E[0].charAt(0);
            return T && (r.hostname = P ? "" : E.length ? E.shift() : "",
            r.host = r.hostname,
            (R = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = R.shift(),
            r.hostname = R.shift(),
            r.host = r.hostname)),
            (x = x || r.host && E.length) && !P && E.unshift(""),
            E.length > 0 ? r.pathname = E.join("/") : (r.pathname = null,
            r.path = null),
            null === r.pathname && null === r.search || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")),
            r.auth = t.auth || r.auth,
            r.slashes = r.slashes || t.slashes,
            r.href = r.format(),
            r
        }
        ,
        i.prototype.parseHost = function() {
            var t = this.host
              , e = o.exec(t);
            e && (":" !== (e = e[0]) && (this.port = e.substr(1)),
            t = t.substr(0, t.length - e.length)),
            t && (this.hostname = t)
        }
        ,
        e.Qc = y,
        e.DB = function(t, e) {
            return y(t, !1, !0).resolve(e)
        }
        ,
        e.WU = function(t) {
            return "string" == typeof t && (t = y(t)),
            t instanceof i ? t.format() : i.prototype.format.call(t)
        }
    },
    39424: function(t, e, r) {
        "use strict";
        r.d(e, {
            _: function() {
                return s
            }
        });
        var n, i = (n = function(t, e) {
            return n = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(t, e) {
                t.__proto__ = e
            }
            || function(t, e) {
                for (var r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r])
            }
            ,
            n(t, e)
        }
        ,
        function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
            function r() {
                this.constructor = t
            }
            n(t, e),
            t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype,
            new r)
        }
        ), s = function(t) {
            function e(r) {
                var n = t.call(this, r) || this
                  , i = Object.create(e.prototype);
                return Object.setPrototypeOf(n, i),
                Object.defineProperty(n, "name", {
                    configurable: !0,
                    enumerable: !1,
                    value: e.name
                }),
                n
            }
            return i(e, t),
            e
        }(Error)
    },
    8163: function(t, e, r) {
        "use strict";
        r.d(e, {
            n: function() {
                return a
            }
        });
        var n = function(t, e) {
            this.type = t,
            this.data = e
        }
          , i = r(39424)
          , s = r(38757)
          , o = {
            type: -1,
            encode: function(t) {
                var e, r, n, i;
                return t instanceof Date ? function(t) {
                    var e, r = t.sec, n = t.nsec;
                    if (r >= 0 && n >= 0 && r <= 17179869183) {
                        if (0 === n && r <= 4294967295) {
                            var i = new Uint8Array(4);
                            return (e = new DataView(i.buffer)).setUint32(0, r),
                            i
                        }
                        var o = r / 4294967296
                          , a = 4294967295 & r;
                        return i = new Uint8Array(8),
                        (e = new DataView(i.buffer)).setUint32(0, n << 2 | 3 & o),
                        e.setUint32(4, a),
                        i
                    }
                    return i = new Uint8Array(12),
                    (e = new DataView(i.buffer)).setUint32(0, n),
                    (0,
                    s.zT)(e, 4, r),
                    i
                }((n = 1e6 * ((e = t.getTime()) - 1e3 * (r = Math.floor(e / 1e3))),
                {
                    sec: r + (i = Math.floor(n / 1e9)),
                    nsec: n - 1e9 * i
                })) : null
            },
            decode: function(t) {
                var e = function(t) {
                    var e = new DataView(t.buffer,t.byteOffset,t.byteLength);
                    switch (t.byteLength) {
                    case 4:
                        return {
                            sec: e.getUint32(0),
                            nsec: 0
                        };
                    case 8:
                        var r = e.getUint32(0);
                        return {
                            sec: 4294967296 * (3 & r) + e.getUint32(4),
                            nsec: r >>> 2
                        };
                    case 12:
                        return {
                            sec: (0,
                            s.eu)(e, 4),
                            nsec: e.getUint32(0)
                        };
                    default:
                        throw new i._("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(t.length))
                    }
                }(t);
                return new Date(1e3 * e.sec + e.nsec / 1e6)
            }
        }
          , a = function() {
            function t() {
                this.builtInEncoders = [],
                this.builtInDecoders = [],
                this.encoders = [],
                this.decoders = [],
                this.register(o)
            }
            return t.prototype.register = function(t) {
                var e = t.type
                  , r = t.encode
                  , n = t.decode;
                if (e >= 0)
                    this.encoders[e] = r,
                    this.decoders[e] = n;
                else {
                    var i = 1 + e;
                    this.builtInEncoders[i] = r,
                    this.builtInDecoders[i] = n
                }
            }
            ,
            t.prototype.tryToEncode = function(t, e) {
                for (var r = 0; r < this.builtInEncoders.length; r++)
                    if (null != (i = this.builtInEncoders[r]) && null != (s = i(t, e)))
                        return new n(-1 - r,s);
                for (r = 0; r < this.encoders.length; r++) {
                    var i, s;
                    if (null != (i = this.encoders[r]) && null != (s = i(t, e)))
                        return new n(r,s)
                }
                return t instanceof n ? t : null
            }
            ,
            t.prototype.decode = function(t, e, r) {
                var i = e < 0 ? this.builtInDecoders[-1 - e] : this.decoders[e];
                return i ? i(t, e, r) : new n(e,t)
            }
            ,
            t.defaultCodec = new t,
            t
        }()
    },
    37510: function(t, e, r) {
        "use strict";
        function n(t) {
            return "".concat(t < 0 ? "-" : "", "0x").concat(Math.abs(t).toString(16).padStart(2, "0"))
        }
        r.d(e, {
            Jx: function() {
                return x
            }
        });
        var i = r(8163)
          , s = r(38757)
          , o = r(33067)
          , a = r(48797)
          , h = function() {
            function t(t, e) {
                void 0 === t && (t = 16),
                void 0 === e && (e = 16),
                this.maxKeyLength = t,
                this.maxLengthPerKey = e,
                this.hit = 0,
                this.miss = 0,
                this.caches = [];
                for (var r = 0; r < this.maxKeyLength; r++)
                    this.caches.push([])
            }
            return t.prototype.canBeCached = function(t) {
                return t > 0 && t <= this.maxKeyLength
            }
            ,
            t.prototype.find = function(t, e, r) {
                t: for (var n = 0, i = this.caches[r - 1]; n < i.length; n++) {
                    for (var s = i[n], o = s.bytes, a = 0; a < r; a++)
                        if (o[a] !== t[e + a])
                            continue t;
                    return s.str
                }
                return null
            }
            ,
            t.prototype.store = function(t, e) {
                var r = this.caches[t.length - 1]
                  , n = {
                    bytes: t,
                    str: e
                };
                r.length >= this.maxLengthPerKey ? r[Math.random() * r.length | 0] = n : r.push(n)
            }
            ,
            t.prototype.decode = function(t, e, r) {
                var n = this.find(t, e, r);
                if (null != n)
                    return this.hit++,
                    n;
                this.miss++;
                var i = (0,
                o.zV)(t, e, r)
                  , s = Uint8Array.prototype.slice.call(t, e, e + r);
                return this.store(s, i),
                i
            }
            ,
            t
        }()
          , l = r(39424)
          , u = function(t, e) {
            var r, n, i, s, o = {
                label: 0,
                sent: function() {
                    if (1 & i[0])
                        throw i[1];
                    return i[1]
                },
                trys: [],
                ops: []
            };
            return s = {
                next: a(0),
                throw: a(1),
                return: a(2)
            },
            "function" == typeof Symbol && (s[Symbol.iterator] = function() {
                return this
            }
            ),
            s;
            function a(s) {
                return function(a) {
                    return function(s) {
                        if (r)
                            throw new TypeError("Generator is already executing.");
                        for (; o; )
                            try {
                                if (r = 1,
                                n && (i = 2 & s[0] ? n.return : s[0] ? n.throw || ((i = n.return) && i.call(n),
                                0) : n.next) && !(i = i.call(n, s[1])).done)
                                    return i;
                                switch (n = 0,
                                i && (s = [2 & s[0], i.value]),
                                s[0]) {
                                case 0:
                                case 1:
                                    i = s;
                                    break;
                                case 4:
                                    return o.label++,
                                    {
                                        value: s[1],
                                        done: !1
                                    };
                                case 5:
                                    o.label++,
                                    n = s[1],
                                    s = [0];
                                    continue;
                                case 7:
                                    s = o.ops.pop(),
                                    o.trys.pop();
                                    continue;
                                default:
                                    if (!((i = (i = o.trys).length > 0 && i[i.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                        o = 0;
                                        continue
                                    }
                                    if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {
                                        o.label = s[1];
                                        break
                                    }
                                    if (6 === s[0] && o.label < i[1]) {
                                        o.label = i[1],
                                        i = s;
                                        break
                                    }
                                    if (i && o.label < i[2]) {
                                        o.label = i[2],
                                        o.ops.push(s);
                                        break
                                    }
                                    i[2] && o.ops.pop(),
                                    o.trys.pop();
                                    continue
                                }
                                s = e.call(t, o)
                            } catch (t) {
                                s = [6, t],
                                n = 0
                            } finally {
                                r = i = 0
                            }
                        if (5 & s[0])
                            throw s[1];
                        return {
                            value: s[0] ? s[1] : void 0,
                            done: !0
                        }
                    }([s, a])
                }
            }
        }
          , c = function(t) {
            if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
            var e, r = t[Symbol.asyncIterator];
            return r ? r.call(t) : (t = "function" == typeof __values ? __values(t) : t[Symbol.iterator](),
            e = {},
            n("next"),
            n("throw"),
            n("return"),
            e[Symbol.asyncIterator] = function() {
                return this
            }
            ,
            e);
            function n(r) {
                e[r] = t[r] && function(e) {
                    return new Promise((function(n, i) {
                        !function(t, e, r, n) {
                            Promise.resolve(n).then((function(e) {
                                t({
                                    value: e,
                                    done: r
                                })
                            }
                            ), e)
                        }(n, i, (e = t[r](e)).done, e.value)
                    }
                    ))
                }
            }
        }
          , d = function(t) {
            return this instanceof d ? (this.v = t,
            this) : new d(t)
        }
          , f = new DataView(new ArrayBuffer(0))
          , p = new Uint8Array(f.buffer)
          , m = function() {
            try {
                f.getInt8(0)
            } catch (t) {
                return t.constructor
            }
            throw new Error("never reached")
        }()
          , g = new m("Insufficient data")
          , v = new h
          , y = function() {
            function t(t, e, r, n, o, a, h, l) {
                void 0 === t && (t = i.n.defaultCodec),
                void 0 === e && (e = void 0),
                void 0 === r && (r = s.x5),
                void 0 === n && (n = s.x5),
                void 0 === o && (o = s.x5),
                void 0 === a && (a = s.x5),
                void 0 === h && (h = s.x5),
                void 0 === l && (l = v),
                this.extensionCodec = t,
                this.context = e,
                this.maxStrLength = r,
                this.maxBinLength = n,
                this.maxArrayLength = o,
                this.maxMapLength = a,
                this.maxExtLength = h,
                this.keyDecoder = l,
                this.totalPos = 0,
                this.pos = 0,
                this.view = f,
                this.bytes = p,
                this.headByte = -1,
                this.stack = []
            }
            return t.prototype.reinitializeState = function() {
                this.totalPos = 0,
                this.headByte = -1,
                this.stack.length = 0
            }
            ,
            t.prototype.setBuffer = function(t) {
                this.bytes = (0,
                a.z)(t),
                this.view = (0,
                a.V)(this.bytes),
                this.pos = 0
            }
            ,
            t.prototype.appendBuffer = function(t) {
                if (-1 !== this.headByte || this.hasRemaining(1)) {
                    var e = this.bytes.subarray(this.pos)
                      , r = (0,
                    a.z)(t)
                      , n = new Uint8Array(e.length + r.length);
                    n.set(e),
                    n.set(r, e.length),
                    this.setBuffer(n)
                } else
                    this.setBuffer(t)
            }
            ,
            t.prototype.hasRemaining = function(t) {
                return this.view.byteLength - this.pos >= t
            }
            ,
            t.prototype.createExtraByteError = function(t) {
                var e = this.view
                  , r = this.pos;
                return new RangeError("Extra ".concat(e.byteLength - r, " of ").concat(e.byteLength, " byte(s) found at buffer[").concat(t, "]"))
            }
            ,
            t.prototype.decode = function(t) {
                this.reinitializeState(),
                this.setBuffer(t);
                var e = this.doDecodeSync();
                if (this.hasRemaining(1))
                    throw this.createExtraByteError(this.pos);
                return e
            }
            ,
            t.prototype.decodeMulti = function(t) {
                return u(this, (function(e) {
                    switch (e.label) {
                    case 0:
                        this.reinitializeState(),
                        this.setBuffer(t),
                        e.label = 1;
                    case 1:
                        return this.hasRemaining(1) ? [4, this.doDecodeSync()] : [3, 3];
                    case 2:
                        return e.sent(),
                        [3, 1];
                    case 3:
                        return [2]
                    }
                }
                ))
            }
            ,
            t.prototype.decodeAsync = function(t) {
                var e, r, i, s, o, a, h, l;
                return o = this,
                a = void 0,
                l = function() {
                    var o, a, h, l, d, f, p, g;
                    return u(this, (function(u) {
                        switch (u.label) {
                        case 0:
                            o = !1,
                            u.label = 1;
                        case 1:
                            u.trys.push([1, 6, 7, 12]),
                            e = c(t),
                            u.label = 2;
                        case 2:
                            return [4, e.next()];
                        case 3:
                            if ((r = u.sent()).done)
                                return [3, 5];
                            if (h = r.value,
                            o)
                                throw this.createExtraByteError(this.totalPos);
                            this.appendBuffer(h);
                            try {
                                a = this.doDecodeSync(),
                                o = !0
                            } catch (t) {
                                if (!(t instanceof m))
                                    throw t
                            }
                            this.totalPos += this.pos,
                            u.label = 4;
                        case 4:
                            return [3, 2];
                        case 5:
                            return [3, 12];
                        case 6:
                            return l = u.sent(),
                            i = {
                                error: l
                            },
                            [3, 12];
                        case 7:
                            return u.trys.push([7, , 10, 11]),
                            r && !r.done && (s = e.return) ? [4, s.call(e)] : [3, 9];
                        case 8:
                            u.sent(),
                            u.label = 9;
                        case 9:
                            return [3, 11];
                        case 10:
                            if (i)
                                throw i.error;
                            return [7];
                        case 11:
                            return [7];
                        case 12:
                            if (o) {
                                if (this.hasRemaining(1))
                                    throw this.createExtraByteError(this.totalPos);
                                return [2, a]
                            }
                            throw f = (d = this).headByte,
                            p = d.pos,
                            g = d.totalPos,
                            new RangeError("Insufficient data in parsing ".concat(n(f), " at ").concat(g, " (").concat(p, " in the current buffer)"))
                        }
                    }
                    ))
                }
                ,
                new ((h = void 0) || (h = Promise))((function(t, e) {
                    function r(t) {
                        try {
                            i(l.next(t))
                        } catch (t) {
                            e(t)
                        }
                    }
                    function n(t) {
                        try {
                            i(l.throw(t))
                        } catch (t) {
                            e(t)
                        }
                    }
                    function i(e) {
                        var i;
                        e.done ? t(e.value) : (i = e.value,
                        i instanceof h ? i : new h((function(t) {
                            t(i)
                        }
                        ))).then(r, n)
                    }
                    i((l = l.apply(o, a || [])).next())
                }
                ))
            }
            ,
            t.prototype.decodeArrayStream = function(t) {
                return this.decodeMultiAsync(t, !0)
            }
            ,
            t.prototype.decodeStream = function(t) {
                return this.decodeMultiAsync(t, !1)
            }
            ,
            t.prototype.decodeMultiAsync = function(t, e) {
                return function(t, e, r) {
                    if (!Symbol.asyncIterator)
                        throw new TypeError("Symbol.asyncIterator is not defined.");
                    var n, i = r.apply(t, e || []), s = [];
                    return n = {},
                    o("next"),
                    o("throw"),
                    o("return"),
                    n[Symbol.asyncIterator] = function() {
                        return this
                    }
                    ,
                    n;
                    function o(t) {
                        i[t] && (n[t] = function(e) {
                            return new Promise((function(r, n) {
                                s.push([t, e, r, n]) > 1 || a(t, e)
                            }
                            ))
                        }
                        )
                    }
                    function a(t, e) {
                        try {
                            (r = i[t](e)).value instanceof d ? Promise.resolve(r.value.v).then(h, l) : u(s[0][2], r)
                        } catch (t) {
                            u(s[0][3], t)
                        }
                        var r
                    }
                    function h(t) {
                        a("next", t)
                    }
                    function l(t) {
                        a("throw", t)
                    }
                    function u(t, e) {
                        t(e),
                        s.shift(),
                        s.length && a(s[0][0], s[0][1])
                    }
                }(this, arguments, (function() {
                    var r, n, i, s, o, a, h, l, f;
                    return u(this, (function(u) {
                        switch (u.label) {
                        case 0:
                            r = e,
                            n = -1,
                            u.label = 1;
                        case 1:
                            u.trys.push([1, 13, 14, 19]),
                            i = c(t),
                            u.label = 2;
                        case 2:
                            return [4, d(i.next())];
                        case 3:
                            if ((s = u.sent()).done)
                                return [3, 12];
                            if (o = s.value,
                            e && 0 === n)
                                throw this.createExtraByteError(this.totalPos);
                            this.appendBuffer(o),
                            r && (n = this.readArraySize(),
                            r = !1,
                            this.complete()),
                            u.label = 4;
                        case 4:
                            u.trys.push([4, 9, , 10]),
                            u.label = 5;
                        case 5:
                            return [4, d(this.doDecodeSync())];
                        case 6:
                            return [4, u.sent()];
                        case 7:
                            return u.sent(),
                            0 == --n ? [3, 8] : [3, 5];
                        case 8:
                            return [3, 10];
                        case 9:
                            if (!((a = u.sent())instanceof m))
                                throw a;
                            return [3, 10];
                        case 10:
                            this.totalPos += this.pos,
                            u.label = 11;
                        case 11:
                            return [3, 2];
                        case 12:
                            return [3, 19];
                        case 13:
                            return h = u.sent(),
                            l = {
                                error: h
                            },
                            [3, 19];
                        case 14:
                            return u.trys.push([14, , 17, 18]),
                            s && !s.done && (f = i.return) ? [4, d(f.call(i))] : [3, 16];
                        case 15:
                            u.sent(),
                            u.label = 16;
                        case 16:
                            return [3, 18];
                        case 17:
                            if (l)
                                throw l.error;
                            return [7];
                        case 18:
                            return [7];
                        case 19:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            t.prototype.doDecodeSync = function() {
                t: for (; ; ) {
                    var t = this.readHeadByte()
                      , e = void 0;
                    if (t >= 224)
                        e = t - 256;
                    else if (t < 192)
                        if (t < 128)
                            e = t;
                        else if (t < 144) {
                            if (0 != (i = t - 128)) {
                                this.pushMapState(i),
                                this.complete();
                                continue t
                            }
                            e = {}
                        } else if (t < 160) {
                            if (0 != (i = t - 144)) {
                                this.pushArrayState(i),
                                this.complete();
                                continue t
                            }
                            e = []
                        } else {
                            var r = t - 160;
                            e = this.decodeUtf8String(r, 0)
                        }
                    else if (192 === t)
                        e = null;
                    else if (194 === t)
                        e = !1;
                    else if (195 === t)
                        e = !0;
                    else if (202 === t)
                        e = this.readF32();
                    else if (203 === t)
                        e = this.readF64();
                    else if (204 === t)
                        e = this.readU8();
                    else if (205 === t)
                        e = this.readU16();
                    else if (206 === t)
                        e = this.readU32();
                    else if (207 === t)
                        e = this.readU64();
                    else if (208 === t)
                        e = this.readI8();
                    else if (209 === t)
                        e = this.readI16();
                    else if (210 === t)
                        e = this.readI32();
                    else if (211 === t)
                        e = this.readI64();
                    else if (217 === t)
                        r = this.lookU8(),
                        e = this.decodeUtf8String(r, 1);
                    else if (218 === t)
                        r = this.lookU16(),
                        e = this.decodeUtf8String(r, 2);
                    else if (219 === t)
                        r = this.lookU32(),
                        e = this.decodeUtf8String(r, 4);
                    else if (220 === t) {
                        if (0 !== (i = this.readU16())) {
                            this.pushArrayState(i),
                            this.complete();
                            continue t
                        }
                        e = []
                    } else if (221 === t) {
                        if (0 !== (i = this.readU32())) {
                            this.pushArrayState(i),
                            this.complete();
                            continue t
                        }
                        e = []
                    } else if (222 === t) {
                        if (0 !== (i = this.readU16())) {
                            this.pushMapState(i),
                            this.complete();
                            continue t
                        }
                        e = {}
                    } else if (223 === t) {
                        if (0 !== (i = this.readU32())) {
                            this.pushMapState(i),
                            this.complete();
                            continue t
                        }
                        e = {}
                    } else if (196 === t) {
                        var i = this.lookU8();
                        e = this.decodeBinary(i, 1)
                    } else if (197 === t)
                        i = this.lookU16(),
                        e = this.decodeBinary(i, 2);
                    else if (198 === t)
                        i = this.lookU32(),
                        e = this.decodeBinary(i, 4);
                    else if (212 === t)
                        e = this.decodeExtension(1, 0);
                    else if (213 === t)
                        e = this.decodeExtension(2, 0);
                    else if (214 === t)
                        e = this.decodeExtension(4, 0);
                    else if (215 === t)
                        e = this.decodeExtension(8, 0);
                    else if (216 === t)
                        e = this.decodeExtension(16, 0);
                    else if (199 === t)
                        i = this.lookU8(),
                        e = this.decodeExtension(i, 1);
                    else if (200 === t)
                        i = this.lookU16(),
                        e = this.decodeExtension(i, 2);
                    else {
                        if (201 !== t)
                            throw new l._("Unrecognized type byte: ".concat(n(t)));
                        i = this.lookU32(),
                        e = this.decodeExtension(i, 4)
                    }
                    this.complete();
                    for (var s = this.stack; s.length > 0; ) {
                        var o = s[s.length - 1];
                        if (0 === o.type) {
                            if (o.array[o.position] = e,
                            o.position++,
                            o.position !== o.size)
                                continue t;
                            s.pop(),
                            e = o.array
                        } else {
                            if (1 === o.type) {
                                if (void 0,
                                "string" != (a = typeof e) && "number" !== a)
                                    throw new l._("The type of key must be string or number but " + typeof e);
                                if ("__proto__" === e)
                                    throw new l._("The key __proto__ is not allowed");
                                o.key = e,
                                o.type = 2;
                                continue t
                            }
                            if (o.map[o.key] = e,
                            o.readCount++,
                            o.readCount !== o.size) {
                                o.key = null,
                                o.type = 1;
                                continue t
                            }
                            s.pop(),
                            e = o.map
                        }
                    }
                    return e
                }
                var a
            }
            ,
            t.prototype.readHeadByte = function() {
                return -1 === this.headByte && (this.headByte = this.readU8()),
                this.headByte
            }
            ,
            t.prototype.complete = function() {
                this.headByte = -1
            }
            ,
            t.prototype.readArraySize = function() {
                var t = this.readHeadByte();
                switch (t) {
                case 220:
                    return this.readU16();
                case 221:
                    return this.readU32();
                default:
                    if (t < 160)
                        return t - 144;
                    throw new l._("Unrecognized array type byte: ".concat(n(t)))
                }
            }
            ,
            t.prototype.pushMapState = function(t) {
                if (t > this.maxMapLength)
                    throw new l._("Max length exceeded: map length (".concat(t, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
                this.stack.push({
                    type: 1,
                    size: t,
                    key: null,
                    readCount: 0,
                    map: {}
                })
            }
            ,
            t.prototype.pushArrayState = function(t) {
                if (t > this.maxArrayLength)
                    throw new l._("Max length exceeded: array length (".concat(t, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
                this.stack.push({
                    type: 0,
                    size: t,
                    array: new Array(t),
                    position: 0
                })
            }
            ,
            t.prototype.decodeUtf8String = function(t, e) {
                var r;
                if (t > this.maxStrLength)
                    throw new l._("Max length exceeded: UTF-8 byte length (".concat(t, ") > maxStrLength (").concat(this.maxStrLength, ")"));
                if (this.bytes.byteLength < this.pos + e + t)
                    throw g;
                var n, i = this.pos + e;
                return n = this.stateIsMapKey() && (null === (r = this.keyDecoder) || void 0 === r ? void 0 : r.canBeCached(t)) ? this.keyDecoder.decode(this.bytes, i, t) : t > o.hJ ? (0,
                o.nI)(this.bytes, i, t) : (0,
                o.zV)(this.bytes, i, t),
                this.pos += e + t,
                n
            }
            ,
            t.prototype.stateIsMapKey = function() {
                return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type
            }
            ,
            t.prototype.decodeBinary = function(t, e) {
                if (t > this.maxBinLength)
                    throw new l._("Max length exceeded: bin length (".concat(t, ") > maxBinLength (").concat(this.maxBinLength, ")"));
                if (!this.hasRemaining(t + e))
                    throw g;
                var r = this.pos + e
                  , n = this.bytes.subarray(r, r + t);
                return this.pos += e + t,
                n
            }
            ,
            t.prototype.decodeExtension = function(t, e) {
                if (t > this.maxExtLength)
                    throw new l._("Max length exceeded: ext length (".concat(t, ") > maxExtLength (").concat(this.maxExtLength, ")"));
                var r = this.view.getInt8(this.pos + e)
                  , n = this.decodeBinary(t, e + 1);
                return this.extensionCodec.decode(n, r, this.context)
            }
            ,
            t.prototype.lookU8 = function() {
                return this.view.getUint8(this.pos)
            }
            ,
            t.prototype.lookU16 = function() {
                return this.view.getUint16(this.pos)
            }
            ,
            t.prototype.lookU32 = function() {
                return this.view.getUint32(this.pos)
            }
            ,
            t.prototype.readU8 = function() {
                var t = this.view.getUint8(this.pos);
                return this.pos++,
                t
            }
            ,
            t.prototype.readI8 = function() {
                var t = this.view.getInt8(this.pos);
                return this.pos++,
                t
            }
            ,
            t.prototype.readU16 = function() {
                var t = this.view.getUint16(this.pos);
                return this.pos += 2,
                t
            }
            ,
            t.prototype.readI16 = function() {
                var t = this.view.getInt16(this.pos);
                return this.pos += 2,
                t
            }
            ,
            t.prototype.readU32 = function() {
                var t = this.view.getUint32(this.pos);
                return this.pos += 4,
                t
            }
            ,
            t.prototype.readI32 = function() {
                var t = this.view.getInt32(this.pos);
                return this.pos += 4,
                t
            }
            ,
            t.prototype.readU64 = function() {
                var t = (0,
                s.Lz)(this.view, this.pos);
                return this.pos += 8,
                t
            }
            ,
            t.prototype.readI64 = function() {
                var t = (0,
                s.eu)(this.view, this.pos);
                return this.pos += 8,
                t
            }
            ,
            t.prototype.readF32 = function() {
                var t = this.view.getFloat32(this.pos);
                return this.pos += 4,
                t
            }
            ,
            t.prototype.readF64 = function() {
                var t = this.view.getFloat64(this.pos);
                return this.pos += 8,
                t
            }
            ,
            t
        }()
          , _ = {};
        function x(t, e) {
            return void 0 === e && (e = _),
            new y(e.extensionCodec,e.context,e.maxStrLength,e.maxBinLength,e.maxArrayLength,e.maxMapLength,e.maxExtLength).decode(t)
        }
    },
    57484: function(t, e, r) {
        "use strict";
        r.d(e, {
            c: function() {
                return l
            }
        });
        var n = r(33067)
          , i = r(8163)
          , s = r(38757)
          , o = r(48797)
          , a = function() {
            function t(t, e, r, n, s, o, a, h) {
                void 0 === t && (t = i.n.defaultCodec),
                void 0 === e && (e = void 0),
                void 0 === r && (r = 100),
                void 0 === n && (n = 2048),
                void 0 === s && (s = !1),
                void 0 === o && (o = !1),
                void 0 === a && (a = !1),
                void 0 === h && (h = !1),
                this.extensionCodec = t,
                this.context = e,
                this.maxDepth = r,
                this.initialBufferSize = n,
                this.sortKeys = s,
                this.forceFloat32 = o,
                this.ignoreUndefined = a,
                this.forceIntegerToFloat = h,
                this.pos = 0,
                this.view = new DataView(new ArrayBuffer(this.initialBufferSize)),
                this.bytes = new Uint8Array(this.view.buffer)
            }
            return t.prototype.reinitializeState = function() {
                this.pos = 0
            }
            ,
            t.prototype.encodeSharedRef = function(t) {
                return this.reinitializeState(),
                this.doEncode(t, 1),
                this.bytes.subarray(0, this.pos)
            }
            ,
            t.prototype.encode = function(t) {
                return this.reinitializeState(),
                this.doEncode(t, 1),
                this.bytes.slice(0, this.pos)
            }
            ,
            t.prototype.doEncode = function(t, e) {
                if (e > this.maxDepth)
                    throw new Error("Too deep objects in depth ".concat(e));
                null == t ? this.encodeNil() : "boolean" == typeof t ? this.encodeBoolean(t) : "number" == typeof t ? this.encodeNumber(t) : "string" == typeof t ? this.encodeString(t) : this.encodeObject(t, e)
            }
            ,
            t.prototype.ensureBufferSizeToWrite = function(t) {
                var e = this.pos + t;
                this.view.byteLength < e && this.resizeBuffer(2 * e)
            }
            ,
            t.prototype.resizeBuffer = function(t) {
                var e = new ArrayBuffer(t)
                  , r = new Uint8Array(e)
                  , n = new DataView(e);
                r.set(this.bytes),
                this.view = n,
                this.bytes = r
            }
            ,
            t.prototype.encodeNil = function() {
                this.writeU8(192)
            }
            ,
            t.prototype.encodeBoolean = function(t) {
                !1 === t ? this.writeU8(194) : this.writeU8(195)
            }
            ,
            t.prototype.encodeNumber = function(t) {
                Number.isSafeInteger(t) && !this.forceIntegerToFloat ? t >= 0 ? t < 128 ? this.writeU8(t) : t < 256 ? (this.writeU8(204),
                this.writeU8(t)) : t < 65536 ? (this.writeU8(205),
                this.writeU16(t)) : t < 4294967296 ? (this.writeU8(206),
                this.writeU32(t)) : (this.writeU8(207),
                this.writeU64(t)) : t >= -32 ? this.writeU8(224 | t + 32) : t >= -128 ? (this.writeU8(208),
                this.writeI8(t)) : t >= -32768 ? (this.writeU8(209),
                this.writeI16(t)) : t >= -2147483648 ? (this.writeU8(210),
                this.writeI32(t)) : (this.writeU8(211),
                this.writeI64(t)) : this.forceFloat32 ? (this.writeU8(202),
                this.writeF32(t)) : (this.writeU8(203),
                this.writeF64(t))
            }
            ,
            t.prototype.writeStringHeader = function(t) {
                if (t < 32)
                    this.writeU8(160 + t);
                else if (t < 256)
                    this.writeU8(217),
                    this.writeU8(t);
                else if (t < 65536)
                    this.writeU8(218),
                    this.writeU16(t);
                else {
                    if (!(t < 4294967296))
                        throw new Error("Too long string: ".concat(t, " bytes in UTF-8"));
                    this.writeU8(219),
                    this.writeU32(t)
                }
            }
            ,
            t.prototype.encodeString = function(t) {
                if (t.length > n.Oh) {
                    var e = (0,
                    n.ZR)(t);
                    this.ensureBufferSizeToWrite(5 + e),
                    this.writeStringHeader(e),
                    (0,
                    n.pL)(t, this.bytes, this.pos),
                    this.pos += e
                } else
                    e = (0,
                    n.ZR)(t),
                    this.ensureBufferSizeToWrite(5 + e),
                    this.writeStringHeader(e),
                    (0,
                    n.dg)(t, this.bytes, this.pos),
                    this.pos += e
            }
            ,
            t.prototype.encodeObject = function(t, e) {
                var r = this.extensionCodec.tryToEncode(t, this.context);
                if (null != r)
                    this.encodeExtension(r);
                else if (Array.isArray(t))
                    this.encodeArray(t, e);
                else if (ArrayBuffer.isView(t))
                    this.encodeBinary(t);
                else {
                    if ("object" != typeof t)
                        throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(t)));
                    this.encodeMap(t, e)
                }
            }
            ,
            t.prototype.encodeBinary = function(t) {
                var e = t.byteLength;
                if (e < 256)
                    this.writeU8(196),
                    this.writeU8(e);
                else if (e < 65536)
                    this.writeU8(197),
                    this.writeU16(e);
                else {
                    if (!(e < 4294967296))
                        throw new Error("Too large binary: ".concat(e));
                    this.writeU8(198),
                    this.writeU32(e)
                }
                var r = (0,
                o.z)(t);
                this.writeU8a(r)
            }
            ,
            t.prototype.encodeArray = function(t, e) {
                var r = t.length;
                if (r < 16)
                    this.writeU8(144 + r);
                else if (r < 65536)
                    this.writeU8(220),
                    this.writeU16(r);
                else {
                    if (!(r < 4294967296))
                        throw new Error("Too large array: ".concat(r));
                    this.writeU8(221),
                    this.writeU32(r)
                }
                for (var n = 0, i = t; n < i.length; n++) {
                    var s = i[n];
                    this.doEncode(s, e + 1)
                }
            }
            ,
            t.prototype.countWithoutUndefined = function(t, e) {
                for (var r = 0, n = 0, i = e; n < i.length; n++)
                    void 0 !== t[i[n]] && r++;
                return r
            }
            ,
            t.prototype.encodeMap = function(t, e) {
                var r = Object.keys(t);
                this.sortKeys && r.sort();
                var n = this.ignoreUndefined ? this.countWithoutUndefined(t, r) : r.length;
                if (n < 16)
                    this.writeU8(128 + n);
                else if (n < 65536)
                    this.writeU8(222),
                    this.writeU16(n);
                else {
                    if (!(n < 4294967296))
                        throw new Error("Too large map object: ".concat(n));
                    this.writeU8(223),
                    this.writeU32(n)
                }
                for (var i = 0, s = r; i < s.length; i++) {
                    var o = s[i]
                      , a = t[o];
                    this.ignoreUndefined && void 0 === a || (this.encodeString(o),
                    this.doEncode(a, e + 1))
                }
            }
            ,
            t.prototype.encodeExtension = function(t) {
                var e = t.data.length;
                if (1 === e)
                    this.writeU8(212);
                else if (2 === e)
                    this.writeU8(213);
                else if (4 === e)
                    this.writeU8(214);
                else if (8 === e)
                    this.writeU8(215);
                else if (16 === e)
                    this.writeU8(216);
                else if (e < 256)
                    this.writeU8(199),
                    this.writeU8(e);
                else if (e < 65536)
                    this.writeU8(200),
                    this.writeU16(e);
                else {
                    if (!(e < 4294967296))
                        throw new Error("Too large extension object: ".concat(e));
                    this.writeU8(201),
                    this.writeU32(e)
                }
                this.writeI8(t.type),
                this.writeU8a(t.data)
            }
            ,
            t.prototype.writeU8 = function(t) {
                this.ensureBufferSizeToWrite(1),
                this.view.setUint8(this.pos, t),
                this.pos++
            }
            ,
            t.prototype.writeU8a = function(t) {
                var e = t.length;
                this.ensureBufferSizeToWrite(e),
                this.bytes.set(t, this.pos),
                this.pos += e
            }
            ,
            t.prototype.writeI8 = function(t) {
                this.ensureBufferSizeToWrite(1),
                this.view.setInt8(this.pos, t),
                this.pos++
            }
            ,
            t.prototype.writeU16 = function(t) {
                this.ensureBufferSizeToWrite(2),
                this.view.setUint16(this.pos, t),
                this.pos += 2
            }
            ,
            t.prototype.writeI16 = function(t) {
                this.ensureBufferSizeToWrite(2),
                this.view.setInt16(this.pos, t),
                this.pos += 2
            }
            ,
            t.prototype.writeU32 = function(t) {
                this.ensureBufferSizeToWrite(4),
                this.view.setUint32(this.pos, t),
                this.pos += 4
            }
            ,
            t.prototype.writeI32 = function(t) {
                this.ensureBufferSizeToWrite(4),
                this.view.setInt32(this.pos, t),
                this.pos += 4
            }
            ,
            t.prototype.writeF32 = function(t) {
                this.ensureBufferSizeToWrite(4),
                this.view.setFloat32(this.pos, t),
                this.pos += 4
            }
            ,
            t.prototype.writeF64 = function(t) {
                this.ensureBufferSizeToWrite(8),
                this.view.setFloat64(this.pos, t),
                this.pos += 8
            }
            ,
            t.prototype.writeU64 = function(t) {
                this.ensureBufferSizeToWrite(8),
                (0,
                s.$t)(this.view, this.pos, t),
                this.pos += 8
            }
            ,
            t.prototype.writeI64 = function(t) {
                this.ensureBufferSizeToWrite(8),
                (0,
                s.zT)(this.view, this.pos, t),
                this.pos += 8
            }
            ,
            t
        }()
          , h = {};
        function l(t, e) {
            return void 0 === e && (e = h),
            new a(e.extensionCodec,e.context,e.maxDepth,e.initialBufferSize,e.sortKeys,e.forceFloat32,e.ignoreUndefined,e.forceIntegerToFloat).encodeSharedRef(t)
        }
    },
    38757: function(t, e, r) {
        "use strict";
        r.d(e, {
            $t: function() {
                return i
            },
            Lz: function() {
                return a
            },
            eu: function() {
                return o
            },
            x5: function() {
                return n
            },
            zT: function() {
                return s
            }
        });
        var n = 4294967295;
        function i(t, e, r) {
            var n = r / 4294967296
              , i = r;
            t.setUint32(e, n),
            t.setUint32(e + 4, i)
        }
        function s(t, e, r) {
            var n = Math.floor(r / 4294967296)
              , i = r;
            t.setUint32(e, n),
            t.setUint32(e + 4, i)
        }
        function o(t, e) {
            return 4294967296 * t.getInt32(e) + t.getUint32(e + 4)
        }
        function a(t, e) {
            return 4294967296 * t.getUint32(e) + t.getUint32(e + 4)
        }
    },
    48797: function(t, e, r) {
        "use strict";
        function n(t) {
            return t instanceof Uint8Array ? t : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer,t.byteOffset,t.byteLength) : t instanceof ArrayBuffer ? new Uint8Array(t) : Uint8Array.from(t)
        }
        function i(t) {
            if (t instanceof ArrayBuffer)
                return new DataView(t);
            var e = n(t);
            return new DataView(e.buffer,e.byteOffset,e.byteLength)
        }
        r.d(e, {
            V: function() {
                return i
            },
            z: function() {
                return n
            }
        })
    },
    33067: function(t, e, r) {
        "use strict";
        r.d(e, {
            Oh: function() {
                return c
            },
            ZR: function() {
                return h
            },
            dg: function() {
                return l
            },
            hJ: function() {
                return g
            },
            nI: function() {
                return v
            },
            pL: function() {
                return d
            },
            zV: function() {
                return p
            }
        });
        var n, i, s, o = r(38757), a = ("undefined" == typeof process || "never" !== (null === (n = null === process || void 0 === process ? void 0 : process.env) || void 0 === n ? void 0 : n.TEXT_ENCODING)) && "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder;
        function h(t) {
            for (var e = t.length, r = 0, n = 0; n < e; ) {
                var i = t.charCodeAt(n++);
                if (0 != (4294967168 & i))
                    if (0 == (4294965248 & i))
                        r += 2;
                    else {
                        if (i >= 55296 && i <= 56319 && n < e) {
                            var s = t.charCodeAt(n);
                            56320 == (64512 & s) && (++n,
                            i = ((1023 & i) << 10) + (1023 & s) + 65536)
                        }
                        r += 0 == (4294901760 & i) ? 3 : 4
                    }
                else
                    r++
            }
            return r
        }
        function l(t, e, r) {
            for (var n = t.length, i = r, s = 0; s < n; ) {
                var o = t.charCodeAt(s++);
                if (0 != (4294967168 & o)) {
                    if (0 == (4294965248 & o))
                        e[i++] = o >> 6 & 31 | 192;
                    else {
                        if (o >= 55296 && o <= 56319 && s < n) {
                            var a = t.charCodeAt(s);
                            56320 == (64512 & a) && (++s,
                            o = ((1023 & o) << 10) + (1023 & a) + 65536)
                        }
                        0 == (4294901760 & o) ? (e[i++] = o >> 12 & 15 | 224,
                        e[i++] = o >> 6 & 63 | 128) : (e[i++] = o >> 18 & 7 | 240,
                        e[i++] = o >> 12 & 63 | 128,
                        e[i++] = o >> 6 & 63 | 128)
                    }
                    e[i++] = 63 & o | 128
                } else
                    e[i++] = o
            }
        }
        var u = a ? new TextEncoder : void 0
          , c = a ? "undefined" != typeof process && "force" !== (null === (i = null === process || void 0 === process ? void 0 : process.env) || void 0 === i ? void 0 : i.TEXT_ENCODING) ? 200 : 0 : o.x5
          , d = (null == u ? void 0 : u.encodeInto) ? function(t, e, r) {
            u.encodeInto(t, e.subarray(r))
        }
        : function(t, e, r) {
            e.set(u.encode(t), r)
        }
          , f = 4096;
        function p(t, e, r) {
            for (var n = e, i = n + r, s = [], o = ""; n < i; ) {
                var a = t[n++];
                if (0 == (128 & a))
                    s.push(a);
                else if (192 == (224 & a)) {
                    var h = 63 & t[n++];
                    s.push((31 & a) << 6 | h)
                } else if (224 == (240 & a)) {
                    h = 63 & t[n++];
                    var l = 63 & t[n++];
                    s.push((31 & a) << 12 | h << 6 | l)
                } else if (240 == (248 & a)) {
                    var u = (7 & a) << 18 | (h = 63 & t[n++]) << 12 | (l = 63 & t[n++]) << 6 | 63 & t[n++];
                    u > 65535 && (u -= 65536,
                    s.push(u >>> 10 & 1023 | 55296),
                    u = 56320 | 1023 & u),
                    s.push(u)
                } else
                    s.push(a);
                s.length >= f && (o += String.fromCharCode.apply(String, s),
                s.length = 0)
            }
            return s.length > 0 && (o += String.fromCharCode.apply(String, s)),
            o
        }
        var m = a ? new TextDecoder : null
          , g = a ? "undefined" != typeof process && "force" !== (null === (s = null === process || void 0 === process ? void 0 : process.env) || void 0 === s ? void 0 : s.TEXT_DECODER) ? 200 : 0 : o.x5;
        function v(t, e, r) {
            var n = t.subarray(e, e + r);
            return m.decode(n)
        }
    },
    33813: function(t, e, r) {
        "use strict";
        r.d(e, {
            iw: function() {
                return g
            },
            T$: function() {
                return a
            },
            VL: function() {
                return Pe
            },
            a$: function() {
                return Ie
            },
            JZ: function() {
                return Ue
            },
            Ie: function() {
                return Pr
            },
            lW: function() {
                return De
            },
            qm: function() {
                return Ae
            },
            yl: function() {
                return v
            },
            Cd: function() {
                return We
            },
            Il: function() {
                return It
            },
            ZX: function() {
                return ze
            },
            lg: function() {
                return h
            },
            Pj: function() {
                return Ye
            },
            nw: function() {
                return pe
            },
            I2: function() {
                return l
            },
            wn: function() {
                return Br
            },
            wG: function() {
                return Fe
            },
            A7: function() {
                return x
            },
            KI: function() {
                return m
            },
            y3: function() {
                return Ze
            },
            bO: function() {
                return Ir
            },
            AB: function() {
                return or
            },
            _b: function() {
                return Ge
            },
            E9: function() {
                return $e
            },
            mg: function() {
                return qe
            },
            $r: function() {
                return wr
            },
            ud: function() {
                return Zr
            },
            jl: function() {
                return je
            },
            Ae: function() {
                return Ve
            },
            TI: function() {
                return Yr
            },
            Th: function() {
                return hi
            },
            c9: function() {
                return Ke
            },
            aH: function() {
                return f
            },
            HS: function() {
                return He
            },
            pX: function() {
                return pi
            },
            ex: function() {
                return Cr
            },
            ZM: function() {
                return be
            },
            vK: function() {
                return c
            },
            xE: function() {
                return Wr
            },
            UX: function() {
                return ln
            },
            vB: function() {
                return Zn
            },
            wx: function() {
                return hr
            },
            uF: function() {
                return Yn
            },
            oo: function() {
                return Ar
            },
            Rv: function() {
                return ye
            },
            Nt: function() {
                return p
            },
            e6: function() {
                return ti
            },
            Y9: function() {
                return ri
            },
            kP: function() {
                return ei
            },
            Rw: function() {
                return ve
            },
            tq: function() {
                return z
            },
            Xd: function() {
                return w
            },
            P6: function() {
                return n
            }
        });
        var n = {};
        r.r(n),
        r.d(n, {
            BaseTextureCache: function() {
                return re
            },
            BoundingBox: function() {
                return Qt
            },
            CanvasRenderTarget: function() {
                return se
            },
            DATA_URI: function() {
                return Gt
            },
            EventEmitter: function() {
                return H
            },
            ProgramCache: function() {
                return te
            },
            TextureCache: function() {
                return ee
            },
            clearTextureCache: function() {
                return ie
            },
            correctBlendMode: function() {
                return Lt
            },
            createIndicesForQuads: function() {
                return jt
            },
            decomposeDataUri: function() {
                return ue
            },
            deprecation: function() {
                return Z
            },
            destroyTextureCache: function() {
                return ne
            },
            determineCrossOrigin: function() {
                return de
            },
            earcut: function() {
                return $
            },
            getBufferType: function() {
                return zt
            },
            getCanvasBoundingBox: function() {
                return he
            },
            getResolutionOfUrl: function() {
                return fe
            },
            hex2rgb: function() {
                return Mt
            },
            hex2string: function() {
                return Dt
            },
            interleaveTypedArrays: function() {
                return $t
            },
            isMobile: function() {
                return z
            },
            isPow2: function() {
                return Vt
            },
            isWebGLSupported: function() {
                return et
            },
            log2: function() {
                return Wt
            },
            nextPow2: function() {
                return Xt
            },
            path: function() {
                return q
            },
            premultiplyBlendMode: function() {
                return kt
            },
            premultiplyRgba: function() {
                return Nt
            },
            premultiplyTint: function() {
                return Ft
            },
            premultiplyTintToRgba: function() {
                return Ut
            },
            removeItems: function() {
                return Yt
            },
            rgb2hex: function() {
                return Bt
            },
            sayHello: function() {
                return Q
            },
            sign: function() {
                return qt
            },
            skipHello: function() {
                return J
            },
            string2hex: function() {
                return Ot
            },
            trimCanvas: function() {
                return le
            },
            uid: function() {
                return Zt
            },
            url: function() {
                return V
            }
        });
        var i = (t => (t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY",
        t[t.WEBGL = 1] = "WEBGL",
        t[t.WEBGL2 = 2] = "WEBGL2",
        t))(i || {})
          , s = (t => (t[t.UNKNOWN = 0] = "UNKNOWN",
        t[t.WEBGL = 1] = "WEBGL",
        t[t.CANVAS = 2] = "CANVAS",
        t))(s || {})
          , o = (t => (t[t.COLOR = 16384] = "COLOR",
        t[t.DEPTH = 256] = "DEPTH",
        t[t.STENCIL = 1024] = "STENCIL",
        t))(o || {})
          , a = (t => (t[t.NORMAL = 0] = "NORMAL",
        t[t.ADD = 1] = "ADD",
        t[t.MULTIPLY = 2] = "MULTIPLY",
        t[t.SCREEN = 3] = "SCREEN",
        t[t.OVERLAY = 4] = "OVERLAY",
        t[t.DARKEN = 5] = "DARKEN",
        t[t.LIGHTEN = 6] = "LIGHTEN",
        t[t.COLOR_DODGE = 7] = "COLOR_DODGE",
        t[t.COLOR_BURN = 8] = "COLOR_BURN",
        t[t.HARD_LIGHT = 9] = "HARD_LIGHT",
        t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT",
        t[t.DIFFERENCE = 11] = "DIFFERENCE",
        t[t.EXCLUSION = 12] = "EXCLUSION",
        t[t.HUE = 13] = "HUE",
        t[t.SATURATION = 14] = "SATURATION",
        t[t.COLOR = 15] = "COLOR",
        t[t.LUMINOSITY = 16] = "LUMINOSITY",
        t[t.NORMAL_NPM = 17] = "NORMAL_NPM",
        t[t.ADD_NPM = 18] = "ADD_NPM",
        t[t.SCREEN_NPM = 19] = "SCREEN_NPM",
        t[t.NONE = 20] = "NONE",
        t[t.SRC_OVER = 0] = "SRC_OVER",
        t[t.SRC_IN = 21] = "SRC_IN",
        t[t.SRC_OUT = 22] = "SRC_OUT",
        t[t.SRC_ATOP = 23] = "SRC_ATOP",
        t[t.DST_OVER = 24] = "DST_OVER",
        t[t.DST_IN = 25] = "DST_IN",
        t[t.DST_OUT = 26] = "DST_OUT",
        t[t.DST_ATOP = 27] = "DST_ATOP",
        t[t.ERASE = 26] = "ERASE",
        t[t.SUBTRACT = 28] = "SUBTRACT",
        t[t.XOR = 29] = "XOR",
        t))(a || {})
          , h = (t => (t[t.POINTS = 0] = "POINTS",
        t[t.LINES = 1] = "LINES",
        t[t.LINE_LOOP = 2] = "LINE_LOOP",
        t[t.LINE_STRIP = 3] = "LINE_STRIP",
        t[t.TRIANGLES = 4] = "TRIANGLES",
        t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP",
        t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN",
        t))(h || {})
          , l = (t => (t[t.RGBA = 6408] = "RGBA",
        t[t.RGB = 6407] = "RGB",
        t[t.RG = 33319] = "RG",
        t[t.RED = 6403] = "RED",
        t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
        t[t.RGB_INTEGER = 36248] = "RGB_INTEGER",
        t[t.RG_INTEGER = 33320] = "RG_INTEGER",
        t[t.RED_INTEGER = 36244] = "RED_INTEGER",
        t[t.ALPHA = 6406] = "ALPHA",
        t[t.LUMINANCE = 6409] = "LUMINANCE",
        t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
        t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
        t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
        t))(l || {})
          , u = (t => (t[t.TEXTURE_2D = 3553] = "TEXTURE_2D",
        t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP",
        t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY",
        t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X",
        t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X",
        t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y",
        t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y",
        t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z",
        t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z",
        t))(u || {})
          , c = (t => (t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
        t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
        t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
        t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
        t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
        t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
        t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
        t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
        t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
        t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
        t[t.BYTE = 5120] = "BYTE",
        t[t.SHORT = 5122] = "SHORT",
        t[t.INT = 5124] = "INT",
        t[t.FLOAT = 5126] = "FLOAT",
        t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
        t[t.HALF_FLOAT = 36193] = "HALF_FLOAT",
        t))(c || {})
          , d = (t => (t[t.FLOAT = 0] = "FLOAT",
        t[t.INT = 1] = "INT",
        t[t.UINT = 2] = "UINT",
        t))(d || {})
          , f = (t => (t[t.NEAREST = 0] = "NEAREST",
        t[t.LINEAR = 1] = "LINEAR",
        t))(f || {})
          , p = (t => (t[t.CLAMP = 33071] = "CLAMP",
        t[t.REPEAT = 10497] = "REPEAT",
        t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT",
        t))(p || {})
          , m = (t => (t[t.OFF = 0] = "OFF",
        t[t.POW2 = 1] = "POW2",
        t[t.ON = 2] = "ON",
        t[t.ON_MANUAL = 3] = "ON_MANUAL",
        t))(m || {})
          , g = (t => (t[t.NPM = 0] = "NPM",
        t[t.UNPACK = 1] = "UNPACK",
        t[t.PMA = 2] = "PMA",
        t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA",
        t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD",
        t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA",
        t))(g || {})
          , v = (t => (t[t.NO = 0] = "NO",
        t[t.YES = 1] = "YES",
        t[t.AUTO = 2] = "AUTO",
        t[t.BLEND = 0] = "BLEND",
        t[t.CLEAR = 1] = "CLEAR",
        t[t.BLIT = 2] = "BLIT",
        t))(v || {})
          , y = (t => (t[t.AUTO = 0] = "AUTO",
        t[t.MANUAL = 1] = "MANUAL",
        t))(y || {})
          , _ = (t => (t.LOW = "lowp",
        t.MEDIUM = "mediump",
        t.HIGH = "highp",
        t))(_ || {})
          , x = (t => (t[t.NONE = 0] = "NONE",
        t[t.SCISSOR = 1] = "SCISSOR",
        t[t.STENCIL = 2] = "STENCIL",
        t[t.SPRITE = 3] = "SPRITE",
        t[t.COLOR = 4] = "COLOR",
        t))(x || {})
          , b = (t => (t[t.NONE = 0] = "NONE",
        t[t.LOW = 2] = "LOW",
        t[t.MEDIUM = 4] = "MEDIUM",
        t[t.HIGH = 8] = "HIGH",
        t))(b || {})
          , E = (t => (t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
        t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
        t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER",
        t))(E || {});
        const T = {
            createCanvas: (t, e) => {
                const r = document.createElement("canvas");
                return r.width = t,
                r.height = e,
                r
            }
            ,
            getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
            getWebGLRenderingContext: () => WebGLRenderingContext,
            getNavigator: () => navigator,
            getBaseUrl: () => document.baseURI ?? window.location.href,
            getFontFaceSet: () => document.fonts,
            fetch: (t, e) => fetch(t, e),
            parseXML: t => (new DOMParser).parseFromString(t, "text/xml")
        }
          , w = {
            ADAPTER: T,
            RESOLUTION: 1,
            CREATE_IMAGE_BITMAP: !1,
            ROUND_PIXELS: !1
        };
        var S = /iPhone/i
          , A = /iPod/i
          , C = /iPad/i
          , R = /\biOS-universal(?:.+)Mac\b/i
          , P = /\bAndroid(?:.+)Mobile\b/i
          , I = /Android/i
          , M = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i
          , D = /Silk/i
          , O = /Windows Phone/i
          , B = /\bWindows(?:.+)ARM\b/i
          , k = /BlackBerry/i
          , L = /BB10/i
          , N = /Opera Mini/i
          , F = /\b(CriOS|Chrome)(?:.+)Mobile/i
          , U = /Mobile(?:.+)Firefox\b/i
          , G = function(t) {
            return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream
        };
        function j(t) {
            var e = {
                userAgent: "",
                platform: "",
                maxTouchPoints: 0
            };
            t || "undefined" == typeof navigator ? "string" == typeof t ? e.userAgent = t : t && t.userAgent && (e = {
                userAgent: t.userAgent,
                platform: t.platform,
                maxTouchPoints: t.maxTouchPoints || 0
            }) : e = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                maxTouchPoints: navigator.maxTouchPoints || 0
            };
            var r = e.userAgent
              , n = r.split("[FBAN");
            void 0 !== n[1] && (r = n[0]),
            void 0 !== (n = r.split("Twitter"))[1] && (r = n[0]);
            var i = function(t) {
                return function(e) {
                    return e.test(t)
                }
            }(r)
              , s = {
                apple: {
                    phone: i(S) && !i(O),
                    ipod: i(A),
                    tablet: !i(S) && (i(C) || G(e)) && !i(O),
                    universal: i(R),
                    device: (i(S) || i(A) || i(C) || i(R) || G(e)) && !i(O)
                },
                amazon: {
                    phone: i(M),
                    tablet: !i(M) && i(D),
                    device: i(M) || i(D)
                },
                android: {
                    phone: !i(O) && i(M) || !i(O) && i(P),
                    tablet: !i(O) && !i(M) && !i(P) && (i(D) || i(I)),
                    device: !i(O) && (i(M) || i(D) || i(P) || i(I)) || i(/\bokhttp\b/i)
                },
                windows: {
                    phone: i(O),
                    tablet: i(B),
                    device: i(O) || i(B)
                },
                other: {
                    blackberry: i(k),
                    blackberry10: i(L),
                    opera: i(N),
                    firefox: i(U),
                    chrome: i(F),
                    device: i(k) || i(L) || i(N) || i(U) || i(F)
                },
                any: !1,
                phone: !1,
                tablet: !1
            };
            return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device,
            s.phone = s.apple.phone || s.android.phone || s.windows.phone,
            s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet,
            s
        }
        const z = (j.default ?? j)(globalThis.navigator);
        w.RETINA_PREFIX = /@([0-9\.]+)x/,
        w.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
        var H = r(26729)
          , $ = r(9187)
          , X = r(8575);
        const V = {
            parse: X.Qc,
            format: X.WU,
            resolve: X.DB
        };
        function W(t) {
            if ("string" != typeof t)
                throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`)
        }
        function Y(t) {
            return t.split("?")[0].split("#")[0]
        }
        const q = {
            toPosix(t) {
                return "\\",
                "/",
                t.replace(new RegExp("\\".replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),"g"), "/")
            },
            isUrl(t) {
                return /^https?:/.test(this.toPosix(t))
            },
            isDataUrl(t) {
                return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t)
            },
            hasProtocol(t) {
                return /^[^/:]+:\//.test(this.toPosix(t))
            },
            getProtocol(t) {
                W(t),
                t = this.toPosix(t);
                let e = "";
                const r = /^file:\/\/\//.exec(t)
                  , n = /^[^/:]+:\/\//.exec(t)
                  , i = /^[^/:]+:\//.exec(t);
                if (r || n || i) {
                    const s = r?.[0] || n?.[0] || i?.[0];
                    e = s,
                    t = t.slice(s.length)
                }
                return e
            },
            toAbsolute(t, e, r) {
                if (this.isDataUrl(t))
                    return t;
                const n = Y(this.toPosix(e ?? w.ADAPTER.getBaseUrl()))
                  , i = Y(this.toPosix(r ?? this.rootname(n)));
                return W(t),
                (t = this.toPosix(t)).startsWith("/") ? q.join(i, t.slice(1)) : this.isAbsolute(t) ? t : this.join(n, t)
            },
            normalize(t) {
                if (W(t = this.toPosix(t)),
                0 === t.length)
                    return ".";
                let e = "";
                const r = t.startsWith("/");
                this.hasProtocol(t) && (e = this.rootname(t),
                t = t.slice(e.length));
                const n = t.endsWith("/");
                return t = function(t, e) {
                    let r = ""
                      , n = 0
                      , i = -1
                      , s = 0
                      , o = -1;
                    for (let e = 0; e <= t.length; ++e) {
                        if (e < t.length)
                            o = t.charCodeAt(e);
                        else {
                            if (47 === o)
                                break;
                            o = 47
                        }
                        if (47 === o) {
                            if (i === e - 1 || 1 === s)
                                ;
                            else if (i !== e - 1 && 2 === s) {
                                if (r.length < 2 || 2 !== n || 46 !== r.charCodeAt(r.length - 1) || 46 !== r.charCodeAt(r.length - 2))
                                    if (r.length > 2) {
                                        const t = r.lastIndexOf("/");
                                        if (t !== r.length - 1) {
                                            -1 === t ? (r = "",
                                            n = 0) : (r = r.slice(0, t),
                                            n = r.length - 1 - r.lastIndexOf("/")),
                                            i = e,
                                            s = 0;
                                            continue
                                        }
                                    } else if (2 === r.length || 1 === r.length) {
                                        r = "",
                                        n = 0,
                                        i = e,
                                        s = 0;
                                        continue
                                    }
                            } else
                                r.length > 0 ? r += `/${t.slice(i + 1, e)}` : r = t.slice(i + 1, e),
                                n = e - i - 1;
                            i = e,
                            s = 0
                        } else
                            46 === o && -1 !== s ? ++s : s = -1
                    }
                    return r
                }(t),
                t.length > 0 && n && (t += "/"),
                r ? `/${t}` : e + t
            },
            isAbsolute(t) {
                return W(t),
                t = this.toPosix(t),
                !!this.hasProtocol(t) || t.startsWith("/")
            },
            join(...t) {
                if (0 === t.length)
                    return ".";
                let e;
                for (let r = 0; r < t.length; ++r) {
                    const n = t[r];
                    if (W(n),
                    n.length > 0)
                        if (void 0 === e)
                            e = n;
                        else {
                            const i = t[r - 1] ?? "";
                            this.extname(i) ? e += `/../${n}` : e += `/${n}`
                        }
                }
                return void 0 === e ? "." : this.normalize(e)
            },
            dirname(t) {
                if (W(t),
                0 === t.length)
                    return ".";
                let e = (t = this.toPosix(t)).charCodeAt(0);
                const r = 47 === e;
                let n = -1
                  , i = !0;
                const s = this.getProtocol(t)
                  , o = t;
                for (let r = (t = t.slice(s.length)).length - 1; r >= 1; --r)
                    if (e = t.charCodeAt(r),
                    47 === e) {
                        if (!i) {
                            n = r;
                            break
                        }
                    } else
                        i = !1;
                return -1 === n ? r ? "/" : this.isUrl(o) ? s + t : s : r && 1 === n ? "//" : s + t.slice(0, n)
            },
            rootname(t) {
                W(t);
                let e = "";
                if (e = (t = this.toPosix(t)).startsWith("/") ? "/" : this.getProtocol(t),
                this.isUrl(t)) {
                    const r = t.indexOf("/", e.length);
                    e = -1 !== r ? t.slice(0, r) : t,
                    e.endsWith("/") || (e += "/")
                }
                return e
            },
            basename(t, e) {
                W(t),
                e && W(e),
                t = Y(this.toPosix(t));
                let r, n = 0, i = -1, s = !0;
                if (void 0 !== e && e.length > 0 && e.length <= t.length) {
                    if (e.length === t.length && e === t)
                        return "";
                    let o = e.length - 1
                      , a = -1;
                    for (r = t.length - 1; r >= 0; --r) {
                        const h = t.charCodeAt(r);
                        if (47 === h) {
                            if (!s) {
                                n = r + 1;
                                break
                            }
                        } else
                            -1 === a && (s = !1,
                            a = r + 1),
                            o >= 0 && (h === e.charCodeAt(o) ? -1 == --o && (i = r) : (o = -1,
                            i = a))
                    }
                    return n === i ? i = a : -1 === i && (i = t.length),
                    t.slice(n, i)
                }
                for (r = t.length - 1; r >= 0; --r)
                    if (47 === t.charCodeAt(r)) {
                        if (!s) {
                            n = r + 1;
                            break
                        }
                    } else
                        -1 === i && (s = !1,
                        i = r + 1);
                return -1 === i ? "" : t.slice(n, i)
            },
            extname(t) {
                W(t);
                let e = -1
                  , r = 0
                  , n = -1
                  , i = !0
                  , s = 0;
                for (let o = (t = Y(this.toPosix(t))).length - 1; o >= 0; --o) {
                    const a = t.charCodeAt(o);
                    if (47 !== a)
                        -1 === n && (i = !1,
                        n = o + 1),
                        46 === a ? -1 === e ? e = o : 1 !== s && (s = 1) : -1 !== e && (s = -1);
                    else if (!i) {
                        r = o + 1;
                        break
                    }
                }
                return -1 === e || -1 === n || 0 === s || 1 === s && e === n - 1 && e === r + 1 ? "" : t.slice(e, n)
            },
            parse(t) {
                W(t);
                const e = {
                    root: "",
                    dir: "",
                    base: "",
                    ext: "",
                    name: ""
                };
                if (0 === t.length)
                    return e;
                let r = (t = Y(this.toPosix(t))).charCodeAt(0);
                const n = this.isAbsolute(t);
                let i;
                e.root = this.rootname(t),
                i = n || this.hasProtocol(t) ? 1 : 0;
                let s = -1
                  , o = 0
                  , a = -1
                  , h = !0
                  , l = t.length - 1
                  , u = 0;
                for (; l >= i; --l)
                    if (r = t.charCodeAt(l),
                    47 !== r)
                        -1 === a && (h = !1,
                        a = l + 1),
                        46 === r ? -1 === s ? s = l : 1 !== u && (u = 1) : -1 !== s && (u = -1);
                    else if (!h) {
                        o = l + 1;
                        break
                    }
                return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === o + 1 ? -1 !== a && (e.base = e.name = 0 === o && n ? t.slice(1, a) : t.slice(o, a)) : (0 === o && n ? (e.name = t.slice(1, s),
                e.base = t.slice(1, a)) : (e.name = t.slice(o, s),
                e.base = t.slice(o, a)),
                e.ext = t.slice(s, a)),
                e.dir = this.dirname(t),
                e
            },
            sep: "/",
            delimiter: ":"
        }
          , K = {};
        function Z(t, e, r=3) {
            if (K[e])
                return;
            let n = (new Error).stack;
            void 0 === n ? console.warn("PixiJS Deprecation Warning: ", `${e}\nDeprecated since v${t}`) : (n = n.split("\n").splice(r).join("\n"),
            console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}\nDeprecated since v${t}`),
            console.warn(n),
            console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}\nDeprecated since v${t}`),
            console.warn(n))),
            K[e] = !0
        }
        function J() {
            Z("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")
        }
        function Q() {
            Z("7.0.0", 'sayHello is deprecated, please use Renderer\'s "hello" option')
        }
        let tt;
        function et() {
            return void 0 === tt && (tt = function() {
                const t = {
                    stencil: !0,
                    failIfMajorPerformanceCaveat: w.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
                };
                try {
                    if (!w.ADAPTER.getWebGLRenderingContext())
                        return !1;
                    const e = w.ADAPTER.createCanvas();
                    let r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t);
                    const n = !!r?.getContextAttributes()?.stencil;
                    if (r) {
                        const t = r.getExtension("WEBGL_lose_context");
                        t && t.loseContext()
                    }
                    return r = null,
                    n
                } catch (t) {
                    return !1
                }
            }()),
            tt
        }
        var rt = {
            grad: .9,
            turn: 360,
            rad: 360 / (2 * Math.PI)
        }
          , nt = function(t) {
            return "string" == typeof t ? t.length > 0 : "number" == typeof t
        }
          , it = function(t, e, r) {
            return void 0 === e && (e = 0),
            void 0 === r && (r = Math.pow(10, e)),
            Math.round(r * t) / r + 0
        }
          , st = function(t, e, r) {
            return void 0 === e && (e = 0),
            void 0 === r && (r = 1),
            t > r ? r : t > e ? t : e
        }
          , ot = function(t) {
            return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360
        }
          , at = function(t) {
            return {
                r: st(t.r, 0, 255),
                g: st(t.g, 0, 255),
                b: st(t.b, 0, 255),
                a: st(t.a)
            }
        }
          , ht = function(t) {
            return {
                r: it(t.r),
                g: it(t.g),
                b: it(t.b),
                a: it(t.a, 3)
            }
        }
          , lt = /^#([0-9a-f]{3,8})$/i
          , ut = function(t) {
            var e = t.toString(16);
            return e.length < 2 ? "0" + e : e
        }
          , ct = function(t) {
            var e = t.r
              , r = t.g
              , n = t.b
              , i = t.a
              , s = Math.max(e, r, n)
              , o = s - Math.min(e, r, n)
              , a = o ? s === e ? (r - n) / o : s === r ? 2 + (n - e) / o : 4 + (e - r) / o : 0;
            return {
                h: 60 * (a < 0 ? a + 6 : a),
                s: s ? o / s * 100 : 0,
                v: s / 255 * 100,
                a: i
            }
        }
          , dt = function(t) {
            var e = t.h
              , r = t.s
              , n = t.v
              , i = t.a;
            e = e / 360 * 6,
            r /= 100,
            n /= 100;
            var s = Math.floor(e)
              , o = n * (1 - r)
              , a = n * (1 - (e - s) * r)
              , h = n * (1 - (1 - e + s) * r)
              , l = s % 6;
            return {
                r: 255 * [n, a, o, o, h, n][l],
                g: 255 * [h, n, n, a, o, o][l],
                b: 255 * [o, o, h, n, n, a][l],
                a: i
            }
        }
          , ft = function(t) {
            return {
                h: ot(t.h),
                s: st(t.s, 0, 100),
                l: st(t.l, 0, 100),
                a: st(t.a)
            }
        }
          , pt = function(t) {
            return {
                h: it(t.h),
                s: it(t.s),
                l: it(t.l),
                a: it(t.a, 3)
            }
        }
          , mt = function(t) {
            return dt((r = (e = t).s,
            {
                h: e.h,
                s: (r *= ((n = e.l) < 50 ? n : 100 - n) / 100) > 0 ? 2 * r / (n + r) * 100 : 0,
                v: n + r,
                a: e.a
            }));
            var e, r, n
        }
          , gt = function(t) {
            return {
                h: (e = ct(t)).h,
                s: (i = (200 - (r = e.s)) * (n = e.v) / 100) > 0 && i < 200 ? r * n / 100 / (i <= 100 ? i : 200 - i) * 100 : 0,
                l: i / 2,
                a: e.a
            };
            var e, r, n, i
        }
          , vt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
          , yt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
          , _t = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
          , xt = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
          , bt = {
            string: [[function(t) {
                var e = lt.exec(t);
                return e ? (t = e[1]).length <= 4 ? {
                    r: parseInt(t[0] + t[0], 16),
                    g: parseInt(t[1] + t[1], 16),
                    b: parseInt(t[2] + t[2], 16),
                    a: 4 === t.length ? it(parseInt(t[3] + t[3], 16) / 255, 2) : 1
                } : 6 === t.length || 8 === t.length ? {
                    r: parseInt(t.substr(0, 2), 16),
                    g: parseInt(t.substr(2, 2), 16),
                    b: parseInt(t.substr(4, 2), 16),
                    a: 8 === t.length ? it(parseInt(t.substr(6, 2), 16) / 255, 2) : 1
                } : null : null
            }
            , "hex"], [function(t) {
                var e = _t.exec(t) || xt.exec(t);
                return e ? e[2] !== e[4] || e[4] !== e[6] ? null : at({
                    r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                    g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                    b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                    a: void 0 === e[7] ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
                }) : null
            }
            , "rgb"], [function(t) {
                var e = vt.exec(t) || yt.exec(t);
                if (!e)
                    return null;
                var r, n, i = ft({
                    h: (r = e[1],
                    n = e[2],
                    void 0 === n && (n = "deg"),
                    Number(r) * (rt[n] || 1)),
                    s: Number(e[3]),
                    l: Number(e[4]),
                    a: void 0 === e[5] ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
                });
                return mt(i)
            }
            , "hsl"]],
            object: [[function(t) {
                var e = t.r
                  , r = t.g
                  , n = t.b
                  , i = t.a
                  , s = void 0 === i ? 1 : i;
                return nt(e) && nt(r) && nt(n) ? at({
                    r: Number(e),
                    g: Number(r),
                    b: Number(n),
                    a: Number(s)
                }) : null
            }
            , "rgb"], [function(t) {
                var e = t.h
                  , r = t.s
                  , n = t.l
                  , i = t.a
                  , s = void 0 === i ? 1 : i;
                if (!nt(e) || !nt(r) || !nt(n))
                    return null;
                var o = ft({
                    h: Number(e),
                    s: Number(r),
                    l: Number(n),
                    a: Number(s)
                });
                return mt(o)
            }
            , "hsl"], [function(t) {
                var e = t.h
                  , r = t.s
                  , n = t.v
                  , i = t.a
                  , s = void 0 === i ? 1 : i;
                if (!nt(e) || !nt(r) || !nt(n))
                    return null;
                var o = function(t) {
                    return {
                        h: ot(t.h),
                        s: st(t.s, 0, 100),
                        v: st(t.v, 0, 100),
                        a: st(t.a)
                    }
                }({
                    h: Number(e),
                    s: Number(r),
                    v: Number(n),
                    a: Number(s)
                });
                return dt(o)
            }
            , "hsv"]]
        }
          , Et = function(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r][0](t);
                if (n)
                    return [n, e[r][1]]
            }
            return [null, void 0]
        }
          , Tt = function(t, e) {
            var r = gt(t);
            return {
                h: r.h,
                s: st(r.s + 100 * e, 0, 100),
                l: r.l,
                a: r.a
            }
        }
          , wt = function(t) {
            return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255
        }
          , St = function(t, e) {
            var r = gt(t);
            return {
                h: r.h,
                s: r.s,
                l: st(r.l + 100 * e, 0, 100),
                a: r.a
            }
        }
          , At = function() {
            function t(t) {
                this.parsed = function(t) {
                    return "string" == typeof t ? Et(t.trim(), bt.string) : "object" == typeof t && null !== t ? Et(t, bt.object) : [null, void 0]
                }(t)[0],
                this.rgba = this.parsed || {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                }
            }
            return t.prototype.isValid = function() {
                return null !== this.parsed
            }
            ,
            t.prototype.brightness = function() {
                return it(wt(this.rgba), 2)
            }
            ,
            t.prototype.isDark = function() {
                return wt(this.rgba) < .5
            }
            ,
            t.prototype.isLight = function() {
                return wt(this.rgba) >= .5
            }
            ,
            t.prototype.toHex = function() {
                return e = (t = ht(this.rgba)).r,
                r = t.g,
                n = t.b,
                s = (i = t.a) < 1 ? ut(it(255 * i)) : "",
                "#" + ut(e) + ut(r) + ut(n) + s;
                var t, e, r, n, i, s
            }
            ,
            t.prototype.toRgb = function() {
                return ht(this.rgba)
            }
            ,
            t.prototype.toRgbString = function() {
                return e = (t = ht(this.rgba)).r,
                r = t.g,
                n = t.b,
                (i = t.a) < 1 ? "rgba(" + e + ", " + r + ", " + n + ", " + i + ")" : "rgb(" + e + ", " + r + ", " + n + ")";
                var t, e, r, n, i
            }
            ,
            t.prototype.toHsl = function() {
                return pt(gt(this.rgba))
            }
            ,
            t.prototype.toHslString = function() {
                return e = (t = pt(gt(this.rgba))).h,
                r = t.s,
                n = t.l,
                (i = t.a) < 1 ? "hsla(" + e + ", " + r + "%, " + n + "%, " + i + ")" : "hsl(" + e + ", " + r + "%, " + n + "%)";
                var t, e, r, n, i
            }
            ,
            t.prototype.toHsv = function() {
                return t = ct(this.rgba),
                {
                    h: it(t.h),
                    s: it(t.s),
                    v: it(t.v),
                    a: it(t.a, 3)
                };
                var t
            }
            ,
            t.prototype.invert = function() {
                return Ct({
                    r: 255 - (t = this.rgba).r,
                    g: 255 - t.g,
                    b: 255 - t.b,
                    a: t.a
                });
                var t
            }
            ,
            t.prototype.saturate = function(t) {
                return void 0 === t && (t = .1),
                Ct(Tt(this.rgba, t))
            }
            ,
            t.prototype.desaturate = function(t) {
                return void 0 === t && (t = .1),
                Ct(Tt(this.rgba, -t))
            }
            ,
            t.prototype.grayscale = function() {
                return Ct(Tt(this.rgba, -1))
            }
            ,
            t.prototype.lighten = function(t) {
                return void 0 === t && (t = .1),
                Ct(St(this.rgba, t))
            }
            ,
            t.prototype.darken = function(t) {
                return void 0 === t && (t = .1),
                Ct(St(this.rgba, -t))
            }
            ,
            t.prototype.rotate = function(t) {
                return void 0 === t && (t = 15),
                this.hue(this.hue() + t)
            }
            ,
            t.prototype.alpha = function(t) {
                return "number" == typeof t ? Ct({
                    r: (e = this.rgba).r,
                    g: e.g,
                    b: e.b,
                    a: t
                }) : it(this.rgba.a, 3);
                var e
            }
            ,
            t.prototype.hue = function(t) {
                var e = gt(this.rgba);
                return "number" == typeof t ? Ct({
                    h: t,
                    s: e.s,
                    l: e.l,
                    a: e.a
                }) : it(e.h)
            }
            ,
            t.prototype.isEqual = function(t) {
                return this.toHex() === Ct(t).toHex()
            }
            ,
            t
        }()
          , Ct = function(t) {
            return t instanceof At ? t : new At(t)
        }
          , Rt = [];
        !function(t) {
            t.forEach((function(t) {
                Rt.indexOf(t) < 0 && (t(At, bt),
                Rt.push(t))
            }
            ))
        }([function(t, e) {
            var r = {
                white: "#ffffff",
                bisque: "#ffe4c4",
                blue: "#0000ff",
                cadetblue: "#5f9ea0",
                chartreuse: "#7fff00",
                chocolate: "#d2691e",
                coral: "#ff7f50",
                antiquewhite: "#faebd7",
                aqua: "#00ffff",
                azure: "#f0ffff",
                whitesmoke: "#f5f5f5",
                papayawhip: "#ffefd5",
                plum: "#dda0dd",
                blanchedalmond: "#ffebcd",
                black: "#000000",
                gold: "#ffd700",
                goldenrod: "#daa520",
                gainsboro: "#dcdcdc",
                cornsilk: "#fff8dc",
                cornflowerblue: "#6495ed",
                burlywood: "#deb887",
                aquamarine: "#7fffd4",
                beige: "#f5f5dc",
                crimson: "#dc143c",
                cyan: "#00ffff",
                darkblue: "#00008b",
                darkcyan: "#008b8b",
                darkgoldenrod: "#b8860b",
                darkkhaki: "#bdb76b",
                darkgray: "#a9a9a9",
                darkgreen: "#006400",
                darkgrey: "#a9a9a9",
                peachpuff: "#ffdab9",
                darkmagenta: "#8b008b",
                darkred: "#8b0000",
                darkorchid: "#9932cc",
                darkorange: "#ff8c00",
                darkslateblue: "#483d8b",
                gray: "#808080",
                darkslategray: "#2f4f4f",
                darkslategrey: "#2f4f4f",
                deeppink: "#ff1493",
                deepskyblue: "#00bfff",
                wheat: "#f5deb3",
                firebrick: "#b22222",
                floralwhite: "#fffaf0",
                ghostwhite: "#f8f8ff",
                darkviolet: "#9400d3",
                magenta: "#ff00ff",
                green: "#008000",
                dodgerblue: "#1e90ff",
                grey: "#808080",
                honeydew: "#f0fff0",
                hotpink: "#ff69b4",
                blueviolet: "#8a2be2",
                forestgreen: "#228b22",
                lawngreen: "#7cfc00",
                indianred: "#cd5c5c",
                indigo: "#4b0082",
                fuchsia: "#ff00ff",
                brown: "#a52a2a",
                maroon: "#800000",
                mediumblue: "#0000cd",
                lightcoral: "#f08080",
                darkturquoise: "#00ced1",
                lightcyan: "#e0ffff",
                ivory: "#fffff0",
                lightyellow: "#ffffe0",
                lightsalmon: "#ffa07a",
                lightseagreen: "#20b2aa",
                linen: "#faf0e6",
                mediumaquamarine: "#66cdaa",
                lemonchiffon: "#fffacd",
                lime: "#00ff00",
                khaki: "#f0e68c",
                mediumseagreen: "#3cb371",
                limegreen: "#32cd32",
                mediumspringgreen: "#00fa9a",
                lightskyblue: "#87cefa",
                lightblue: "#add8e6",
                midnightblue: "#191970",
                lightpink: "#ffb6c1",
                mistyrose: "#ffe4e1",
                moccasin: "#ffe4b5",
                mintcream: "#f5fffa",
                lightslategray: "#778899",
                lightslategrey: "#778899",
                navajowhite: "#ffdead",
                navy: "#000080",
                mediumvioletred: "#c71585",
                powderblue: "#b0e0e6",
                palegoldenrod: "#eee8aa",
                oldlace: "#fdf5e6",
                paleturquoise: "#afeeee",
                mediumturquoise: "#48d1cc",
                mediumorchid: "#ba55d3",
                rebeccapurple: "#663399",
                lightsteelblue: "#b0c4de",
                mediumslateblue: "#7b68ee",
                thistle: "#d8bfd8",
                tan: "#d2b48c",
                orchid: "#da70d6",
                mediumpurple: "#9370db",
                purple: "#800080",
                pink: "#ffc0cb",
                skyblue: "#87ceeb",
                springgreen: "#00ff7f",
                palegreen: "#98fb98",
                red: "#ff0000",
                yellow: "#ffff00",
                slateblue: "#6a5acd",
                lavenderblush: "#fff0f5",
                peru: "#cd853f",
                palevioletred: "#db7093",
                violet: "#ee82ee",
                teal: "#008080",
                slategray: "#708090",
                slategrey: "#708090",
                aliceblue: "#f0f8ff",
                darkseagreen: "#8fbc8f",
                darkolivegreen: "#556b2f",
                greenyellow: "#adff2f",
                seagreen: "#2e8b57",
                seashell: "#fff5ee",
                tomato: "#ff6347",
                silver: "#c0c0c0",
                sienna: "#a0522d",
                lavender: "#e6e6fa",
                lightgreen: "#90ee90",
                orange: "#ffa500",
                orangered: "#ff4500",
                steelblue: "#4682b4",
                royalblue: "#4169e1",
                turquoise: "#40e0d0",
                yellowgreen: "#9acd32",
                salmon: "#fa8072",
                saddlebrown: "#8b4513",
                sandybrown: "#f4a460",
                rosybrown: "#bc8f8f",
                darksalmon: "#e9967a",
                lightgoldenrodyellow: "#fafad2",
                snow: "#fffafa",
                lightgrey: "#d3d3d3",
                lightgray: "#d3d3d3",
                dimgray: "#696969",
                dimgrey: "#696969",
                olivedrab: "#6b8e23",
                olive: "#808000"
            }
              , n = {};
            for (var i in r)
                n[r[i]] = i;
            var s = {};
            t.prototype.toName = function(e) {
                if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
                    return "transparent";
                var i, o, a = n[this.toHex()];
                if (a)
                    return a;
                if (null == e ? void 0 : e.closest) {
                    var h = this.toRgb()
                      , l = 1 / 0
                      , u = "black";
                    if (!s.length)
                        for (var c in r)
                            s[c] = new t(r[c]).toRgb();
                    for (var d in r) {
                        var f = (i = h,
                        o = s[d],
                        Math.pow(i.r - o.r, 2) + Math.pow(i.g - o.g, 2) + Math.pow(i.b - o.b, 2));
                        f < l && (l = f,
                        u = d)
                    }
                    return u
                }
            }
            ,
            e.string.push([function(e) {
                var n = e.toLowerCase()
                  , i = "transparent" === n ? "#0000" : r[n];
                return i ? new t(i).toRgb() : null
            }
            , "name"])
        }
        ]);
        const Pt = class {
            constructor(t=16777215) {
                this._value = null,
                this._components = new Float32Array(4),
                this._components.fill(1),
                this._int = 16777215,
                this.value = t
            }
            get red() {
                return this._components[0]
            }
            get green() {
                return this._components[1]
            }
            get blue() {
                return this._components[2]
            }
            get alpha() {
                return this._components[3]
            }
            setValue(t) {
                return this.value = t,
                this
            }
            set value(t) {
                if (t instanceof Pt)
                    this._value = this.cloneSource(t._value),
                    this._int = t._int,
                    this._components.set(t._components);
                else {
                    if (null === t)
                        throw new Error("Cannot set PIXI.Color#value to null");
                    null !== this._value && this.isSourceEqual(this._value, t) || (this.normalize(t),
                    this._value = this.cloneSource(t))
                }
            }
            get value() {
                return this._value
            }
            cloneSource(t) {
                return "string" == typeof t || "number" == typeof t || t instanceof Number || null === t ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : "object" == typeof t && null !== t ? {
                    ...t
                } : t
            }
            isSourceEqual(t, e) {
                const r = typeof t;
                if (r !== typeof e)
                    return !1;
                if ("number" === r || "string" === r || t instanceof Number)
                    return t === e;
                if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
                    return t.length === e.length && t.every(( (t, r) => t === e[r]));
                if (null !== t && null !== e) {
                    const r = Object.keys(t)
                      , n = Object.keys(e);
                    return r.length === n.length && r.every((r => t[r] === e[r]))
                }
                return t === e
            }
            toRgba() {
                const [t,e,r,n] = this._components;
                return {
                    r: t,
                    g: e,
                    b: r,
                    a: n
                }
            }
            toRgb() {
                const [t,e,r] = this._components;
                return {
                    r: t,
                    g: e,
                    b: r
                }
            }
            toRgbaString() {
                const [t,e,r] = this.toUint8RgbArray();
                return `rgba(${t},${e},${r},${this.alpha})`
            }
            toUint8RgbArray(t) {
                const [e,r,n] = this._components;
                return (t = t ?? [])[0] = Math.round(255 * e),
                t[1] = Math.round(255 * r),
                t[2] = Math.round(255 * n),
                t
            }
            toRgbArray(t) {
                t = t ?? [];
                const [e,r,n] = this._components;
                return t[0] = e,
                t[1] = r,
                t[2] = n,
                t
            }
            toNumber() {
                return this._int
            }
            toLittleEndianNumber() {
                const t = this._int;
                return (t >> 16) + (65280 & t) + ((255 & t) << 16)
            }
            multiply(t) {
                const [e,r,n,i] = Pt.temp.setValue(t)._components;
                return this._components[0] *= e,
                this._components[1] *= r,
                this._components[2] *= n,
                this._components[3] *= i,
                this.refreshInt(),
                this._value = null,
                this
            }
            premultiply(t, e=!0) {
                return e && (this._components[0] *= t,
                this._components[1] *= t,
                this._components[2] *= t),
                this._components[3] = t,
                this.refreshInt(),
                this._value = null,
                this
            }
            toPremultiplied(t, e=!0) {
                if (1 === t)
                    return (255 << 24) + this._int;
                if (0 === t)
                    return e ? 0 : this._int;
                let r = this._int >> 16 & 255
                  , n = this._int >> 8 & 255
                  , i = 255 & this._int;
                return e && (r = r * t + .5 | 0,
                n = n * t + .5 | 0,
                i = i * t + .5 | 0),
                (255 * t << 24) + (r << 16) + (n << 8) + i
            }
            toHex() {
                const t = this._int.toString(16);
                return `#${"000000".substring(0, 6 - t.length) + t}`
            }
            toHexa() {
                const t = Math.round(255 * this._components[3]).toString(16);
                return this.toHex() + "00".substring(0, 2 - t.length) + t
            }
            setAlpha(t) {
                return this._components[3] = this._clamp(t),
                this
            }
            round(t) {
                const [e,r,n] = this._components;
                return this._components[0] = Math.round(e * t) / t,
                this._components[1] = Math.round(r * t) / t,
                this._components[2] = Math.round(n * t) / t,
                this.refreshInt(),
                this._value = null,
                this
            }
            toArray(t) {
                t = t ?? [];
                const [e,r,n,i] = this._components;
                return t[0] = e,
                t[1] = r,
                t[2] = n,
                t[3] = i,
                t
            }
            normalize(t) {
                let e, r, n, i;
                if (("number" == typeof t || t instanceof Number) && t >= 0 && t <= 16777215)
                    e = (t >> 16 & 255) / 255,
                    r = (t >> 8 & 255) / 255,
                    n = (255 & t) / 255,
                    i = 1;
                else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4)
                    t = this._clamp(t),
                    [e,r,n,i=1] = t;
                else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4)
                    t = this._clamp(t, 0, 255),
                    [e,r,n,i=255] = t,
                    e /= 255,
                    r /= 255,
                    n /= 255,
                    i /= 255;
                else if ("string" == typeof t || "object" == typeof t) {
                    if ("string" == typeof t) {
                        const e = Pt.HEX_PATTERN.exec(t);
                        e && (t = `#${e[2]}`)
                    }
                    const s = Ct(t);
                    s.isValid() && (({r: e, g: r, b: n, a: i} = s.rgba),
                    e /= 255,
                    r /= 255,
                    n /= 255)
                }
                if (void 0 === e)
                    throw new Error(`Unable to convert color ${t}`);
                this._components[0] = e,
                this._components[1] = r,
                this._components[2] = n,
                this._components[3] = i,
                this.refreshInt()
            }
            refreshInt() {
                this._clamp(this._components);
                const [t,e,r] = this._components;
                this._int = (255 * t << 16) + (255 * e << 8) + (255 * r | 0)
            }
            _clamp(t, e=0, r=1) {
                return "number" == typeof t ? Math.min(Math.max(t, e), r) : (t.forEach(( (n, i) => {
                    t[i] = Math.min(Math.max(n, e), r)
                }
                )),
                t)
            }
        }
        ;
        let It = Pt;
        function Mt(t, e=[]) {
            return Z("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"),
            It.shared.setValue(t).toRgbArray(e)
        }
        function Dt(t) {
            return Z("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"),
            It.shared.setValue(t).toHex()
        }
        function Ot(t) {
            return Z("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"),
            It.shared.setValue(t).toNumber()
        }
        function Bt(t) {
            return Z("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"),
            It.shared.setValue(t).toNumber()
        }
        It.shared = new Pt,
        It.temp = new Pt,
        It.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
        const kt = function() {
            const t = []
              , e = [];
            for (let r = 0; r < 32; r++)
                t[r] = r,
                e[r] = r;
            t[a.NORMAL_NPM] = a.NORMAL,
            t[a.ADD_NPM] = a.ADD,
            t[a.SCREEN_NPM] = a.SCREEN,
            e[a.NORMAL] = a.NORMAL_NPM,
            e[a.ADD] = a.ADD_NPM,
            e[a.SCREEN] = a.SCREEN_NPM;
            const r = [];
            return r.push(e),
            r.push(t),
            r
        }();
        function Lt(t, e) {
            return kt[e ? 1 : 0][t]
        }
        function Nt(t, e, r, n=!0) {
            return Z("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"),
            It.shared.setValue(t).premultiply(e, n).toArray(r ?? new Float32Array(4))
        }
        function Ft(t, e) {
            return Z("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"),
            It.shared.setValue(t).toPremultiplied(e)
        }
        function Ut(t, e, r, n=!0) {
            return Z("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"),
            It.shared.setValue(t).premultiply(e, n).toArray(r ?? new Float32Array(4))
        }
        const Gt = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
        function jt(t, e=null) {
            const r = 6 * t;
            if ((e = e || new Uint16Array(r)).length !== r)
                throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${r}`);
            for (let t = 0, n = 0; t < r; t += 6,
            n += 4)
                e[t + 0] = n + 0,
                e[t + 1] = n + 1,
                e[t + 2] = n + 2,
                e[t + 3] = n + 0,
                e[t + 4] = n + 2,
                e[t + 5] = n + 3;
            return e
        }
        function zt(t) {
            if (4 === t.BYTES_PER_ELEMENT)
                return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
            if (2 === t.BYTES_PER_ELEMENT) {
                if (t instanceof Uint16Array)
                    return "Uint16Array"
            } else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array)
                return "Uint8Array";
            return null
        }
        const Ht = {
            Float32Array: Float32Array,
            Uint32Array: Uint32Array,
            Int32Array: Int32Array,
            Uint8Array: Uint8Array
        };
        function $t(t, e) {
            let r = 0
              , n = 0;
            const i = {};
            for (let i = 0; i < t.length; i++)
                n += e[i],
                r += t[i].length;
            const s = new ArrayBuffer(4 * r);
            let o = null
              , a = 0;
            for (let r = 0; r < t.length; r++) {
                const h = e[r]
                  , l = t[r]
                  , u = zt(l);
                i[u] || (i[u] = new Ht[u](s)),
                o = i[u];
                for (let t = 0; t < l.length; t++)
                    o[(t / h | 0) * n + a + t % h] = l[t];
                a += h
            }
            return new Float32Array(s)
        }
        function Xt(t) {
            return t += 0 === t ? 1 : 0,
            --t,
            t |= t >>> 1,
            t |= t >>> 2,
            t |= t >>> 4,
            t |= t >>> 8,
            1 + (t |= t >>> 16)
        }
        function Vt(t) {
            return !(t & t - 1 || !t)
        }
        function Wt(t) {
            let e = (t > 65535 ? 1 : 0) << 4
              , r = ((t >>>= e) > 255 ? 1 : 0) << 3;
            return e |= r,
            r = ((t >>>= r) > 15 ? 1 : 0) << 2,
            e |= r,
            r = ((t >>>= r) > 3 ? 1 : 0) << 1,
            e |= r,
            e | (t >>>= r) >> 1
        }
        function Yt(t, e, r) {
            const n = t.length;
            let i;
            if (e >= n || 0 === r)
                return;
            const s = n - (r = e + r > n ? n - e : r);
            for (i = e; i < s; ++i)
                t[i] = t[i + r];
            t.length = s
        }
        function qt(t) {
            return 0 === t ? 0 : t < 0 ? -1 : 1
        }
        let Kt = 0;
        function Zt() {
            return ++Kt
        }
        const Jt = class {
            constructor(t, e, r, n) {
                this.left = t,
                this.top = e,
                this.right = r,
                this.bottom = n
            }
            get width() {
                return this.right - this.left
            }
            get height() {
                return this.bottom - this.top
            }
            isEmpty() {
                return this.left === this.right || this.top === this.bottom
            }
        }
        ;
        let Qt = Jt;
        Qt.EMPTY = new Jt(0,0,0,0);
        const te = {}
          , ee = Object.create(null)
          , re = Object.create(null);
        function ne() {
            let t;
            for (t in ee)
                ee[t].destroy();
            for (t in re)
                re[t].destroy()
        }
        function ie() {
            let t;
            for (t in ee)
                delete ee[t];
            for (t in re)
                delete re[t]
        }
        class se {
            constructor(t, e, r) {
                this._canvas = w.ADAPTER.createCanvas(),
                this._context = this._canvas.getContext("2d"),
                this.resolution = r || w.RESOLUTION,
                this.resize(t, e)
            }
            clear() {
                this._checkDestroyed(),
                this._context.setTransform(1, 0, 0, 1, 0, 0),
                this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
            }
            resize(t, e) {
                this._checkDestroyed(),
                this._canvas.width = Math.round(t * this.resolution),
                this._canvas.height = Math.round(e * this.resolution)
            }
            destroy() {
                this._context = null,
                this._canvas = null
            }
            get width() {
                return this._checkDestroyed(),
                this._canvas.width
            }
            set width(t) {
                this._checkDestroyed(),
                this._canvas.width = Math.round(t)
            }
            get height() {
                return this._checkDestroyed(),
                this._canvas.height
            }
            set height(t) {
                this._checkDestroyed(),
                this._canvas.height = Math.round(t)
            }
            get canvas() {
                return this._checkDestroyed(),
                this._canvas
            }
            get context() {
                return this._checkDestroyed(),
                this._context
            }
            _checkDestroyed() {
                if (null === this._canvas)
                    throw new TypeError("The CanvasRenderTarget has already been destroyed")
            }
        }
        function oe(t, e, r) {
            for (let n = 0, i = 4 * r * e; n < e; ++n,
            i += 4)
                if (0 !== t[i + 3])
                    return !1;
            return !0
        }
        function ae(t, e, r, n, i) {
            const s = 4 * e;
            for (let e = n, o = n * s + 4 * r; e <= i; ++e,
            o += s)
                if (0 !== t[o + 3])
                    return !1;
            return !0
        }
        function he(t) {
            const {width: e, height: r} = t
              , n = t.getContext("2d", {
                willReadFrequently: !0
            });
            if (null === n)
                throw new TypeError("Failed to get canvas 2D context");
            const i = n.getImageData(0, 0, e, r).data;
            let s = 0
              , o = 0
              , a = e - 1
              , h = r - 1;
            for (; o < r && oe(i, e, o); )
                ++o;
            if (o === r)
                return Qt.EMPTY;
            for (; oe(i, e, h); )
                --h;
            for (; ae(i, e, s, o, h); )
                ++s;
            for (; ae(i, e, a, o, h); )
                --a;
            return ++a,
            ++h,
            new Qt(s,o,a,h)
        }
        function le(t) {
            const e = he(t)
              , {width: r, height: n} = e;
            let i = null;
            if (!e.isEmpty()) {
                const s = t.getContext("2d");
                if (null === s)
                    throw new TypeError("Failed to get canvas 2D context");
                i = s.getImageData(e.left, e.top, r, n)
            }
            return {
                width: r,
                height: n,
                data: i
            }
        }
        function ue(t) {
            const e = Gt.exec(t);
            if (e)
                return {
                    mediaType: e[1] ? e[1].toLowerCase() : void 0,
                    subType: e[2] ? e[2].toLowerCase() : void 0,
                    charset: e[3] ? e[3].toLowerCase() : void 0,
                    encoding: e[4] ? e[4].toLowerCase() : void 0,
                    data: e[5]
                }
        }
        let ce;
        function de(t, e=globalThis.location) {
            if (t.startsWith("data:"))
                return "";
            e = e || globalThis.location,
            ce || (ce = document.createElement("a")),
            ce.href = t;
            const r = V.parse(ce.href)
              , n = !r.port && "" === e.port || r.port === e.port;
            return r.hostname === e.hostname && n && r.protocol === e.protocol ? "" : "anonymous"
        }
        function fe(t, e=1) {
            const r = w.RETINA_PREFIX?.exec(t);
            return r ? parseFloat(r[1]) : e
        }
        var pe = (t => (t.Renderer = "renderer",
        t.Application = "application",
        t.RendererSystem = "renderer-webgl-system",
        t.RendererPlugin = "renderer-webgl-plugin",
        t.CanvasRendererSystem = "renderer-canvas-system",
        t.CanvasRendererPlugin = "renderer-canvas-plugin",
        t.Asset = "asset",
        t.LoadParser = "load-parser",
        t.ResolveParser = "resolve-parser",
        t.CacheParser = "cache-parser",
        t.DetectionParser = "detection-parser",
        t))(pe || {});
        const me = t => {
            if ("function" == typeof t || "object" == typeof t && t.extension) {
                if (!t.extension)
                    throw new Error("Extension class must have an extension object");
                t = {
                    ..."object" != typeof t.extension ? {
                        type: t.extension
                    } : t.extension,
                    ref: t
                }
            }
            if ("object" != typeof t)
                throw new Error("Invalid extension type");
            return "string" == typeof (t = {
                ...t
            }).type && (t.type = [t.type]),
            t
        }
          , ge = (t, e) => me(t).priority ?? e
          , ve = {
            _addHandlers: {},
            _removeHandlers: {},
            _queue: {},
            remove(...t) {
                return t.map(me).forEach((t => {
                    t.type.forEach((e => this._removeHandlers[e]?.(t)))
                }
                )),
                this
            },
            add(...t) {
                return t.map(me).forEach((t => {
                    t.type.forEach((e => {
                        const r = this._addHandlers
                          , n = this._queue;
                        r[e] ? r[e](t) : (n[e] = n[e] || [],
                        n[e].push(t))
                    }
                    ))
                }
                )),
                this
            },
            handle(t, e, r) {
                const n = this._addHandlers
                  , i = this._removeHandlers;
                if (n[t] || i[t])
                    throw new Error(`Extension type ${t} already has a handler`);
                n[t] = e,
                i[t] = r;
                const s = this._queue;
                return s[t] && (s[t].forEach((t => e(t))),
                delete s[t]),
                this
            },
            handleByMap(t, e) {
                return this.handle(t, (t => {
                    e[t.name] = t.ref
                }
                ), (t => {
                    delete e[t.name]
                }
                ))
            },
            handleByList(t, e, r=-1) {
                return this.handle(t, (t => {
                    e.includes(t.ref) || (e.push(t.ref),
                    e.sort(( (t, e) => ge(e, r) - ge(t, r))))
                }
                ), (t => {
                    const r = e.indexOf(t.ref);
                    -1 !== r && e.splice(r, 1)
                }
                ))
            }
        };
        class ye {
            constructor(t) {
                "number" == typeof t ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t,
                this.uint32View = new Uint32Array(this.rawBinaryData),
                this.float32View = new Float32Array(this.rawBinaryData)
            }
            get int8View() {
                return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
                this._int8View
            }
            get uint8View() {
                return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
                this._uint8View
            }
            get int16View() {
                return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
                this._int16View
            }
            get uint16View() {
                return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)),
                this._uint16View
            }
            get int32View() {
                return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
                this._int32View
            }
            view(t) {
                return this[`${t}View`]
            }
            destroy() {
                this.rawBinaryData = null,
                this._int8View = null,
                this._uint8View = null,
                this._int16View = null,
                this._uint16View = null,
                this._int32View = null,
                this.uint32View = null,
                this.float32View = null
            }
            static sizeOf(t) {
                switch (t) {
                case "int8":
                case "uint8":
                    return 1;
                case "int16":
                case "uint16":
                    return 2;
                case "int32":
                case "uint32":
                case "float32":
                    return 4;
                default:
                    throw new Error(`${t} isn't a valid view type`)
                }
            }
        }
        const _e = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");
        function xe(t) {
            let e = "";
            for (let r = 0; r < t; ++r)
                r > 0 && (e += "\nelse "),
                r < t - 1 && (e += `if(test == ${r}.0){}`);
            return e
        }
        class be {
            constructor() {
                this.data = 0,
                this.blendMode = a.NORMAL,
                this.polygonOffset = 0,
                this.blend = !0,
                this.depthMask = !0
            }
            get blend() {
                return !!(1 & this.data)
            }
            set blend(t) {
                !!(1 & this.data) !== t && (this.data ^= 1)
            }
            get offsets() {
                return !!(2 & this.data)
            }
            set offsets(t) {
                !!(2 & this.data) !== t && (this.data ^= 2)
            }
            get culling() {
                return !!(4 & this.data)
            }
            set culling(t) {
                !!(4 & this.data) !== t && (this.data ^= 4)
            }
            get depthTest() {
                return !!(8 & this.data)
            }
            set depthTest(t) {
                !!(8 & this.data) !== t && (this.data ^= 8)
            }
            get depthMask() {
                return !!(32 & this.data)
            }
            set depthMask(t) {
                !!(32 & this.data) !== t && (this.data ^= 32)
            }
            get clockwiseFrontFace() {
                return !!(16 & this.data)
            }
            set clockwiseFrontFace(t) {
                !!(16 & this.data) !== t && (this.data ^= 16)
            }
            get blendMode() {
                return this._blendMode
            }
            set blendMode(t) {
                this.blend = t !== a.NONE,
                this._blendMode = t
            }
            get polygonOffset() {
                return this._polygonOffset
            }
            set polygonOffset(t) {
                this.offsets = !!t,
                this._polygonOffset = t
            }
            toString() {
                return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
            }
            static for2d() {
                const t = new be;
                return t.depthTest = !1,
                t.blend = !0,
                t
            }
        }
        const Ee = [];
        function Te(t, e) {
            if (!t)
                return null;
            let r = "";
            if ("string" == typeof t) {
                const e = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
                e && (r = e[1].toLowerCase())
            }
            for (let n = Ee.length - 1; n >= 0; --n) {
                const i = Ee[n];
                if (i.test && i.test(t, r))
                    return new i(t,e)
            }
            throw new Error("Unrecognized source type to auto-detect Resource")
        }
        class we {
            constructor(t) {
                this.items = [],
                this._name = t,
                this._aliasCount = 0
            }
            emit(t, e, r, n, i, s, o, a) {
                if (arguments.length > 8)
                    throw new Error("max arguments reached");
                const {name: h, items: l} = this;
                this._aliasCount++;
                for (let u = 0, c = l.length; u < c; u++)
                    l[u][h](t, e, r, n, i, s, o, a);
                return l === this.items && this._aliasCount--,
                this
            }
            ensureNonAliasedItems() {
                this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0,
                this.items = this.items.slice(0))
            }
            add(t) {
                return t[this._name] && (this.ensureNonAliasedItems(),
                this.remove(t),
                this.items.push(t)),
                this
            }
            remove(t) {
                const e = this.items.indexOf(t);
                return -1 !== e && (this.ensureNonAliasedItems(),
                this.items.splice(e, 1)),
                this
            }
            contains(t) {
                return this.items.includes(t)
            }
            removeAll() {
                return this.ensureNonAliasedItems(),
                this.items.length = 0,
                this
            }
            destroy() {
                this.removeAll(),
                this.items = null,
                this._name = null
            }
            get empty() {
                return 0 === this.items.length
            }
            get name() {
                return this._name
            }
        }
        Object.defineProperties(we.prototype, {
            dispatch: {
                value: we.prototype.emit
            },
            run: {
                value: we.prototype.emit
            }
        });
        class Se {
            constructor(t=0, e=0) {
                this._width = t,
                this._height = e,
                this.destroyed = !1,
                this.internal = !1,
                this.onResize = new we("setRealSize"),
                this.onUpdate = new we("update"),
                this.onError = new we("onError")
            }
            bind(t) {
                this.onResize.add(t),
                this.onUpdate.add(t),
                this.onError.add(t),
                (this._width || this._height) && this.onResize.emit(this._width, this._height)
            }
            unbind(t) {
                this.onResize.remove(t),
                this.onUpdate.remove(t),
                this.onError.remove(t)
            }
            resize(t, e) {
                t === this._width && e === this._height || (this._width = t,
                this._height = e,
                this.onResize.emit(t, e))
            }
            get valid() {
                return !!this._width && !!this._height
            }
            update() {
                this.destroyed || this.onUpdate.emit()
            }
            load() {
                return Promise.resolve(this)
            }
            get width() {
                return this._width
            }
            get height() {
                return this._height
            }
            style(t, e, r) {
                return !1
            }
            dispose() {}
            destroy() {
                this.destroyed || (this.destroyed = !0,
                this.dispose(),
                this.onError.removeAll(),
                this.onError = null,
                this.onResize.removeAll(),
                this.onResize = null,
                this.onUpdate.removeAll(),
                this.onUpdate = null)
            }
            static test(t, e) {
                return !1
            }
        }
        class Ae extends Se {
            constructor(t, e) {
                const {width: r, height: n} = e || {};
                if (!r || !n)
                    throw new Error("BufferResource width or height invalid");
                super(r, n),
                this.data = t
            }
            upload(t, e, r) {
                const n = t.gl;
                n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === g.UNPACK);
                const i = e.realWidth
                  , s = e.realHeight;
                return r.width === i && r.height === s ? n.texSubImage2D(e.target, 0, 0, 0, i, s, e.format, r.type, this.data) : (r.width = i,
                r.height = s,
                n.texImage2D(e.target, 0, r.internalFormat, i, s, 0, e.format, r.type, this.data)),
                !0
            }
            dispose() {
                this.data = null
            }
            static test(t) {
                return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
            }
        }
        const Ce = {
            scaleMode: f.NEAREST,
            format: l.RGBA,
            alphaMode: g.NPM
        }
          , Re = class extends H {
            constructor(t=null, e=null) {
                super(),
                e = Object.assign({}, Re.defaultOptions, e);
                const {alphaMode: r, mipmap: n, anisotropicLevel: i, scaleMode: s, width: o, height: a, wrapMode: h, format: l, type: u, target: c, resolution: d, resourceOptions: f} = e;
                !t || t instanceof Se || ((t = Te(t, f)).internal = !0),
                this.resolution = d || w.RESOLUTION,
                this.width = Math.round((o || 0) * this.resolution) / this.resolution,
                this.height = Math.round((a || 0) * this.resolution) / this.resolution,
                this._mipmap = n,
                this.anisotropicLevel = i,
                this._wrapMode = h,
                this._scaleMode = s,
                this.format = l,
                this.type = u,
                this.target = c,
                this.alphaMode = r,
                this.uid = Zt(),
                this.touched = 0,
                this.isPowerOfTwo = !1,
                this._refreshPOT(),
                this._glTextures = {},
                this.dirtyId = 0,
                this.dirtyStyleId = 0,
                this.cacheId = null,
                this.valid = o > 0 && a > 0,
                this.textureCacheIds = [],
                this.destroyed = !1,
                this.resource = null,
                this._batchEnabled = 0,
                this._batchLocation = 0,
                this.parentTextureArray = null,
                this.setResource(t)
            }
            get realWidth() {
                return Math.round(this.width * this.resolution)
            }
            get realHeight() {
                return Math.round(this.height * this.resolution)
            }
            get mipmap() {
                return this._mipmap
            }
            set mipmap(t) {
                this._mipmap !== t && (this._mipmap = t,
                this.dirtyStyleId++)
            }
            get scaleMode() {
                return this._scaleMode
            }
            set scaleMode(t) {
                this._scaleMode !== t && (this._scaleMode = t,
                this.dirtyStyleId++)
            }
            get wrapMode() {
                return this._wrapMode
            }
            set wrapMode(t) {
                this._wrapMode !== t && (this._wrapMode = t,
                this.dirtyStyleId++)
            }
            setStyle(t, e) {
                let r;
                return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t,
                r = !0),
                void 0 !== e && e !== this.mipmap && (this.mipmap = e,
                r = !0),
                r && this.dirtyStyleId++,
                this
            }
            setSize(t, e, r) {
                return r = r || this.resolution,
                this.setRealSize(t * r, e * r, r)
            }
            setRealSize(t, e, r) {
                return this.resolution = r || this.resolution,
                this.width = Math.round(t) / this.resolution,
                this.height = Math.round(e) / this.resolution,
                this._refreshPOT(),
                this.update(),
                this
            }
            _refreshPOT() {
                this.isPowerOfTwo = Vt(this.realWidth) && Vt(this.realHeight)
            }
            setResolution(t) {
                const e = this.resolution;
                return e === t || (this.resolution = t,
                this.valid && (this.width = Math.round(this.width * e) / t,
                this.height = Math.round(this.height * e) / t,
                this.emit("update", this)),
                this._refreshPOT()),
                this
            }
            setResource(t) {
                if (this.resource === t)
                    return this;
                if (this.resource)
                    throw new Error("Resource can be set only once");
                return t.bind(this),
                this.resource = t,
                this
            }
            update() {
                this.valid ? (this.dirtyId++,
                this.dirtyStyleId++,
                this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0,
                this.emit("loaded", this),
                this.emit("update", this))
            }
            onError(t) {
                this.emit("error", this, t)
            }
            destroy() {
                this.resource && (this.resource.unbind(this),
                this.resource.internal && this.resource.destroy(),
                this.resource = null),
                this.cacheId && (delete re[this.cacheId],
                delete ee[this.cacheId],
                this.cacheId = null),
                this.dispose(),
                Re.removeFromCache(this),
                this.textureCacheIds = null,
                this.destroyed = !0
            }
            dispose() {
                this.emit("dispose", this)
            }
            castToBaseTexture() {
                return this
            }
            static from(t, e, r=w.STRICT_TEXTURE_CACHE) {
                const n = "string" == typeof t;
                let i = null;
                if (n)
                    i = t;
                else {
                    if (!t._pixiId) {
                        const r = e?.pixiIdPrefix || "pixiid";
                        t._pixiId = `${r}_${Zt()}`
                    }
                    i = t._pixiId
                }
                let s = re[i];
                if (n && r && !s)
                    throw new Error(`The cacheId "${i}" does not exist in BaseTextureCache.`);
                return s || (s = new Re(t,e),
                s.cacheId = i,
                Re.addToCache(s, i)),
                s
            }
            static fromBuffer(t, e, r, n) {
                t = t || new Float32Array(e * r * 4);
                const i = new Ae(t,{
                    width: e,
                    height: r
                })
                  , s = t instanceof Float32Array ? c.FLOAT : c.UNSIGNED_BYTE;
                return new Re(i,Object.assign({}, Ce, {
                    type: s
                }, n))
            }
            static addToCache(t, e) {
                e && (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e),
                re[e] && re[e] !== t && console.warn(`BaseTexture added to the cache with an id [${e}] that already had an entry`),
                re[e] = t)
            }
            static removeFromCache(t) {
                if ("string" == typeof t) {
                    const e = re[t];
                    if (e) {
                        const r = e.textureCacheIds.indexOf(t);
                        return r > -1 && e.textureCacheIds.splice(r, 1),
                        delete re[t],
                        e
                    }
                } else if (t?.textureCacheIds) {
                    for (let e = 0; e < t.textureCacheIds.length; ++e)
                        delete re[t.textureCacheIds[e]];
                    return t.textureCacheIds.length = 0,
                    t
                }
                return null
            }
        }
        ;
        let Pe = Re;
        Pe.defaultOptions = {
            mipmap: m.POW2,
            anisotropicLevel: 0,
            scaleMode: f.LINEAR,
            wrapMode: p.CLAMP,
            alphaMode: g.UNPACK,
            target: u.TEXTURE_2D,
            format: l.RGBA,
            type: c.UNSIGNED_BYTE
        },
        Pe._globalBatch = 0;
        class Ie {
            constructor() {
                this.texArray = null,
                this.blend = 0,
                this.type = h.TRIANGLES,
                this.start = 0,
                this.size = 0,
                this.data = null
            }
        }
        let Me = 0;
        class De {
            constructor(t, e=!0, r=!1) {
                this.data = t || new Float32Array(1),
                this._glBuffers = {},
                this._updateID = 0,
                this.index = r,
                this.static = e,
                this.id = Me++,
                this.disposeRunner = new we("disposeBuffer")
            }
            update(t) {
                t instanceof Array && (t = new Float32Array(t)),
                this.data = t || this.data,
                this._updateID++
            }
            dispose() {
                this.disposeRunner.emit(this, !1)
            }
            destroy() {
                this.dispose(),
                this.data = null
            }
            set index(t) {
                this.type = t ? E.ELEMENT_ARRAY_BUFFER : E.ARRAY_BUFFER
            }
            get index() {
                return this.type === E.ELEMENT_ARRAY_BUFFER
            }
            static from(t) {
                return t instanceof Array && (t = new Float32Array(t)),
                new De(t)
            }
        }
        class Oe {
            constructor(t, e=0, r=!1, n=c.FLOAT, i, s, o, a=1) {
                this.buffer = t,
                this.size = e,
                this.normalized = r,
                this.type = n,
                this.stride = i,
                this.start = s,
                this.instance = o,
                this.divisor = a
            }
            destroy() {
                this.buffer = null
            }
            static from(t, e, r, n, i) {
                return new Oe(t,e,r,n,i)
            }
        }
        const Be = {
            Float32Array: Float32Array,
            Uint32Array: Uint32Array,
            Int32Array: Int32Array,
            Uint8Array: Uint8Array
        }
          , ke = {
            5126: 4,
            5123: 2,
            5121: 1
        };
        let Le = 0;
        const Ne = {
            Float32Array: Float32Array,
            Uint32Array: Uint32Array,
            Int32Array: Int32Array,
            Uint8Array: Uint8Array,
            Uint16Array: Uint16Array
        };
        class Fe {
            constructor(t=[], e={}) {
                this.buffers = t,
                this.indexBuffer = null,
                this.attributes = e,
                this.glVertexArrayObjects = {},
                this.id = Le++,
                this.instanced = !1,
                this.instanceCount = 1,
                this.disposeRunner = new we("disposeGeometry"),
                this.refCount = 0
            }
            addAttribute(t, e, r=0, n=!1, i, s, o, a=!1) {
                if (!e)
                    throw new Error("You must pass a buffer when creating an attribute");
                e instanceof De || (e instanceof Array && (e = new Float32Array(e)),
                e = new De(e));
                const h = t.split("|");
                if (h.length > 1) {
                    for (let t = 0; t < h.length; t++)
                        this.addAttribute(h[t], e, r, n, i);
                    return this
                }
                let l = this.buffers.indexOf(e);
                return -1 === l && (this.buffers.push(e),
                l = this.buffers.length - 1),
                this.attributes[t] = new Oe(l,r,n,i,s,o,a),
                this.instanced = this.instanced || a,
                this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            getBuffer(t) {
                return this.buffers[this.getAttribute(t).buffer]
            }
            addIndex(t) {
                return t instanceof De || (t instanceof Array && (t = new Uint16Array(t)),
                t = new De(t)),
                t.type = E.ELEMENT_ARRAY_BUFFER,
                this.indexBuffer = t,
                this.buffers.includes(t) || this.buffers.push(t),
                this
            }
            getIndex() {
                return this.indexBuffer
            }
            interleave() {
                if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer)
                    return this;
                const t = []
                  , e = []
                  , r = new De;
                let n;
                for (n in this.attributes) {
                    const r = this.attributes[n]
                      , i = this.buffers[r.buffer];
                    t.push(i.data),
                    e.push(r.size * ke[r.type] / 4),
                    r.buffer = 0
                }
                for (r.data = function(t, e) {
                    let r = 0
                      , n = 0;
                    const i = {};
                    for (let i = 0; i < t.length; i++)
                        n += e[i],
                        r += t[i].length;
                    const s = new ArrayBuffer(4 * r);
                    let o = null
                      , a = 0;
                    for (let r = 0; r < t.length; r++) {
                        const h = e[r]
                          , l = t[r]
                          , u = zt(l);
                        i[u] || (i[u] = new Be[u](s)),
                        o = i[u];
                        for (let t = 0; t < l.length; t++)
                            o[(t / h | 0) * n + a + t % h] = l[t];
                        a += h
                    }
                    return new Float32Array(s)
                }(t, e),
                n = 0; n < this.buffers.length; n++)
                    this.buffers[n] !== this.indexBuffer && this.buffers[n].destroy();
                return this.buffers = [r],
                this.indexBuffer && this.buffers.push(this.indexBuffer),
                this
            }
            getSize() {
                for (const t in this.attributes) {
                    const e = this.attributes[t];
                    return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
                }
                return 0
            }
            dispose() {
                this.disposeRunner.emit(this, !1)
            }
            destroy() {
                this.dispose(),
                this.buffers = null,
                this.indexBuffer = null,
                this.attributes = null
            }
            clone() {
                const t = new Fe;
                for (let e = 0; e < this.buffers.length; e++)
                    t.buffers[e] = new De(this.buffers[e].data.slice(0));
                for (const e in this.attributes) {
                    const r = this.attributes[e];
                    t.attributes[e] = new Oe(r.buffer,r.size,r.normalized,r.type,r.stride,r.start,r.instance)
                }
                return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)],
                t.indexBuffer.type = E.ELEMENT_ARRAY_BUFFER),
                t
            }
            static merge(t) {
                const e = new Fe
                  , r = []
                  , n = []
                  , i = [];
                let s;
                for (let e = 0; e < t.length; e++) {
                    s = t[e];
                    for (let t = 0; t < s.buffers.length; t++)
                        n[t] = n[t] || 0,
                        n[t] += s.buffers[t].data.length,
                        i[t] = 0
                }
                for (let t = 0; t < s.buffers.length; t++)
                    r[t] = new (Ne[zt(s.buffers[t].data)])(n[t]),
                    e.buffers[t] = new De(r[t]);
                for (let e = 0; e < t.length; e++) {
                    s = t[e];
                    for (let t = 0; t < s.buffers.length; t++)
                        r[t].set(s.buffers[t].data, i[t]),
                        i[t] += s.buffers[t].data.length
                }
                if (e.attributes = s.attributes,
                s.indexBuffer) {
                    e.indexBuffer = e.buffers[s.buffers.indexOf(s.indexBuffer)],
                    e.indexBuffer.type = E.ELEMENT_ARRAY_BUFFER;
                    let r = 0
                      , n = 0
                      , i = 0
                      , o = 0;
                    for (let t = 0; t < s.buffers.length; t++)
                        if (s.buffers[t] !== s.indexBuffer) {
                            o = t;
                            break
                        }
                    for (const t in s.attributes) {
                        const e = s.attributes[t];
                        (0 | e.buffer) === o && (n += e.size * ke[e.type] / 4)
                    }
                    for (let s = 0; s < t.length; s++) {
                        const a = t[s].indexBuffer.data;
                        for (let t = 0; t < a.length; t++)
                            e.indexBuffer.data[t + i] += r;
                        r += t[s].buffers[o].data.length / n,
                        i += a.length
                    }
                }
                return e
            }
        }
        class Ue extends Fe {
            constructor(t=!1) {
                super(),
                this._buffer = new De(null,t,!1),
                this._indexBuffer = new De(null,t,!0),
                this.addAttribute("aVertexPosition", this._buffer, 2, !1, c.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, c.FLOAT).addAttribute("aColor", this._buffer, 4, !0, c.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, c.FLOAT).addIndex(this._indexBuffer)
            }
        }
        const Ge = 2 * Math.PI
          , je = 180 / Math.PI
          , ze = Math.PI / 180;
        var He = (t => (t[t.POLY = 0] = "POLY",
        t[t.RECT = 1] = "RECT",
        t[t.CIRC = 2] = "CIRC",
        t[t.ELIP = 3] = "ELIP",
        t[t.RREC = 4] = "RREC",
        t))(He || {});
        class $e {
            constructor(t=0, e=0) {
                this.x = 0,
                this.y = 0,
                this.x = t,
                this.y = e
            }
            clone() {
                return new $e(this.x,this.y)
            }
            copyFrom(t) {
                return this.set(t.x, t.y),
                this
            }
            copyTo(t) {
                return t.set(this.x, this.y),
                t
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            set(t=0, e=t) {
                return this.x = t,
                this.y = e,
                this
            }
            toString() {
                return `[@pixi/math:Point x=${this.x} y=${this.y}]`
            }
        }
        const Xe = [new $e, new $e, new $e, new $e];
        class Ve {
            constructor(t=0, e=0, r=0, n=0) {
                this.x = Number(t),
                this.y = Number(e),
                this.width = Number(r),
                this.height = Number(n),
                this.type = He.RECT
            }
            get left() {
                return this.x
            }
            get right() {
                return this.x + this.width
            }
            get top() {
                return this.y
            }
            get bottom() {
                return this.y + this.height
            }
            static get EMPTY() {
                return new Ve(0,0,0,0)
            }
            clone() {
                return new Ve(this.x,this.y,this.width,this.height)
            }
            copyFrom(t) {
                return this.x = t.x,
                this.y = t.y,
                this.width = t.width,
                this.height = t.height,
                this
            }
            copyTo(t) {
                return t.x = this.x,
                t.y = this.y,
                t.width = this.width,
                t.height = this.height,
                t
            }
            contains(t, e) {
                return !(this.width <= 0 || this.height <= 0) && t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height
            }
            intersects(t, e) {
                if (!e) {
                    const e = this.x < t.x ? t.x : this.x;
                    if ((this.right > t.right ? t.right : this.right) <= e)
                        return !1;
                    const r = this.y < t.y ? t.y : this.y;
                    return (this.bottom > t.bottom ? t.bottom : this.bottom) > r
                }
                const r = this.left
                  , n = this.right
                  , i = this.top
                  , s = this.bottom;
                if (n <= r || s <= i)
                    return !1;
                const o = Xe[0].set(t.left, t.top)
                  , a = Xe[1].set(t.left, t.bottom)
                  , h = Xe[2].set(t.right, t.top)
                  , l = Xe[3].set(t.right, t.bottom);
                if (h.x <= o.x || a.y <= o.y)
                    return !1;
                const u = Math.sign(e.a * e.d - e.b * e.c);
                if (0 === u)
                    return !1;
                if (e.apply(o, o),
                e.apply(a, a),
                e.apply(h, h),
                e.apply(l, l),
                Math.max(o.x, a.x, h.x, l.x) <= r || Math.min(o.x, a.x, h.x, l.x) >= n || Math.max(o.y, a.y, h.y, l.y) <= i || Math.min(o.y, a.y, h.y, l.y) >= s)
                    return !1;
                const c = u * (a.y - o.y)
                  , d = u * (o.x - a.x)
                  , f = c * r + d * i
                  , p = c * n + d * i
                  , m = c * r + d * s
                  , g = c * n + d * s;
                if (Math.max(f, p, m, g) <= c * o.x + d * o.y || Math.min(f, p, m, g) >= c * l.x + d * l.y)
                    return !1;
                const v = u * (o.y - h.y)
                  , y = u * (h.x - o.x)
                  , _ = v * r + y * i
                  , x = v * n + y * i
                  , b = v * r + y * s
                  , E = v * n + y * s;
                return !(Math.max(_, x, b, E) <= v * o.x + y * o.y || Math.min(_, x, b, E) >= v * l.x + y * l.y)
            }
            pad(t=0, e=t) {
                return this.x -= t,
                this.y -= e,
                this.width += 2 * t,
                this.height += 2 * e,
                this
            }
            fit(t) {
                const e = Math.max(this.x, t.x)
                  , r = Math.min(this.x + this.width, t.x + t.width)
                  , n = Math.max(this.y, t.y)
                  , i = Math.min(this.y + this.height, t.y + t.height);
                return this.x = e,
                this.width = Math.max(r - e, 0),
                this.y = n,
                this.height = Math.max(i - n, 0),
                this
            }
            ceil(t=1, e=.001) {
                const r = Math.ceil((this.x + this.width - e) * t) / t
                  , n = Math.ceil((this.y + this.height - e) * t) / t;
                return this.x = Math.floor((this.x + e) * t) / t,
                this.y = Math.floor((this.y + e) * t) / t,
                this.width = r - this.x,
                this.height = n - this.y,
                this
            }
            enlarge(t) {
                const e = Math.min(this.x, t.x)
                  , r = Math.max(this.x + this.width, t.x + t.width)
                  , n = Math.min(this.y, t.y)
                  , i = Math.max(this.y + this.height, t.y + t.height);
                return this.x = e,
                this.width = r - e,
                this.y = n,
                this.height = i - n,
                this
            }
            toString() {
                return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
            }
        }
        class We {
            constructor(t=0, e=0, r=0) {
                this.x = t,
                this.y = e,
                this.radius = r,
                this.type = He.CIRC
            }
            clone() {
                return new We(this.x,this.y,this.radius)
            }
            contains(t, e) {
                if (this.radius <= 0)
                    return !1;
                const r = this.radius * this.radius;
                let n = this.x - t
                  , i = this.y - e;
                return n *= n,
                i *= i,
                n + i <= r
            }
            getBounds() {
                return new Ve(this.x - this.radius,this.y - this.radius,2 * this.radius,2 * this.radius)
            }
            toString() {
                return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
            }
        }
        class Ye {
            constructor(t=0, e=0, r=0, n=0) {
                this.x = t,
                this.y = e,
                this.width = r,
                this.height = n,
                this.type = He.ELIP
            }
            clone() {
                return new Ye(this.x,this.y,this.width,this.height)
            }
            contains(t, e) {
                if (this.width <= 0 || this.height <= 0)
                    return !1;
                let r = (t - this.x) / this.width
                  , n = (e - this.y) / this.height;
                return r *= r,
                n *= n,
                r + n <= 1
            }
            getBounds() {
                return new Ve(this.x - this.width,this.y - this.height,this.width,this.height)
            }
            toString() {
                return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
            }
        }
        class qe {
            constructor(...t) {
                let e = Array.isArray(t[0]) ? t[0] : t;
                if ("number" != typeof e[0]) {
                    const t = [];
                    for (let r = 0, n = e.length; r < n; r++)
                        t.push(e[r].x, e[r].y);
                    e = t
                }
                this.points = e,
                this.type = He.POLY,
                this.closeStroke = !0
            }
            clone() {
                const t = this.points.slice()
                  , e = new qe(t);
                return e.closeStroke = this.closeStroke,
                e
            }
            contains(t, e) {
                let r = !1;
                const n = this.points.length / 2;
                for (let i = 0, s = n - 1; i < n; s = i++) {
                    const n = this.points[2 * i]
                      , o = this.points[2 * i + 1]
                      , a = this.points[2 * s]
                      , h = this.points[2 * s + 1];
                    o > e != h > e && t < (e - o) / (h - o) * (a - n) + n && (r = !r)
                }
                return r
            }
            toString() {
                return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce(( (t, e) => `${t}, ${e}`), "")}]`
            }
        }
        class Ke {
            constructor(t=0, e=0, r=0, n=0, i=20) {
                this.x = t,
                this.y = e,
                this.width = r,
                this.height = n,
                this.radius = i,
                this.type = He.RREC
            }
            clone() {
                return new Ke(this.x,this.y,this.width,this.height,this.radius)
            }
            contains(t, e) {
                if (this.width <= 0 || this.height <= 0)
                    return !1;
                if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
                    const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                    if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r)
                        return !0;
                    let n = t - (this.x + r)
                      , i = e - (this.y + r);
                    const s = r * r;
                    if (n * n + i * i <= s)
                        return !0;
                    if (n = t - (this.x + this.width - r),
                    n * n + i * i <= s)
                        return !0;
                    if (i = e - (this.y + this.height - r),
                    n * n + i * i <= s)
                        return !0;
                    if (n = t - (this.x + r),
                    n * n + i * i <= s)
                        return !0
                }
                return !1
            }
            toString() {
                return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
            }
        }
        class Ze {
            constructor(t=1, e=0, r=0, n=1, i=0, s=0) {
                this.array = null,
                this.a = t,
                this.b = e,
                this.c = r,
                this.d = n,
                this.tx = i,
                this.ty = s
            }
            fromArray(t) {
                this.a = t[0],
                this.b = t[1],
                this.c = t[3],
                this.d = t[4],
                this.tx = t[2],
                this.ty = t[5]
            }
            set(t, e, r, n, i, s) {
                return this.a = t,
                this.b = e,
                this.c = r,
                this.d = n,
                this.tx = i,
                this.ty = s,
                this
            }
            toArray(t, e) {
                this.array || (this.array = new Float32Array(9));
                const r = e || this.array;
                return t ? (r[0] = this.a,
                r[1] = this.b,
                r[2] = 0,
                r[3] = this.c,
                r[4] = this.d,
                r[5] = 0,
                r[6] = this.tx,
                r[7] = this.ty,
                r[8] = 1) : (r[0] = this.a,
                r[1] = this.c,
                r[2] = this.tx,
                r[3] = this.b,
                r[4] = this.d,
                r[5] = this.ty,
                r[6] = 0,
                r[7] = 0,
                r[8] = 1),
                r
            }
            apply(t, e) {
                e = e || new $e;
                const r = t.x
                  , n = t.y;
                return e.x = this.a * r + this.c * n + this.tx,
                e.y = this.b * r + this.d * n + this.ty,
                e
            }
            applyInverse(t, e) {
                e = e || new $e;
                const r = 1 / (this.a * this.d + this.c * -this.b)
                  , n = t.x
                  , i = t.y;
                return e.x = this.d * r * n + -this.c * r * i + (this.ty * this.c - this.tx * this.d) * r,
                e.y = this.a * r * i + -this.b * r * n + (-this.ty * this.a + this.tx * this.b) * r,
                e
            }
            translate(t, e) {
                return this.tx += t,
                this.ty += e,
                this
            }
            scale(t, e) {
                return this.a *= t,
                this.d *= e,
                this.c *= t,
                this.b *= e,
                this.tx *= t,
                this.ty *= e,
                this
            }
            rotate(t) {
                const e = Math.cos(t)
                  , r = Math.sin(t)
                  , n = this.a
                  , i = this.c
                  , s = this.tx;
                return this.a = n * e - this.b * r,
                this.b = n * r + this.b * e,
                this.c = i * e - this.d * r,
                this.d = i * r + this.d * e,
                this.tx = s * e - this.ty * r,
                this.ty = s * r + this.ty * e,
                this
            }
            append(t) {
                const e = this.a
                  , r = this.b
                  , n = this.c
                  , i = this.d;
                return this.a = t.a * e + t.b * n,
                this.b = t.a * r + t.b * i,
                this.c = t.c * e + t.d * n,
                this.d = t.c * r + t.d * i,
                this.tx = t.tx * e + t.ty * n + this.tx,
                this.ty = t.tx * r + t.ty * i + this.ty,
                this
            }
            setTransform(t, e, r, n, i, s, o, a, h) {
                return this.a = Math.cos(o + h) * i,
                this.b = Math.sin(o + h) * i,
                this.c = -Math.sin(o - a) * s,
                this.d = Math.cos(o - a) * s,
                this.tx = t - (r * this.a + n * this.c),
                this.ty = e - (r * this.b + n * this.d),
                this
            }
            prepend(t) {
                const e = this.tx;
                if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
                    const e = this.a
                      , r = this.c;
                    this.a = e * t.a + this.b * t.c,
                    this.b = e * t.b + this.b * t.d,
                    this.c = r * t.a + this.d * t.c,
                    this.d = r * t.b + this.d * t.d
                }
                return this.tx = e * t.a + this.ty * t.c + t.tx,
                this.ty = e * t.b + this.ty * t.d + t.ty,
                this
            }
            decompose(t) {
                const e = this.a
                  , r = this.b
                  , n = this.c
                  , i = this.d
                  , s = t.pivot
                  , o = -Math.atan2(-n, i)
                  , a = Math.atan2(r, e)
                  , h = Math.abs(o + a);
                return h < 1e-5 || Math.abs(Ge - h) < 1e-5 ? (t.rotation = a,
                t.skew.x = t.skew.y = 0) : (t.rotation = 0,
                t.skew.x = o,
                t.skew.y = a),
                t.scale.x = Math.sqrt(e * e + r * r),
                t.scale.y = Math.sqrt(n * n + i * i),
                t.position.x = this.tx + (s.x * e + s.y * n),
                t.position.y = this.ty + (s.x * r + s.y * i),
                t
            }
            invert() {
                const t = this.a
                  , e = this.b
                  , r = this.c
                  , n = this.d
                  , i = this.tx
                  , s = t * n - e * r;
                return this.a = n / s,
                this.b = -e / s,
                this.c = -r / s,
                this.d = t / s,
                this.tx = (r * this.ty - n * i) / s,
                this.ty = -(t * this.ty - e * i) / s,
                this
            }
            identity() {
                return this.a = 1,
                this.b = 0,
                this.c = 0,
                this.d = 1,
                this.tx = 0,
                this.ty = 0,
                this
            }
            clone() {
                const t = new Ze;
                return t.a = this.a,
                t.b = this.b,
                t.c = this.c,
                t.d = this.d,
                t.tx = this.tx,
                t.ty = this.ty,
                t
            }
            copyTo(t) {
                return t.a = this.a,
                t.b = this.b,
                t.c = this.c,
                t.d = this.d,
                t.tx = this.tx,
                t.ty = this.ty,
                t
            }
            copyFrom(t) {
                return this.a = t.a,
                this.b = t.b,
                this.c = t.c,
                this.d = t.d,
                this.tx = t.tx,
                this.ty = t.ty,
                this
            }
            toString() {
                return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
            }
            static get IDENTITY() {
                return new Ze
            }
            static get TEMP_MATRIX() {
                return new Ze
            }
        }
        const Je = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
          , Qe = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
          , tr = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
          , er = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
          , rr = []
          , nr = []
          , ir = Math.sign;
        !function() {
            for (let t = 0; t < 16; t++) {
                const e = [];
                rr.push(e);
                for (let r = 0; r < 16; r++) {
                    const n = ir(Je[t] * Je[r] + tr[t] * Qe[r])
                      , i = ir(Qe[t] * Je[r] + er[t] * Qe[r])
                      , s = ir(Je[t] * tr[r] + tr[t] * er[r])
                      , o = ir(Qe[t] * tr[r] + er[t] * er[r]);
                    for (let t = 0; t < 16; t++)
                        if (Je[t] === n && Qe[t] === i && tr[t] === s && er[t] === o) {
                            e.push(t);
                            break
                        }
                }
            }
            for (let t = 0; t < 16; t++) {
                const e = new Ze;
                e.set(Je[t], Qe[t], tr[t], er[t], 0, 0),
                nr.push(e)
            }
        }();
        const sr = {
            E: 0,
            SE: 1,
            S: 2,
            SW: 3,
            W: 4,
            NW: 5,
            N: 6,
            NE: 7,
            MIRROR_VERTICAL: 8,
            MAIN_DIAGONAL: 10,
            MIRROR_HORIZONTAL: 12,
            REVERSE_DIAGONAL: 14,
            uX: t => Je[t],
            uY: t => Qe[t],
            vX: t => tr[t],
            vY: t => er[t],
            inv: t => 8 & t ? 15 & t : 7 & -t,
            add: (t, e) => rr[t][e],
            sub: (t, e) => rr[t][sr.inv(e)],
            rotate180: t => 4 ^ t,
            isVertical: t => 2 == (3 & t),
            byDirection: (t, e) => 2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? sr.S : sr.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? sr.E : sr.W : e > 0 ? t > 0 ? sr.SE : sr.SW : t > 0 ? sr.NE : sr.NW,
            matrixAppendRotationInv: (t, e, r=0, n=0) => {
                const i = nr[sr.inv(e)];
                i.tx = r,
                i.ty = n,
                t.append(i)
            }
        };
        class or {
            constructor(t, e, r=0, n=0) {
                this._x = r,
                this._y = n,
                this.cb = t,
                this.scope = e
            }
            clone(t=this.cb, e=this.scope) {
                return new or(t,e,this._x,this._y)
            }
            set(t=0, e=t) {
                return this._x === t && this._y === e || (this._x = t,
                this._y = e,
                this.cb.call(this.scope)),
                this
            }
            copyFrom(t) {
                return this._x === t.x && this._y === t.y || (this._x = t.x,
                this._y = t.y,
                this.cb.call(this.scope)),
                this
            }
            copyTo(t) {
                return t.set(this._x, this._y),
                t
            }
            equals(t) {
                return t.x === this._x && t.y === this._y
            }
            toString() {
                return `[@pixi/math:ObservablePoint x=0 y=0 scope=${this.scope}]`
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x !== t && (this._x = t,
                this.cb.call(this.scope))
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y !== t && (this._y = t,
                this.cb.call(this.scope))
            }
        }
        const ar = class {
            constructor() {
                this.worldTransform = new Ze,
                this.localTransform = new Ze,
                this.position = new or(this.onChange,this,0,0),
                this.scale = new or(this.onChange,this,1,1),
                this.pivot = new or(this.onChange,this,0,0),
                this.skew = new or(this.updateSkew,this,0,0),
                this._rotation = 0,
                this._cx = 1,
                this._sx = 0,
                this._cy = 0,
                this._sy = 1,
                this._localID = 0,
                this._currentLocalID = 0,
                this._worldID = 0,
                this._parentID = 0
            }
            onChange() {
                this._localID++
            }
            updateSkew() {
                this._cx = Math.cos(this._rotation + this.skew.y),
                this._sx = Math.sin(this._rotation + this.skew.y),
                this._cy = -Math.sin(this._rotation - this.skew.x),
                this._sy = Math.cos(this._rotation - this.skew.x),
                this._localID++
            }
            toString() {
                return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
            }
            updateLocalTransform() {
                const t = this.localTransform;
                this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x,
                t.b = this._sx * this.scale.x,
                t.c = this._cy * this.scale.y,
                t.d = this._sy * this.scale.y,
                t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c),
                t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d),
                this._currentLocalID = this._localID,
                this._parentID = -1)
            }
            updateTransform(t) {
                const e = this.localTransform;
                if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x,
                e.b = this._sx * this.scale.x,
                e.c = this._cy * this.scale.y,
                e.d = this._sy * this.scale.y,
                e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c),
                e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d),
                this._currentLocalID = this._localID,
                this._parentID = -1),
                this._parentID !== t._worldID) {
                    const r = t.worldTransform
                      , n = this.worldTransform;
                    n.a = e.a * r.a + e.b * r.c,
                    n.b = e.a * r.b + e.b * r.d,
                    n.c = e.c * r.a + e.d * r.c,
                    n.d = e.c * r.b + e.d * r.d,
                    n.tx = e.tx * r.a + e.ty * r.c + r.tx,
                    n.ty = e.tx * r.b + e.ty * r.d + r.ty,
                    this._parentID = t._worldID,
                    this._worldID++
                }
            }
            setFromMatrix(t) {
                t.decompose(this),
                this._localID++
            }
            get rotation() {
                return this._rotation
            }
            set rotation(t) {
                this._rotation !== t && (this._rotation = t,
                this.updateSkew())
            }
        }
        ;
        let hr = ar;
        hr.IDENTITY = new ar;
        const lr = [{
            test: t => "float" === t.type && 1 === t.size && !t.isArray,
            code: t => `\n            if(uv["${t}"] !== ud["${t}"].value)\n            {\n                ud["${t}"].value = uv["${t}"]\n                gl.uniform1f(ud["${t}"].location, uv["${t}"])\n            }\n            `
        }, {
            test: (t, e) => !("sampler2D" !== t.type && "samplerCube" !== t.type && "sampler2DArray" !== t.type || 1 !== t.size || t.isArray || null != e && void 0 === e.castToBaseTexture),
            code: t => `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv["${t}"], t);\n\n            if(ud["${t}"].value !== t)\n            {\n                ud["${t}"].value = t;\n                gl.uniform1i(ud["${t}"].location, t);\n; // eslint-disable-line max-len\n            }`
        }, {
            test: (t, e) => "mat3" === t.type && 1 === t.size && !t.isArray && void 0 !== e.a,
            code: t => `\n            gl.uniformMatrix3fv(ud["${t}"].location, false, uv["${t}"].toArray(true));\n            `,
            codeUbo: t => `\n                var ${t}_matrix = uv.${t}.toArray(true);\n\n                data[offset] = ${t}_matrix[0];\n                data[offset+1] = ${t}_matrix[1];\n                data[offset+2] = ${t}_matrix[2];\n        \n                data[offset + 4] = ${t}_matrix[3];\n                data[offset + 5] = ${t}_matrix[4];\n                data[offset + 6] = ${t}_matrix[5];\n        \n                data[offset + 8] = ${t}_matrix[6];\n                data[offset + 9] = ${t}_matrix[7];\n                data[offset + 10] = ${t}_matrix[8];\n            `
        }, {
            test: (t, e) => "vec2" === t.type && 1 === t.size && !t.isArray && void 0 !== e.x,
            code: t => `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["${t}"].location, v.x, v.y);\n                }`,
            codeUbo: t => `\n                v = uv.${t};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `
        }, {
            test: t => "vec2" === t.type && 1 === t.size && !t.isArray,
            code: t => `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["${t}"].location, v[0], v[1]);\n                }\n            `
        }, {
            test: (t, e) => "vec4" === t.type && 1 === t.size && !t.isArray && void 0 !== e.width,
            code: t => `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["${t}"].location, v.x, v.y, v.width, v.height)\n                }`,
            codeUbo: t => `\n                    v = uv.${t};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `
        }, {
            test: (t, e) => "vec4" === t.type && 1 === t.size && !t.isArray && void 0 !== e.red,
            code: t => `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n                    cv[3] = v.alpha;\n                    gl.uniform4f(ud["${t}"].location, v.red, v.green, v.blue, v.alpha)\n                }`,
            codeUbo: t => `\n                    v = uv.${t};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                    data[offset+3] = v.alpha;\n                `
        }, {
            test: (t, e) => "vec3" === t.type && 1 === t.size && !t.isArray && void 0 !== e.red,
            code: t => `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n    \n                    gl.uniform3f(ud["${t}"].location, v.red, v.green, v.blue)\n                }`,
            codeUbo: t => `\n                    v = uv.${t};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                `
        }, {
            test: t => "vec4" === t.type && 1 === t.size && !t.isArray,
            code: t => `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["${t}"].location, v[0], v[1], v[2], v[3])\n                }`
        }]
          , ur = {
            float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
            vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
            vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
            vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
            int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
            ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
            ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
            ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
            uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
            uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
            uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
            uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
            bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
            bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
            bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
            bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
            mat2: "gl.uniformMatrix2fv(location, false, v)",
            mat3: "gl.uniformMatrix3fv(location, false, v)",
            mat4: "gl.uniformMatrix4fv(location, false, v)",
            sampler2D: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
            samplerCube: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
            sampler2DArray: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }"
        }
          , cr = {
            float: "gl.uniform1fv(location, v)",
            vec2: "gl.uniform2fv(location, v)",
            vec3: "gl.uniform3fv(location, v)",
            vec4: "gl.uniform4fv(location, v)",
            mat4: "gl.uniformMatrix4fv(location, false, v)",
            mat3: "gl.uniformMatrix3fv(location, false, v)",
            mat2: "gl.uniformMatrix2fv(location, false, v)",
            int: "gl.uniform1iv(location, v)",
            ivec2: "gl.uniform2iv(location, v)",
            ivec3: "gl.uniform3iv(location, v)",
            ivec4: "gl.uniform4iv(location, v)",
            uint: "gl.uniform1uiv(location, v)",
            uvec2: "gl.uniform2uiv(location, v)",
            uvec3: "gl.uniform3uiv(location, v)",
            uvec4: "gl.uniform4uiv(location, v)",
            bool: "gl.uniform1iv(location, v)",
            bvec2: "gl.uniform2iv(location, v)",
            bvec3: "gl.uniform3iv(location, v)",
            bvec4: "gl.uniform4iv(location, v)",
            sampler2D: "gl.uniform1iv(location, v)",
            samplerCube: "gl.uniform1iv(location, v)",
            sampler2DArray: "gl.uniform1iv(location, v)"
        }
          , dr = {};
        let fr, pr = dr;
        const mr = {
            float: 1,
            vec2: 2,
            vec3: 3,
            vec4: 4,
            int: 1,
            ivec2: 2,
            ivec3: 3,
            ivec4: 4,
            uint: 1,
            uvec2: 2,
            uvec3: 3,
            uvec4: 4,
            bool: 1,
            bvec2: 2,
            bvec3: 3,
            bvec4: 4,
            mat2: 4,
            mat3: 9,
            mat4: 16,
            sampler2D: 1
        };
        function gr(t) {
            return mr[t]
        }
        let vr = null;
        const yr = {
            FLOAT: "float",
            FLOAT_VEC2: "vec2",
            FLOAT_VEC3: "vec3",
            FLOAT_VEC4: "vec4",
            INT: "int",
            INT_VEC2: "ivec2",
            INT_VEC3: "ivec3",
            INT_VEC4: "ivec4",
            UNSIGNED_INT: "uint",
            UNSIGNED_INT_VEC2: "uvec2",
            UNSIGNED_INT_VEC3: "uvec3",
            UNSIGNED_INT_VEC4: "uvec4",
            BOOL: "bool",
            BOOL_VEC2: "bvec2",
            BOOL_VEC3: "bvec3",
            BOOL_VEC4: "bvec4",
            FLOAT_MAT2: "mat2",
            FLOAT_MAT3: "mat3",
            FLOAT_MAT4: "mat4",
            SAMPLER_2D: "sampler2D",
            INT_SAMPLER_2D: "sampler2D",
            UNSIGNED_INT_SAMPLER_2D: "sampler2D",
            SAMPLER_CUBE: "samplerCube",
            INT_SAMPLER_CUBE: "samplerCube",
            UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
            SAMPLER_2D_ARRAY: "sampler2DArray",
            INT_SAMPLER_2D_ARRAY: "sampler2DArray",
            UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
        };
        function _r(t, e) {
            if (!vr) {
                const e = Object.keys(yr);
                vr = {};
                for (let r = 0; r < e.length; ++r) {
                    const n = e[r];
                    vr[t[n]] = yr[n]
                }
            }
            return vr[e]
        }
        function xr(t, e, r) {
            if ("precision" !== t.substring(0, 9)) {
                let n = e;
                return e === _.HIGH && r !== _.HIGH && (n = _.MEDIUM),
                `precision ${n} float;\n${t}`
            }
            return r !== _.HIGH && "precision highp" === t.substring(0, 15) ? t.replace("precision highp", "precision mediump") : t
        }
        let br = 0;
        const Er = {}
          , Tr = class {
            constructor(t, e, r="pixi-shader", n={}) {
                this.extra = {},
                this.id = br++,
                this.vertexSrc = t || Tr.defaultVertexSrc,
                this.fragmentSrc = e || Tr.defaultFragmentSrc,
                this.vertexSrc = this.vertexSrc.trim(),
                this.fragmentSrc = this.fragmentSrc.trim(),
                this.extra = n,
                "#version" !== this.vertexSrc.substring(0, 8) && (r = r.replace(/\s+/g, "-"),
                Er[r] ? (Er[r]++,
                r += `-${Er[r]}`) : Er[r] = 1,
                this.vertexSrc = `#define SHADER_NAME ${r}\n${this.vertexSrc}`,
                this.fragmentSrc = `#define SHADER_NAME ${r}\n${this.fragmentSrc}`,
                this.vertexSrc = xr(this.vertexSrc, Tr.defaultVertexPrecision, _.HIGH),
                this.fragmentSrc = xr(this.fragmentSrc, Tr.defaultFragmentPrecision, function() {
                    if (!fr) {
                        fr = _.MEDIUM;
                        const t = function() {
                            if (pr === dr || pr?.isContextLost()) {
                                const t = w.ADAPTER.createCanvas();
                                let e;
                                w.PREFER_ENV >= i.WEBGL2 && (e = t.getContext("webgl2", {})),
                                e || (e = t.getContext("webgl", {}) || t.getContext("experimental-webgl", {}),
                                e ? e.getExtension("WEBGL_draw_buffers") : e = null),
                                pr = e
                            }
                            return pr
                        }();
                        if (t && t.getShaderPrecisionFormat) {
                            const e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
                            fr = e.precision ? _.HIGH : _.MEDIUM
                        }
                    }
                    return fr
                }())),
                this.glPrograms = {},
                this.syncUniforms = null
            }
            static get defaultVertexSrc() {
                return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"
            }
            static get defaultFragmentSrc() {
                return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"
            }
            static from(t, e, r) {
                const n = t + e;
                let i = te[n];
                return i || (te[n] = i = new Tr(t,e,r)),
                i
            }
        }
        ;
        let wr = Tr;
        wr.defaultVertexPrecision = _.HIGH,
        wr.defaultFragmentPrecision = z.apple.device ? _.HIGH : _.MEDIUM;
        let Sr = 0;
        class Ar {
            constructor(t, e, r) {
                this.group = !0,
                this.syncUniforms = {},
                this.dirtyId = 0,
                this.id = Sr++,
                this.static = !!e,
                this.ubo = !!r,
                t instanceof De ? (this.buffer = t,
                this.buffer.type = E.UNIFORM_BUFFER,
                this.autoManage = !1,
                this.ubo = !0) : (this.uniforms = t,
                this.ubo && (this.buffer = new De(new Float32Array(1)),
                this.buffer.type = E.UNIFORM_BUFFER,
                this.autoManage = !0))
            }
            update() {
                this.dirtyId++,
                !this.autoManage && this.buffer && this.buffer.update()
            }
            add(t, e, r) {
                if (this.ubo)
                    throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
                this.uniforms[t] = new Ar(e,r)
            }
            static from(t, e, r) {
                return new Ar(t,e,r)
            }
            static uboFrom(t, e) {
                return new Ar(t,e ?? !0,!0)
            }
        }
        class Cr {
            constructor(t, e) {
                this.uniformBindCount = 0,
                this.program = t,
                this.uniformGroup = e ? e instanceof Ar ? e : new Ar(e) : new Ar({}),
                this.disposeRunner = new we("disposeShader")
            }
            checkUniformExists(t, e) {
                if (e.uniforms[t])
                    return !0;
                for (const r in e.uniforms) {
                    const n = e.uniforms[r];
                    if (n.group && this.checkUniformExists(t, n))
                        return !0
                }
                return !1
            }
            destroy() {
                this.uniformGroup = null,
                this.disposeRunner.emit(this),
                this.disposeRunner.destroy()
            }
            get uniforms() {
                return this.uniformGroup.uniforms
            }
            static from(t, e, r) {
                const n = wr.from(t, e);
                return new Cr(n,r)
            }
        }
        class Rr {
            constructor(t, e) {
                if (this.vertexSrc = t,
                this.fragTemplate = e,
                this.programCache = {},
                this.defaultGroupCache = {},
                !e.includes("%count%"))
                    throw new Error('Fragment template must contain "%count%".');
                if (!e.includes("%forloop%"))
                    throw new Error('Fragment template must contain "%forloop%".')
            }
            generateShader(t) {
                if (!this.programCache[t]) {
                    const e = new Int32Array(t);
                    for (let r = 0; r < t; r++)
                        e[r] = r;
                    this.defaultGroupCache[t] = Ar.from({
                        uSamplers: e
                    }, !0);
                    let r = this.fragTemplate;
                    r = r.replace(/%count%/gi, `${t}`),
                    r = r.replace(/%forloop%/gi, this.generateSampleSrc(t)),
                    this.programCache[t] = new wr(this.vertexSrc,r)
                }
                const e = {
                    tint: new Float32Array([1, 1, 1, 1]),
                    translationMatrix: new Ze,
                    default: this.defaultGroupCache[t]
                };
                return new Cr(this.programCache[t],e)
            }
            generateSampleSrc(t) {
                let e = "";
                e += "\n",
                e += "\n";
                for (let r = 0; r < t; r++)
                    r > 0 && (e += "\nelse "),
                    r < t - 1 && (e += `if(vTextureId < ${r}.5)`),
                    e += "\n{",
                    e += `\n\tcolor = texture2D(uSamplers[${r}], vTextureCoord);`,
                    e += "\n}";
                return e += "\n",
                e += "\n",
                e
            }
        }
        class Pr {
            constructor() {
                this.elements = [],
                this.ids = [],
                this.count = 0
            }
            clear() {
                for (let t = 0; t < this.count; t++)
                    this.elements[t] = null;
                this.count = 0
            }
        }
        class Ir {
            constructor(t) {
                this.renderer = t
            }
            flush() {}
            destroy() {
                this.renderer = null
            }
            start() {}
            stop() {
                this.flush()
            }
            render(t) {}
        }
        const Mr = class extends Ir {
            constructor(t) {
                super(t),
                this.setShaderGenerator(),
                this.geometryClass = Ue,
                this.vertexSize = 6,
                this.state = be.for2d(),
                this.size = 4 * Mr.defaultBatchSize,
                this._vertexCount = 0,
                this._indexCount = 0,
                this._bufferedElements = [],
                this._bufferedTextures = [],
                this._bufferSize = 0,
                this._shader = null,
                this._packedGeometries = [],
                this._packedGeometryPoolSize = 2,
                this._flushId = 0,
                this._aBuffers = {},
                this._iBuffers = {},
                this.maxTextures = 1,
                this.renderer.on("prerender", this.onPrerender, this),
                t.runners.contextChange.add(this),
                this._dcIndex = 0,
                this._aIndex = 0,
                this._iIndex = 0,
                this._attributeBuffer = null,
                this._indexBuffer = null,
                this._tempBoundTextures = []
            }
            static get defaultMaxTextures() {
                return this._defaultMaxTextures = this._defaultMaxTextures ?? function(t) {
                    let e = !0;
                    const r = w.ADAPTER.getNavigator();
                    if (z.tablet || z.phone) {
                        if (z.apple.device) {
                            const t = r.userAgent.match(/OS (\d+)_(\d+)?/);
                            t && parseInt(t[1], 10) < 11 && (e = !1)
                        }
                        if (z.android.device) {
                            const t = r.userAgent.match(/Android\s([0-9.]*)/);
                            t && parseInt(t[1], 10) < 7 && (e = !1)
                        }
                    }
                    return e ? 32 : 4
                }(),
                this._defaultMaxTextures
            }
            static set defaultMaxTextures(t) {
                this._defaultMaxTextures = t
            }
            static get canUploadSameBuffer() {
                return this._canUploadSameBuffer = this._canUploadSameBuffer ?? !z.apple.device,
                this._canUploadSameBuffer
            }
            static set canUploadSameBuffer(t) {
                this._canUploadSameBuffer = t
            }
            get MAX_TEXTURES() {
                return Z("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"),
                this.maxTextures
            }
            static get defaultVertexSrc() {
                return "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n"
            }
            static get defaultFragmentTemplate() {
                return "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n"
            }
            setShaderGenerator({vertex: t=Mr.defaultVertexSrc, fragment: e=Mr.defaultFragmentTemplate}={}) {
                this.shaderGenerator = new Rr(t,e)
            }
            contextChange() {
                const t = this.renderer.gl;
                w.PREFER_ENV === i.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), Mr.defaultMaxTextures),
                this.maxTextures = function(t, e) {
                    if (0 === t)
                        throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
                    const r = e.createShader(e.FRAGMENT_SHADER);
                    for (; ; ) {
                        const n = _e.replace(/%forloop%/gi, xe(t));
                        if (e.shaderSource(r, n),
                        e.compileShader(r),
                        e.getShaderParameter(r, e.COMPILE_STATUS))
                            break;
                        t = t / 2 | 0
                    }
                    return t
                }(this.maxTextures, t)),
                this._shader = this.shaderGenerator.generateShader(this.maxTextures);
                for (let t = 0; t < this._packedGeometryPoolSize; t++)
                    this._packedGeometries[t] = new this.geometryClass;
                this.initFlushBuffers()
            }
            initFlushBuffers() {
                const {_drawCallPool: t, _textureArrayPool: e} = Mr
                  , r = this.size / 4
                  , n = Math.floor(r / this.maxTextures) + 1;
                for (; t.length < r; )
                    t.push(new Ie);
                for (; e.length < n; )
                    e.push(new Pr);
                for (let t = 0; t < this.maxTextures; t++)
                    this._tempBoundTextures[t] = null
            }
            onPrerender() {
                this._flushId = 0
            }
            render(t) {
                t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(),
                this._vertexCount += t.vertexData.length / 2,
                this._indexCount += t.indices.length,
                this._bufferedTextures[this._bufferSize] = t._texture.baseTexture,
                this._bufferedElements[this._bufferSize++] = t)
            }
            buildTexturesAndDrawCalls() {
                const {_bufferedTextures: t, maxTextures: e} = this
                  , r = Mr._textureArrayPool
                  , n = this.renderer.batch
                  , i = this._tempBoundTextures
                  , s = this.renderer.textureGC.count;
                let o = ++Pe._globalBatch
                  , a = 0
                  , h = r[0]
                  , l = 0;
                n.copyBoundTextures(i, e);
                for (let u = 0; u < this._bufferSize; ++u) {
                    const c = t[u];
                    t[u] = null,
                    c._batchEnabled !== o && (h.count >= e && (n.boundArray(h, i, o, e),
                    this.buildDrawCalls(h, l, u),
                    l = u,
                    h = r[++a],
                    ++o),
                    c._batchEnabled = o,
                    c.touched = s,
                    h.elements[h.count++] = c)
                }
                h.count > 0 && (n.boundArray(h, i, o, e),
                this.buildDrawCalls(h, l, this._bufferSize),
                ++a,
                ++o);
                for (let t = 0; t < i.length; t++)
                    i[t] = null;
                Pe._globalBatch = o
            }
            buildDrawCalls(t, e, r) {
                const {_bufferedElements: n, _attributeBuffer: i, _indexBuffer: s, vertexSize: o} = this
                  , a = Mr._drawCallPool;
                let h = this._dcIndex
                  , l = this._aIndex
                  , u = this._iIndex
                  , c = a[h];
                c.start = this._iIndex,
                c.texArray = t;
                for (let d = e; d < r; ++d) {
                    const r = n[d]
                      , f = r._texture.baseTexture
                      , p = kt[f.alphaMode ? 1 : 0][r.blendMode];
                    n[d] = null,
                    e < d && c.blend !== p && (c.size = u - c.start,
                    e = d,
                    c = a[++h],
                    c.texArray = t,
                    c.start = u),
                    this.packInterleavedGeometry(r, i, s, l, u),
                    l += r.vertexData.length / 2 * o,
                    u += r.indices.length,
                    c.blend = p
                }
                e < r && (c.size = u - c.start,
                ++h),
                this._dcIndex = h,
                this._aIndex = l,
                this._iIndex = u
            }
            bindAndClearTexArray(t) {
                const e = this.renderer.texture;
                for (let r = 0; r < t.count; r++)
                    e.bind(t.elements[r], t.ids[r]),
                    t.elements[r] = null;
                t.count = 0
            }
            updateGeometry() {
                const {_packedGeometries: t, _attributeBuffer: e, _indexBuffer: r} = this;
                Mr.canUploadSameBuffer ? (t[this._flushId]._buffer.update(e.rawBinaryData),
                t[this._flushId]._indexBuffer.update(r),
                this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++,
                t[this._flushId] = new this.geometryClass),
                t[this._flushId]._buffer.update(e.rawBinaryData),
                t[this._flushId]._indexBuffer.update(r),
                this.renderer.geometry.bind(t[this._flushId]),
                this.renderer.geometry.updateBuffers(),
                this._flushId++)
            }
            drawBatches() {
                const t = this._dcIndex
                  , {gl: e, state: r} = this.renderer
                  , n = Mr._drawCallPool;
                let i = null;
                for (let s = 0; s < t; s++) {
                    const {texArray: t, type: o, size: a, start: h, blend: l} = n[s];
                    i !== t && (i = t,
                    this.bindAndClearTexArray(t)),
                    this.state.blendMode = l,
                    r.set(this.state),
                    e.drawElements(o, a, e.UNSIGNED_SHORT, 2 * h)
                }
            }
            flush() {
                0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount),
                this._indexBuffer = this.getIndexBuffer(this._indexCount),
                this._aIndex = 0,
                this._iIndex = 0,
                this._dcIndex = 0,
                this.buildTexturesAndDrawCalls(),
                this.updateGeometry(),
                this.drawBatches(),
                this._bufferSize = 0,
                this._vertexCount = 0,
                this._indexCount = 0)
            }
            start() {
                this.renderer.state.set(this.state),
                this.renderer.texture.ensureSamplerType(this.maxTextures),
                this.renderer.shader.bind(this._shader),
                Mr.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
            }
            stop() {
                this.flush()
            }
            destroy() {
                for (let t = 0; t < this._packedGeometryPoolSize; t++)
                    this._packedGeometries[t] && this._packedGeometries[t].destroy();
                this.renderer.off("prerender", this.onPrerender, this),
                this._aBuffers = null,
                this._iBuffers = null,
                this._packedGeometries = null,
                this._attributeBuffer = null,
                this._indexBuffer = null,
                this._shader && (this._shader.destroy(),
                this._shader = null),
                super.destroy()
            }
            getAttributeBuffer(t) {
                const e = Xt(Math.ceil(t / 8))
                  , r = Wt(e)
                  , n = 8 * e;
                this._aBuffers.length <= r && (this._iBuffers.length = r + 1);
                let i = this._aBuffers[n];
                return i || (this._aBuffers[n] = i = new ye(n * this.vertexSize * 4)),
                i
            }
            getIndexBuffer(t) {
                const e = Xt(Math.ceil(t / 12))
                  , r = Wt(e)
                  , n = 12 * e;
                this._iBuffers.length <= r && (this._iBuffers.length = r + 1);
                let i = this._iBuffers[r];
                return i || (this._iBuffers[r] = i = new Uint16Array(n)),
                i
            }
            packInterleavedGeometry(t, e, r, n, i) {
                const {uint32View: s, float32View: o} = e
                  , a = n / this.vertexSize
                  , h = t.uvs
                  , l = t.indices
                  , u = t.vertexData
                  , c = t._texture.baseTexture._batchLocation
                  , d = Math.min(t.worldAlpha, 1)
                  , f = It.shared.setValue(t._tintRGB).toPremultiplied(d, t._texture.baseTexture.alphaMode > 0);
                for (let t = 0; t < u.length; t += 2)
                    o[n++] = u[t],
                    o[n++] = u[t + 1],
                    o[n++] = h[t],
                    o[n++] = h[t + 1],
                    s[n++] = f,
                    o[n++] = c;
                for (let t = 0; t < l.length; t++)
                    r[i++] = a + l[t]
            }
        }
        ;
        let Dr = Mr;
        Dr.defaultBatchSize = 4096,
        Dr.extension = {
            name: "batch",
            type: pe.RendererPlugin
        },
        Dr._drawCallPool = [],
        Dr._textureArrayPool = [],
        ve.add(Dr);
        const Or = class extends Cr {
            constructor(t, e, r) {
                super(wr.from(t || Or.defaultVertexSrc, e || Or.defaultFragmentSrc), r),
                this.padding = 0,
                this.resolution = Or.defaultResolution,
                this.multisample = Or.defaultMultisample,
                this.enabled = !0,
                this.autoFit = !0,
                this.state = new be
            }
            apply(t, e, r, n, i) {
                t.applyFilter(this, e, r, n)
            }
            get blendMode() {
                return this.state.blendMode
            }
            set blendMode(t) {
                this.state.blendMode = t
            }
            get resolution() {
                return this._resolution
            }
            set resolution(t) {
                this._resolution = t
            }
            static get defaultVertexSrc() {
                return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"
            }
            static get defaultFragmentSrc() {
                return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"
            }
        }
        ;
        let Br = Or;
        Br.defaultResolution = 1,
        Br.defaultMultisample = b.NONE;
        class kr {
            constructor() {
                this.clearBeforeRender = !0,
                this._backgroundColor = new It(0),
                this.alpha = 1
            }
            init(t) {
                this.clearBeforeRender = t.clearBeforeRender;
                const {backgroundColor: e, background: r, backgroundAlpha: n} = t
                  , i = r ?? e;
                void 0 !== i && (this.color = i),
                this.alpha = n
            }
            get color() {
                return this._backgroundColor.value
            }
            set color(t) {
                this._backgroundColor.setValue(t)
            }
            get alpha() {
                return this._backgroundColor.alpha
            }
            set alpha(t) {
                this._backgroundColor.setAlpha(t)
            }
            get backgroundColor() {
                return this._backgroundColor
            }
            destroy() {}
        }
        kr.defaultOptions = {
            backgroundAlpha: 1,
            backgroundColor: 0,
            clearBeforeRender: !0
        },
        kr.extension = {
            type: [pe.RendererSystem, pe.CanvasRendererSystem],
            name: "background"
        },
        ve.add(kr);
        class Lr {
            constructor(t) {
                this.renderer = t,
                this.emptyRenderer = new Ir(t),
                this.currentRenderer = this.emptyRenderer
            }
            setObjectRenderer(t) {
                this.currentRenderer !== t && (this.currentRenderer.stop(),
                this.currentRenderer = t,
                this.currentRenderer.start())
            }
            flush() {
                this.setObjectRenderer(this.emptyRenderer)
            }
            reset() {
                this.setObjectRenderer(this.emptyRenderer)
            }
            copyBoundTextures(t, e) {
                const {boundTextures: r} = this.renderer.texture;
                for (let n = e - 1; n >= 0; --n)
                    t[n] = r[n] || null,
                    t[n] && (t[n]._batchLocation = n)
            }
            boundArray(t, e, r, n) {
                const {elements: i, ids: s, count: o} = t;
                let a = 0;
                for (let t = 0; t < o; t++) {
                    const o = i[t]
                      , h = o._batchLocation;
                    if (h >= 0 && h < n && e[h] === o)
                        s[t] = h;
                    else
                        for (; a < n; ) {
                            const n = e[a];
                            if (!n || n._batchEnabled !== r || n._batchLocation !== a) {
                                s[t] = a,
                                o._batchLocation = a,
                                e[a] = o;
                                break
                            }
                            a++
                        }
                }
            }
            destroy() {
                this.renderer = null
            }
        }
        Lr.extension = {
            type: pe.RendererSystem,
            name: "batch"
        },
        ve.add(Lr);
        let Nr = 0;
        class Fr {
            constructor(t) {
                this.renderer = t,
                this.webGLVersion = 1,
                this.extensions = {},
                this.supports = {
                    uint32Indices: !1
                },
                this.handleContextLost = this.handleContextLost.bind(this),
                this.handleContextRestored = this.handleContextRestored.bind(this)
            }
            get isLost() {
                return !this.gl || this.gl.isContextLost()
            }
            contextChange(t) {
                this.gl = t,
                this.renderer.gl = t,
                this.renderer.CONTEXT_UID = Nr++
            }
            init(t) {
                if (t.context)
                    this.initFromContext(t.context);
                else {
                    const e = this.renderer.background.alpha < 1
                      , r = t.premultipliedAlpha;
                    this.preserveDrawingBuffer = t.preserveDrawingBuffer,
                    this.useContextAlpha = t.useContextAlpha,
                    this.powerPreference = t.powerPreference,
                    this.initFromOptions({
                        alpha: e,
                        premultipliedAlpha: r,
                        antialias: t.antialias,
                        stencil: !0,
                        preserveDrawingBuffer: t.preserveDrawingBuffer,
                        powerPreference: t.powerPreference
                    })
                }
            }
            initFromContext(t) {
                this.gl = t,
                this.validateContext(t),
                this.renderer.gl = t,
                this.renderer.CONTEXT_UID = Nr++,
                this.renderer.runners.contextChange.emit(t);
                const e = this.renderer.view;
                void 0 !== e.addEventListener && (e.addEventListener("webglcontextlost", this.handleContextLost, !1),
                e.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
            }
            initFromOptions(t) {
                const e = this.createContext(this.renderer.view, t);
                this.initFromContext(e)
            }
            createContext(t, e) {
                let r;
                if (w.PREFER_ENV >= i.WEBGL2 && (r = t.getContext("webgl2", e)),
                r)
                    this.webGLVersion = 2;
                else if (this.webGLVersion = 1,
                r = t.getContext("webgl", e) || t.getContext("experimental-webgl", e),
                !r)
                    throw new Error("This browser does not support WebGL. Try using the canvas renderer");
                return this.gl = r,
                this.getExtensions(),
                this.gl
            }
            getExtensions() {
                const {gl: t} = this
                  , e = {
                    loseContext: t.getExtension("WEBGL_lose_context"),
                    anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
                    floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                    s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
                    s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                    etc: t.getExtension("WEBGL_compressed_texture_etc"),
                    etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
                    pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                    atc: t.getExtension("WEBGL_compressed_texture_atc"),
                    astc: t.getExtension("WEBGL_compressed_texture_astc")
                };
                1 === this.webGLVersion ? Object.assign(this.extensions, e, {
                    drawBuffers: t.getExtension("WEBGL_draw_buffers"),
                    depthTexture: t.getExtension("WEBGL_depth_texture"),
                    vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
                    uint32ElementIndex: t.getExtension("OES_element_index_uint"),
                    floatTexture: t.getExtension("OES_texture_float"),
                    floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                    textureHalfFloat: t.getExtension("OES_texture_half_float"),
                    textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
                }) : 2 === this.webGLVersion && Object.assign(this.extensions, e, {
                    colorBufferFloat: t.getExtension("EXT_color_buffer_float")
                })
            }
            handleContextLost(t) {
                t.preventDefault(),
                setTimeout(( () => {
                    this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
                }
                ), 0)
            }
            handleContextRestored() {
                this.renderer.runners.contextChange.emit(this.gl)
            }
            destroy() {
                const t = this.renderer.view;
                this.renderer = null,
                void 0 !== t.removeEventListener && (t.removeEventListener("webglcontextlost", this.handleContextLost),
                t.removeEventListener("webglcontextrestored", this.handleContextRestored)),
                this.gl.useProgram(null),
                this.extensions.loseContext && this.extensions.loseContext.loseContext()
            }
            postrender() {
                this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
            }
            validateContext(t) {
                const e = t.getContextAttributes()
                  , r = "WebGL2RenderingContext"in globalThis && t instanceof globalThis.WebGL2RenderingContext;
                r && (this.webGLVersion = 2),
                e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
                const n = r || !!t.getExtension("OES_element_index_uint");
                this.supports.uint32Indices = n,
                n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
            }
        }
        Fr.defaultOptions = {
            context: null,
            antialias: !1,
            premultipliedAlpha: !0,
            preserveDrawingBuffer: !1,
            powerPreference: "default"
        },
        Fr.extension = {
            type: pe.RendererSystem,
            name: "context"
        },
        ve.add(Fr);
        class Ur extends Ae {
            upload(t, e, r) {
                const n = t.gl;
                n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === g.UNPACK);
                const i = e.realWidth
                  , s = e.realHeight;
                return r.width === i && r.height === s ? n.texSubImage2D(e.target, 0, 0, 0, i, s, e.format, r.type, this.data) : (r.width = i,
                r.height = s,
                n.texImage2D(e.target, 0, r.internalFormat, i, s, 0, e.format, r.type, this.data)),
                !0
            }
        }
        class Gr {
            constructor(t, e) {
                this.width = Math.round(t || 100),
                this.height = Math.round(e || 100),
                this.stencil = !1,
                this.depth = !1,
                this.dirtyId = 0,
                this.dirtyFormat = 0,
                this.dirtySize = 0,
                this.depthTexture = null,
                this.colorTextures = [],
                this.glFramebuffers = {},
                this.disposeRunner = new we("disposeFramebuffer"),
                this.multisample = b.NONE
            }
            get colorTexture() {
                return this.colorTextures[0]
            }
            addColorTexture(t=0, e) {
                return this.colorTextures[t] = e || new Pe(null,{
                    scaleMode: f.NEAREST,
                    resolution: 1,
                    mipmap: m.OFF,
                    width: this.width,
                    height: this.height
                }),
                this.dirtyId++,
                this.dirtyFormat++,
                this
            }
            addDepthTexture(t) {
                return this.depthTexture = t || new Pe(new Ur(null,{
                    width: this.width,
                    height: this.height
                }),{
                    scaleMode: f.NEAREST,
                    resolution: 1,
                    width: this.width,
                    height: this.height,
                    mipmap: m.OFF,
                    format: l.DEPTH_COMPONENT,
                    type: c.UNSIGNED_SHORT
                }),
                this.dirtyId++,
                this.dirtyFormat++,
                this
            }
            enableDepth() {
                return this.depth = !0,
                this.dirtyId++,
                this.dirtyFormat++,
                this
            }
            enableStencil() {
                return this.stencil = !0,
                this.dirtyId++,
                this.dirtyFormat++,
                this
            }
            resize(t, e) {
                if (t = Math.round(t),
                e = Math.round(e),
                t !== this.width || e !== this.height) {
                    this.width = t,
                    this.height = e,
                    this.dirtyId++,
                    this.dirtySize++;
                    for (let r = 0; r < this.colorTextures.length; r++) {
                        const n = this.colorTextures[r]
                          , i = n.resolution;
                        n.setSize(t / i, e / i)
                    }
                    if (this.depthTexture) {
                        const r = this.depthTexture.resolution;
                        this.depthTexture.setSize(t / r, e / r)
                    }
                }
            }
            dispose() {
                this.disposeRunner.emit(this, !1)
            }
            destroyDepthTexture() {
                this.depthTexture && (this.depthTexture.destroy(),
                this.depthTexture = null,
                ++this.dirtyId,
                ++this.dirtyFormat)
            }
        }
        class jr extends Pe {
            constructor(t={}) {
                "number" == typeof t && (t = {
                    width: arguments[0],
                    height: arguments[1],
                    scaleMode: arguments[2],
                    resolution: arguments[3]
                }),
                t.width = t.width || 100,
                t.height = t.height || 100,
                t.multisample ?? (t.multisample = b.NONE),
                super(null, t),
                this.mipmap = m.OFF,
                this.valid = !0,
                this._clear = new It([0, 0, 0, 0]),
                this.framebuffer = new Gr(this.realWidth,this.realHeight).addColorTexture(0, this),
                this.framebuffer.multisample = t.multisample,
                this.maskStack = [],
                this.filterStack = [{}]
            }
            set clearColor(t) {
                this._clear.setValue(t)
            }
            get clearColor() {
                return this._clear.value
            }
            get clear() {
                return this._clear
            }
            resize(t, e) {
                this.framebuffer.resize(t * this.resolution, e * this.resolution),
                this.setRealSize(this.framebuffer.width, this.framebuffer.height)
            }
            dispose() {
                this.framebuffer.dispose(),
                super.dispose()
            }
            destroy() {
                super.destroy(),
                this.framebuffer.destroyDepthTexture(),
                this.framebuffer = null
            }
        }
        class zr extends Se {
            constructor(t) {
                const e = t;
                super(e.naturalWidth || e.videoWidth || e.width, e.naturalHeight || e.videoHeight || e.height),
                this.source = t,
                this.noSubImage = !1
            }
            static crossOrigin(t, e, r) {
                void 0 !== r || e.startsWith("data:") ? !1 !== r && (t.crossOrigin = "string" == typeof r ? r : "anonymous") : t.crossOrigin = de(e)
            }
            upload(t, e, r, n) {
                const i = t.gl
                  , s = e.realWidth
                  , o = e.realHeight;
                if (n = n || this.source,
                "undefined" != typeof HTMLImageElement && n instanceof HTMLImageElement) {
                    if (!n.complete || 0 === n.naturalWidth)
                        return !1
                } else if ("undefined" != typeof HTMLVideoElement && n instanceof HTMLVideoElement && n.readyState <= 1 && 0 === n.buffered.length)
                    return !1;
                return i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === g.UNPACK),
                this.noSubImage || e.target !== i.TEXTURE_2D || r.width !== s || r.height !== o ? (r.width = s,
                r.height = o,
                i.texImage2D(e.target, 0, r.internalFormat, e.format, r.type, n)) : i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, e.format, r.type, n),
                !0
            }
            update() {
                if (this.destroyed)
                    return;
                const t = this.source
                  , e = t.naturalWidth || t.videoWidth || t.width
                  , r = t.naturalHeight || t.videoHeight || t.height;
                this.resize(e, r),
                super.update()
            }
            dispose() {
                this.source = null
            }
        }
        class Hr extends zr {
            constructor(t, e) {
                if (e = e || {},
                "string" == typeof t) {
                    const r = new Image;
                    zr.crossOrigin(r, t, e.crossorigin),
                    r.src = t,
                    t = r
                }
                super(t),
                !t.complete && this._width && this._height && (this._width = 0,
                this._height = 0),
                this.url = t.src,
                this._process = null,
                this.preserveBitmap = !1,
                this.createBitmap = (e.createBitmap ?? w.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap,
                this.alphaMode = "number" == typeof e.alphaMode ? e.alphaMode : null,
                this.bitmap = null,
                this._load = null,
                !1 !== e.autoLoad && this.load()
            }
            load(t) {
                return this._load || (void 0 !== t && (this.createBitmap = t),
                this._load = new Promise(( (t, e) => {
                    const r = this.source;
                    this.url = r.src;
                    const n = () => {
                        this.destroyed || (r.onload = null,
                        r.onerror = null,
                        this.resize(r.width, r.height),
                        this._load = null,
                        this.createBitmap ? t(this.process()) : t(this))
                    }
                    ;
                    r.complete && r.src ? n() : (r.onload = n,
                    r.onerror = t => {
                        e(t),
                        this.onError.emit(t)
                    }
                    )
                }
                ))),
                this._load
            }
            process() {
                const t = this.source;
                if (null !== this._process)
                    return this._process;
                if (null !== this.bitmap || !globalThis.createImageBitmap)
                    return Promise.resolve(this);
                const e = globalThis.createImageBitmap
                  , r = !t.crossOrigin || "anonymous" === t.crossOrigin;
                return this._process = fetch(t.src, {
                    mode: r ? "cors" : "no-cors"
                }).then((t => t.blob())).then((r => e(r, 0, 0, t.width, t.height, {
                    premultiplyAlpha: null === this.alphaMode || this.alphaMode === g.UNPACK ? "premultiply" : "none"
                }))).then((t => this.destroyed ? Promise.reject() : (this.bitmap = t,
                this.update(),
                this._process = null,
                Promise.resolve(this)))),
                this._process
            }
            upload(t, e, r) {
                if ("number" == typeof this.alphaMode && (e.alphaMode = this.alphaMode),
                !this.createBitmap)
                    return super.upload(t, e, r);
                if (!this.bitmap && (this.process(),
                !this.bitmap))
                    return !1;
                if (super.upload(t, e, r, this.bitmap),
                !this.preserveBitmap) {
                    let t = !0;
                    const n = e._glTextures;
                    for (const i in n) {
                        const s = n[i];
                        if (s !== r && s.dirtyId !== e.dirtyId) {
                            t = !1;
                            break
                        }
                    }
                    t && (this.bitmap.close && this.bitmap.close(),
                    this.bitmap = null)
                }
                return !0
            }
            dispose() {
                this.source.onload = null,
                this.source.onerror = null,
                super.dispose(),
                this.bitmap && (this.bitmap.close(),
                this.bitmap = null),
                this._process = null,
                this._load = null
            }
            static test(t) {
                return "undefined" != typeof HTMLImageElement && ("string" == typeof t || t instanceof HTMLImageElement)
            }
        }
        class $r {
            constructor() {
                this.x0 = 0,
                this.y0 = 0,
                this.x1 = 1,
                this.y1 = 0,
                this.x2 = 1,
                this.y2 = 1,
                this.x3 = 0,
                this.y3 = 1,
                this.uvsFloat32 = new Float32Array(8)
            }
            set(t, e, r) {
                const n = e.width
                  , i = e.height;
                if (r) {
                    const e = t.width / 2 / n
                      , s = t.height / 2 / i
                      , o = t.x / n + e
                      , a = t.y / i + s;
                    r = sr.add(r, sr.NW),
                    this.x0 = o + e * sr.uX(r),
                    this.y0 = a + s * sr.uY(r),
                    r = sr.add(r, 2),
                    this.x1 = o + e * sr.uX(r),
                    this.y1 = a + s * sr.uY(r),
                    r = sr.add(r, 2),
                    this.x2 = o + e * sr.uX(r),
                    this.y2 = a + s * sr.uY(r),
                    r = sr.add(r, 2),
                    this.x3 = o + e * sr.uX(r),
                    this.y3 = a + s * sr.uY(r)
                } else
                    this.x0 = t.x / n,
                    this.y0 = t.y / i,
                    this.x1 = (t.x + t.width) / n,
                    this.y1 = t.y / i,
                    this.x2 = (t.x + t.width) / n,
                    this.y2 = (t.y + t.height) / i,
                    this.x3 = t.x / n,
                    this.y3 = (t.y + t.height) / i;
                this.uvsFloat32[0] = this.x0,
                this.uvsFloat32[1] = this.y0,
                this.uvsFloat32[2] = this.x1,
                this.uvsFloat32[3] = this.y1,
                this.uvsFloat32[4] = this.x2,
                this.uvsFloat32[5] = this.y2,
                this.uvsFloat32[6] = this.x3,
                this.uvsFloat32[7] = this.y3
            }
            toString() {
                return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
            }
        }
        const Xr = new $r;
        function Vr(t) {
            t.destroy = function() {}
            ,
            t.on = function() {}
            ,
            t.once = function() {}
            ,
            t.emit = function() {}
        }
        class Wr extends H {
            constructor(t, e, r, n, i, s, o) {
                if (super(),
                this.noFrame = !1,
                e || (this.noFrame = !0,
                e = new Ve(0,0,1,1)),
                t instanceof Wr && (t = t.baseTexture),
                this.baseTexture = t,
                this._frame = e,
                this.trim = n,
                this.valid = !1,
                this._uvs = Xr,
                this.uvMatrix = null,
                this.orig = r || e,
                this._rotate = Number(i || 0),
                !0 === i)
                    this._rotate = 2;
                else if (this._rotate % 2 != 0)
                    throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
                this.defaultAnchor = s ? new $e(s.x,s.y) : new $e(0,0),
                this.defaultBorders = o,
                this._updateID = 0,
                this.textureCacheIds = [],
                t.valid ? this.noFrame ? t.valid && this.onBaseTextureUpdated(t) : this.frame = e : t.once("loaded", this.onBaseTextureUpdated, this),
                this.noFrame && t.on("update", this.onBaseTextureUpdated, this)
            }
            update() {
                this.baseTexture.resource && this.baseTexture.resource.update()
            }
            onBaseTextureUpdated(t) {
                if (this.noFrame) {
                    if (!this.baseTexture.valid)
                        return;
                    this._frame.width = t.width,
                    this._frame.height = t.height,
                    this.valid = !0,
                    this.updateUvs()
                } else
                    this.frame = this._frame;
                this.emit("update", this)
            }
            destroy(t) {
                if (this.baseTexture) {
                    if (t) {
                        const {resource: t} = this.baseTexture;
                        t?.url && ee[t.url] && Wr.removeFromCache(t.url),
                        this.baseTexture.destroy()
                    }
                    this.baseTexture.off("loaded", this.onBaseTextureUpdated, this),
                    this.baseTexture.off("update", this.onBaseTextureUpdated, this),
                    this.baseTexture = null
                }
                this._frame = null,
                this._uvs = null,
                this.trim = null,
                this.orig = null,
                this.valid = !1,
                Wr.removeFromCache(this),
                this.textureCacheIds = null
            }
            clone() {
                const t = this._frame.clone()
                  , e = this._frame === this.orig ? t : this.orig.clone()
                  , r = new Wr(this.baseTexture,!this.noFrame && t,e,this.trim?.clone(),this.rotate,this.defaultAnchor,this.defaultBorders);
                return this.noFrame && (r._frame = t),
                r
            }
            updateUvs() {
                this._uvs === Xr && (this._uvs = new $r),
                this._uvs.set(this._frame, this.baseTexture, this.rotate),
                this._updateID++
            }
            static from(t, e={}, r=w.STRICT_TEXTURE_CACHE) {
                const n = "string" == typeof t;
                let i = null;
                if (n)
                    i = t;
                else if (t instanceof Pe) {
                    if (!t.cacheId) {
                        const r = e?.pixiIdPrefix || "pixiid";
                        t.cacheId = `${r}-${Zt()}`,
                        Pe.addToCache(t, t.cacheId)
                    }
                    i = t.cacheId
                } else {
                    if (!t._pixiId) {
                        const r = e?.pixiIdPrefix || "pixiid";
                        t._pixiId = `${r}_${Zt()}`
                    }
                    i = t._pixiId
                }
                let s = ee[i];
                if (n && r && !s)
                    throw new Error(`The cacheId "${i}" does not exist in TextureCache.`);
                return s || t instanceof Pe ? !s && t instanceof Pe && (s = new Wr(t),
                Wr.addToCache(s, i)) : (e.resolution || (e.resolution = fe(t)),
                s = new Wr(new Pe(t,e)),
                s.baseTexture.cacheId = i,
                Pe.addToCache(s.baseTexture, i),
                Wr.addToCache(s, i)),
                s
            }
            static fromURL(t, e) {
                const r = Object.assign({
                    autoLoad: !1
                }, e?.resourceOptions)
                  , n = Wr.from(t, Object.assign({
                    resourceOptions: r
                }, e), !1)
                  , i = n.baseTexture.resource;
                return n.baseTexture.valid ? Promise.resolve(n) : i.load().then(( () => Promise.resolve(n)))
            }
            static fromBuffer(t, e, r, n) {
                return new Wr(Pe.fromBuffer(t, e, r, n))
            }
            static fromLoader(t, e, r, n) {
                const i = new Pe(t,Object.assign({
                    scaleMode: Pe.defaultOptions.scaleMode,
                    resolution: fe(e)
                }, n))
                  , {resource: s} = i;
                s instanceof Hr && (s.url = e);
                const o = new Wr(i);
                return r || (r = e),
                Pe.addToCache(o.baseTexture, r),
                Wr.addToCache(o, r),
                r !== e && (Pe.addToCache(o.baseTexture, e),
                Wr.addToCache(o, e)),
                o.baseTexture.valid ? Promise.resolve(o) : new Promise((t => {
                    o.baseTexture.once("loaded", ( () => t(o)))
                }
                ))
            }
            static addToCache(t, e) {
                e && (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e),
                ee[e] && ee[e] !== t && console.warn(`Texture added to the cache with an id [${e}] that already had an entry`),
                ee[e] = t)
            }
            static removeFromCache(t) {
                if ("string" == typeof t) {
                    const e = ee[t];
                    if (e) {
                        const r = e.textureCacheIds.indexOf(t);
                        return r > -1 && e.textureCacheIds.splice(r, 1),
                        delete ee[t],
                        e
                    }
                } else if (t?.textureCacheIds) {
                    for (let e = 0; e < t.textureCacheIds.length; ++e)
                        ee[t.textureCacheIds[e]] === t && delete ee[t.textureCacheIds[e]];
                    return t.textureCacheIds.length = 0,
                    t
                }
                return null
            }
            get resolution() {
                return this.baseTexture.resolution
            }
            get frame() {
                return this._frame
            }
            set frame(t) {
                this._frame = t,
                this.noFrame = !1;
                const {x: e, y: r, width: n, height: i} = t
                  , s = e + n > this.baseTexture.width
                  , o = r + i > this.baseTexture.height;
                if (s || o) {
                    const t = s && o ? "and" : "or"
                      , a = `X: ${e} + ${n} = ${e + n} > ${this.baseTexture.width}`
                      , h = `Y: ${r} + ${i} = ${r + i} > ${this.baseTexture.height}`;
                    throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${a} ${t} ${h}`)
                }
                this.valid = n && i && this.baseTexture.valid,
                this.trim || this.rotate || (this.orig = t),
                this.valid && this.updateUvs()
            }
            get rotate() {
                return this._rotate
            }
            set rotate(t) {
                this._rotate = t,
                this.valid && this.updateUvs()
            }
            get width() {
                return this.orig.width
            }
            get height() {
                return this.orig.height
            }
            castToBaseTexture() {
                return this.baseTexture
            }
            static get EMPTY() {
                return Wr._EMPTY || (Wr._EMPTY = new Wr(new Pe),
                Vr(Wr._EMPTY),
                Vr(Wr._EMPTY.baseTexture)),
                Wr._EMPTY
            }
            static get WHITE() {
                if (!Wr._WHITE) {
                    const t = w.ADAPTER.createCanvas(16, 16)
                      , e = t.getContext("2d");
                    t.width = 16,
                    t.height = 16,
                    e.fillStyle = "white",
                    e.fillRect(0, 0, 16, 16),
                    Wr._WHITE = new Wr(Pe.from(t)),
                    Vr(Wr._WHITE),
                    Vr(Wr._WHITE.baseTexture)
                }
                return Wr._WHITE
            }
        }
        class Yr extends Wr {
            constructor(t, e) {
                super(t, e),
                this.valid = !0,
                this.filterFrame = null,
                this.filterPoolKey = null,
                this.updateUvs()
            }
            get framebuffer() {
                return this.baseTexture.framebuffer
            }
            get multisample() {
                return this.framebuffer.multisample
            }
            set multisample(t) {
                this.framebuffer.multisample = t
            }
            resize(t, e, r=!0) {
                const n = this.baseTexture.resolution
                  , i = Math.round(t * n) / n
                  , s = Math.round(e * n) / n;
                this.valid = i > 0 && s > 0,
                this._frame.width = this.orig.width = i,
                this._frame.height = this.orig.height = s,
                r && this.baseTexture.resize(i, s),
                this.updateUvs()
            }
            setResolution(t) {
                const {baseTexture: e} = this;
                e.resolution !== t && (e.setResolution(t),
                this.resize(e.width, e.height, !1))
            }
            static create(t) {
                return new Yr(new jr(t))
            }
        }
        class qr {
            constructor(t) {
                this.texturePool = {},
                this.textureOptions = t || {},
                this.enableFullScreen = !1,
                this._pixelsWidth = 0,
                this._pixelsHeight = 0
            }
            createTexture(t, e, r=b.NONE) {
                const n = new jr(Object.assign({
                    width: t,
                    height: e,
                    resolution: 1,
                    multisample: r
                }, this.textureOptions));
                return new Yr(n)
            }
            getOptimalTexture(t, e, r=1, n=b.NONE) {
                let i;
                t = Math.ceil(t * r - 1e-6),
                e = Math.ceil(e * r - 1e-6),
                this.enableFullScreen && t === this._pixelsWidth && e === this._pixelsHeight ? i = n > 1 ? -n : -1 : (i = ((65535 & (t = Xt(t))) << 16 | 65535 & (e = Xt(e))) >>> 0,
                n > 1 && (i += 4294967296 * n)),
                this.texturePool[i] || (this.texturePool[i] = []);
                let s = this.texturePool[i].pop();
                return s || (s = this.createTexture(t, e, n)),
                s.filterPoolKey = i,
                s.setResolution(r),
                s
            }
            getFilterTexture(t, e, r) {
                const n = this.getOptimalTexture(t.width, t.height, e || t.resolution, r || b.NONE);
                return n.filterFrame = t.filterFrame,
                n
            }
            returnTexture(t) {
                const e = t.filterPoolKey;
                t.filterFrame = null,
                this.texturePool[e].push(t)
            }
            returnFilterTexture(t) {
                this.returnTexture(t)
            }
            clear(t) {
                if (t = !1 !== t)
                    for (const t in this.texturePool) {
                        const e = this.texturePool[t];
                        if (e)
                            for (let t = 0; t < e.length; t++)
                                e[t].destroy(!0)
                    }
                this.texturePool = {}
            }
            setScreenSize(t) {
                if (t.width !== this._pixelsWidth || t.height !== this._pixelsHeight) {
                    this.enableFullScreen = t.width > 0 && t.height > 0;
                    for (const t in this.texturePool) {
                        if (!(Number(t) < 0))
                            continue;
                        const e = this.texturePool[t];
                        if (e)
                            for (let t = 0; t < e.length; t++)
                                e[t].destroy(!0);
                        this.texturePool[t] = []
                    }
                    this._pixelsWidth = t.width,
                    this._pixelsHeight = t.height
                }
            }
        }
        qr.SCREEN_KEY = -1;
        class Kr extends Fe {
            constructor() {
                super(),
                this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
            }
        }
        class Zr extends Fe {
            constructor() {
                super(),
                this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]),
                this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                this.vertexBuffer = new De(this.vertices),
                this.uvBuffer = new De(this.uvs),
                this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
            }
            map(t, e) {
                let r = 0
                  , n = 0;
                return this.uvs[0] = r,
                this.uvs[1] = n,
                this.uvs[2] = r + e.width / t.width,
                this.uvs[3] = n,
                this.uvs[4] = r + e.width / t.width,
                this.uvs[5] = n + e.height / t.height,
                this.uvs[6] = r,
                this.uvs[7] = n + e.height / t.height,
                r = e.x,
                n = e.y,
                this.vertices[0] = r,
                this.vertices[1] = n,
                this.vertices[2] = r + e.width,
                this.vertices[3] = n,
                this.vertices[4] = r + e.width,
                this.vertices[5] = n + e.height,
                this.vertices[6] = r,
                this.vertices[7] = n + e.height,
                this.invalidate(),
                this
            }
            invalidate() {
                return this.vertexBuffer._updateID++,
                this.uvBuffer._updateID++,
                this
            }
        }
        class Jr {
            constructor() {
                this.renderTexture = null,
                this.target = null,
                this.legacy = !1,
                this.resolution = 1,
                this.multisample = b.NONE,
                this.sourceFrame = new Ve,
                this.destinationFrame = new Ve,
                this.bindingSourceFrame = new Ve,
                this.bindingDestinationFrame = new Ve,
                this.filters = [],
                this.transform = null
            }
            clear() {
                this.target = null,
                this.filters = null,
                this.renderTexture = null
            }
        }
        const Qr = [new $e, new $e, new $e, new $e]
          , tn = new Ze;
        class en {
            constructor(t) {
                this.renderer = t,
                this.defaultFilterStack = [{}],
                this.texturePool = new qr,
                this.statePool = [],
                this.quad = new Kr,
                this.quadUv = new Zr,
                this.tempRect = new Ve,
                this.activeState = {},
                this.globalUniforms = new Ar({
                    outputFrame: new Ve,
                    inputSize: new Float32Array(4),
                    inputPixel: new Float32Array(4),
                    inputClamp: new Float32Array(4),
                    resolution: 1,
                    filterArea: new Float32Array(4),
                    filterClamp: new Float32Array(4)
                },!0),
                this.forceClear = !1,
                this.useMaxPadding = !1
            }
            init() {
                this.texturePool.setScreenSize(this.renderer.view)
            }
            push(t, e) {
                const r = this.renderer
                  , n = this.defaultFilterStack
                  , i = this.statePool.pop() || new Jr
                  , s = this.renderer.renderTexture;
                let o = e[0].resolution
                  , a = e[0].multisample
                  , h = e[0].padding
                  , l = e[0].autoFit
                  , u = e[0].legacy ?? !0;
                for (let t = 1; t < e.length; t++) {
                    const r = e[t];
                    o = Math.min(o, r.resolution),
                    a = Math.min(a, r.multisample),
                    h = this.useMaxPadding ? Math.max(h, r.padding) : h + r.padding,
                    l = l && r.autoFit,
                    u = u || (r.legacy ?? !0)
                }
                1 === n.length && (this.defaultFilterStack[0].renderTexture = s.current),
                n.push(i),
                i.resolution = o,
                i.multisample = a,
                i.legacy = u,
                i.target = t,
                i.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
                i.sourceFrame.pad(h);
                const c = this.tempRect.copyFrom(s.sourceFrame);
                r.projection.transform && this.transformAABB(tn.copyFrom(r.projection.transform).invert(), c),
                l ? (i.sourceFrame.fit(c),
                (i.sourceFrame.width <= 0 || i.sourceFrame.height <= 0) && (i.sourceFrame.width = 0,
                i.sourceFrame.height = 0)) : i.sourceFrame.intersects(c) || (i.sourceFrame.width = 0,
                i.sourceFrame.height = 0),
                this.roundFrame(i.sourceFrame, s.current ? s.current.resolution : r.resolution, s.sourceFrame, s.destinationFrame, r.projection.transform),
                i.renderTexture = this.getOptimalFilterTexture(i.sourceFrame.width, i.sourceFrame.height, o, a),
                i.filters = e,
                i.destinationFrame.width = i.renderTexture.width,
                i.destinationFrame.height = i.renderTexture.height;
                const d = this.tempRect;
                d.x = 0,
                d.y = 0,
                d.width = i.sourceFrame.width,
                d.height = i.sourceFrame.height,
                i.renderTexture.filterFrame = i.sourceFrame,
                i.bindingSourceFrame.copyFrom(s.sourceFrame),
                i.bindingDestinationFrame.copyFrom(s.destinationFrame),
                i.transform = r.projection.transform,
                r.projection.transform = null,
                s.bind(i.renderTexture, i.sourceFrame, d),
                r.framebuffer.clear(0, 0, 0, 0)
            }
            pop() {
                const t = this.defaultFilterStack
                  , e = t.pop()
                  , r = e.filters;
                this.activeState = e;
                const n = this.globalUniforms.uniforms;
                n.outputFrame = e.sourceFrame,
                n.resolution = e.resolution;
                const i = n.inputSize
                  , s = n.inputPixel
                  , o = n.inputClamp;
                if (i[0] = e.destinationFrame.width,
                i[1] = e.destinationFrame.height,
                i[2] = 1 / i[0],
                i[3] = 1 / i[1],
                s[0] = Math.round(i[0] * e.resolution),
                s[1] = Math.round(i[1] * e.resolution),
                s[2] = 1 / s[0],
                s[3] = 1 / s[1],
                o[0] = .5 * s[2],
                o[1] = .5 * s[3],
                o[2] = e.sourceFrame.width * i[2] - .5 * s[2],
                o[3] = e.sourceFrame.height * i[3] - .5 * s[3],
                e.legacy) {
                    const t = n.filterArea;
                    t[0] = e.destinationFrame.width,
                    t[1] = e.destinationFrame.height,
                    t[2] = e.sourceFrame.x,
                    t[3] = e.sourceFrame.y,
                    n.filterClamp = n.inputClamp
                }
                this.globalUniforms.update();
                const a = t[t.length - 1];
                if (this.renderer.framebuffer.blit(),
                1 === r.length)
                    r[0].apply(this, e.renderTexture, a.renderTexture, v.BLEND, e),
                    this.returnFilterTexture(e.renderTexture);
                else {
                    let t = e.renderTexture
                      , n = this.getOptimalFilterTexture(t.width, t.height, e.resolution);
                    n.filterFrame = t.filterFrame;
                    let i = 0;
                    for (i = 0; i < r.length - 1; ++i) {
                        1 === i && e.multisample > 1 && (n = this.getOptimalFilterTexture(t.width, t.height, e.resolution),
                        n.filterFrame = t.filterFrame),
                        r[i].apply(this, t, n, v.CLEAR, e);
                        const s = t;
                        t = n,
                        n = s
                    }
                    r[i].apply(this, t, a.renderTexture, v.BLEND, e),
                    i > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture),
                    this.returnFilterTexture(t),
                    this.returnFilterTexture(n)
                }
                e.clear(),
                this.statePool.push(e)
            }
            bindAndClear(t, e=v.CLEAR) {
                const {renderTexture: r, state: n} = this.renderer;
                if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null,
                t?.filterFrame) {
                    const e = this.tempRect;
                    e.x = 0,
                    e.y = 0,
                    e.width = t.filterFrame.width,
                    e.height = t.filterFrame.height,
                    r.bind(t, t.filterFrame, e)
                } else
                    t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? r.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
                const i = 1 & n.stateId || this.forceClear;
                (e === v.CLEAR || e === v.BLIT && i) && this.renderer.framebuffer.clear(0, 0, 0, 0)
            }
            applyFilter(t, e, r, n) {
                const i = this.renderer;
                i.state.set(t.state),
                this.bindAndClear(r, n),
                t.uniforms.uSampler = e,
                t.uniforms.filterGlobals = this.globalUniforms,
                i.shader.bind(t),
                t.legacy = !!t.program.attributeData.aTextureCoord,
                t.legacy ? (this.quadUv.map(e._frame, e.filterFrame),
                i.geometry.bind(this.quadUv),
                i.geometry.draw(h.TRIANGLES)) : (i.geometry.bind(this.quad),
                i.geometry.draw(h.TRIANGLE_STRIP))
            }
            calculateSpriteMatrix(t, e) {
                const {sourceFrame: r, destinationFrame: n} = this.activeState
                  , {orig: i} = e._texture
                  , s = t.set(n.width, 0, 0, n.height, r.x, r.y)
                  , o = e.worldTransform.copyTo(Ze.TEMP_MATRIX);
                return o.invert(),
                s.prepend(o),
                s.scale(1 / i.width, 1 / i.height),
                s.translate(e.anchor.x, e.anchor.y),
                s
            }
            destroy() {
                this.renderer = null,
                this.texturePool.clear(!1)
            }
            getOptimalFilterTexture(t, e, r=1, n=b.NONE) {
                return this.texturePool.getOptimalTexture(t, e, r, n)
            }
            getFilterTexture(t, e, r) {
                if ("number" == typeof t) {
                    const r = t;
                    t = e,
                    e = r
                }
                t = t || this.activeState.renderTexture;
                const n = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, r || b.NONE);
                return n.filterFrame = t.filterFrame,
                n
            }
            returnFilterTexture(t) {
                this.texturePool.returnTexture(t)
            }
            emptyPool() {
                this.texturePool.clear(!0)
            }
            resize() {
                this.texturePool.setScreenSize(this.renderer.view)
            }
            transformAABB(t, e) {
                const r = Qr[0]
                  , n = Qr[1]
                  , i = Qr[2]
                  , s = Qr[3];
                r.set(e.left, e.top),
                n.set(e.left, e.bottom),
                i.set(e.right, e.top),
                s.set(e.right, e.bottom),
                t.apply(r, r),
                t.apply(n, n),
                t.apply(i, i),
                t.apply(s, s);
                const o = Math.min(r.x, n.x, i.x, s.x)
                  , a = Math.min(r.y, n.y, i.y, s.y)
                  , h = Math.max(r.x, n.x, i.x, s.x)
                  , l = Math.max(r.y, n.y, i.y, s.y);
                e.x = o,
                e.y = a,
                e.width = h - o,
                e.height = l - a
            }
            roundFrame(t, e, r, n, i) {
                if (!(t.width <= 0 || t.height <= 0 || r.width <= 0 || r.height <= 0)) {
                    if (i) {
                        const {a: t, b: e, c: r, d: n} = i;
                        if ((Math.abs(e) > 1e-4 || Math.abs(r) > 1e-4) && (Math.abs(t) > 1e-4 || Math.abs(n) > 1e-4))
                            return
                    }
                    (i = i ? tn.copyFrom(i) : tn.identity()).translate(-r.x, -r.y).scale(n.width / r.width, n.height / r.height).translate(n.x, n.y),
                    this.transformAABB(i, t),
                    t.ceil(e),
                    this.transformAABB(i.invert(), t)
                }
            }
        }
        en.extension = {
            type: pe.RendererSystem,
            name: "filter"
        },
        ve.add(en);
        class rn {
            constructor(t) {
                this.framebuffer = t,
                this.stencil = null,
                this.dirtyId = -1,
                this.dirtyFormat = -1,
                this.dirtySize = -1,
                this.multisample = b.NONE,
                this.msaaBuffer = null,
                this.blitFramebuffer = null,
                this.mipLevel = 0
            }
        }
        const nn = new Ve;
        class sn {
            constructor(t) {
                this.renderer = t,
                this.managedFramebuffers = [],
                this.unknownFramebuffer = new Gr(10,10),
                this.msaaSamples = null
            }
            contextChange() {
                this.disposeAll(!0);
                const t = this.gl = this.renderer.gl;
                if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
                this.current = this.unknownFramebuffer,
                this.viewport = new Ve,
                this.hasMRT = !0,
                this.writeDepthTexture = !0,
                1 === this.renderer.context.webGLVersion) {
                    let e = this.renderer.context.extensions.drawBuffers
                      , r = this.renderer.context.extensions.depthTexture;
                    w.PREFER_ENV === i.WEBGL_LEGACY && (e = null,
                    r = null),
                    e ? t.drawBuffers = t => e.drawBuffersWEBGL(t) : (this.hasMRT = !1,
                    t.drawBuffers = () => {}
                    ),
                    r || (this.writeDepthTexture = !1)
                } else
                    this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
            }
            bind(t, e, r=0) {
                const {gl: n} = this;
                if (t) {
                    const i = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
                    this.current !== t && (this.current = t,
                    n.bindFramebuffer(n.FRAMEBUFFER, i.framebuffer)),
                    i.mipLevel !== r && (t.dirtyId++,
                    t.dirtyFormat++,
                    i.mipLevel = r),
                    i.dirtyId !== t.dirtyId && (i.dirtyId = t.dirtyId,
                    i.dirtyFormat !== t.dirtyFormat ? (i.dirtyFormat = t.dirtyFormat,
                    i.dirtySize = t.dirtySize,
                    this.updateFramebuffer(t, r)) : i.dirtySize !== t.dirtySize && (i.dirtySize = t.dirtySize,
                    this.resizeFramebuffer(t)));
                    for (let e = 0; e < t.colorTextures.length; e++) {
                        const r = t.colorTextures[e];
                        this.renderer.texture.unbind(r.parentTextureArray || r)
                    }
                    if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
                    e) {
                        const t = e.width >> r
                          , n = e.height >> r
                          , i = t / e.width;
                        this.setViewport(e.x * i, e.y * i, t, n)
                    } else {
                        const e = t.width >> r
                          , n = t.height >> r;
                        this.setViewport(0, 0, e, n)
                    }
                } else
                    this.current && (this.current = null,
                    n.bindFramebuffer(n.FRAMEBUFFER, null)),
                    e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
            }
            setViewport(t, e, r, n) {
                const i = this.viewport;
                t = Math.round(t),
                e = Math.round(e),
                r = Math.round(r),
                n = Math.round(n),
                i.width === r && i.height === n && i.x === t && i.y === e || (i.x = t,
                i.y = e,
                i.width = r,
                i.height = n,
                this.gl.viewport(t, e, r, n))
            }
            get size() {
                return this.current ? {
                    x: 0,
                    y: 0,
                    width: this.current.width,
                    height: this.current.height
                } : {
                    x: 0,
                    y: 0,
                    width: this.renderer.width,
                    height: this.renderer.height
                }
            }
            clear(t, e, r, n, i=o.COLOR | o.DEPTH) {
                const {gl: s} = this;
                s.clearColor(t, e, r, n),
                s.clear(i)
            }
            initFramebuffer(t) {
                const {gl: e} = this
                  , r = new rn(e.createFramebuffer());
                return r.multisample = this.detectSamples(t.multisample),
                t.glFramebuffers[this.CONTEXT_UID] = r,
                this.managedFramebuffers.push(t),
                t.disposeRunner.add(this),
                r
            }
            resizeFramebuffer(t) {
                const {gl: e} = this
                  , r = t.glFramebuffers[this.CONTEXT_UID];
                r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil),
                r.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
                const n = t.colorTextures;
                let i = n.length;
                e.drawBuffers || (i = Math.min(i, 1));
                for (let s = 0; s < i; s++) {
                    const i = n[s]
                      , o = i.parentTextureArray || i;
                    this.renderer.texture.bind(o, 0),
                    0 === s && r.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer),
                    e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, o._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height))
                }
                t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
            }
            updateFramebuffer(t, e) {
                const {gl: r} = this
                  , n = t.glFramebuffers[this.CONTEXT_UID]
                  , i = t.colorTextures;
                let s = i.length;
                r.drawBuffers || (s = Math.min(s, 1)),
                n.multisample > 1 && this.canMultisampleFramebuffer(t) ? n.msaaBuffer = n.msaaBuffer || r.createRenderbuffer() : n.msaaBuffer && (r.deleteRenderbuffer(n.msaaBuffer),
                n.msaaBuffer = null,
                n.blitFramebuffer && (n.blitFramebuffer.dispose(),
                n.blitFramebuffer = null));
                const o = [];
                for (let a = 0; a < s; a++) {
                    const s = i[a]
                      , h = s.parentTextureArray || s;
                    this.renderer.texture.bind(h, 0),
                    0 === a && n.msaaBuffer ? (r.bindRenderbuffer(r.RENDERBUFFER, n.msaaBuffer),
                    r.renderbufferStorageMultisample(r.RENDERBUFFER, n.multisample, h._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height),
                    r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, n.msaaBuffer)) : (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + a, s.target, h._glTextures[this.CONTEXT_UID].texture, e),
                    o.push(r.COLOR_ATTACHMENT0 + a))
                }
                if (o.length > 1 && r.drawBuffers(o),
                t.depthTexture && this.writeDepthTexture) {
                    const n = t.depthTexture;
                    this.renderer.texture.bind(n, 0),
                    r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, n._glTextures[this.CONTEXT_UID].texture, e)
                }
                !t.stencil && !t.depth || t.depthTexture && this.writeDepthTexture ? n.stencil && (r.deleteRenderbuffer(n.stencil),
                n.stencil = null) : (n.stencil = n.stencil || r.createRenderbuffer(),
                r.bindRenderbuffer(r.RENDERBUFFER, n.stencil),
                n.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, n.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height),
                r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, n.stencil))
            }
            canMultisampleFramebuffer(t) {
                return 1 !== this.renderer.context.webGLVersion && t.colorTextures.length <= 1 && !t.depthTexture
            }
            detectSamples(t) {
                const {msaaSamples: e} = this;
                let r = b.NONE;
                if (t <= 1 || null === e)
                    return r;
                for (let n = 0; n < e.length; n++)
                    if (e[n] <= t) {
                        r = e[n];
                        break
                    }
                return 1 === r && (r = b.NONE),
                r
            }
            blit(t, e, r) {
                const {current: n, renderer: i, gl: s, CONTEXT_UID: o} = this;
                if (2 !== i.context.webGLVersion)
                    return;
                if (!n)
                    return;
                const a = n.glFramebuffers[o];
                if (!a)
                    return;
                if (!t) {
                    if (!a.msaaBuffer)
                        return;
                    const e = n.colorTextures[0];
                    if (!e)
                        return;
                    a.blitFramebuffer || (a.blitFramebuffer = new Gr(n.width,n.height),
                    a.blitFramebuffer.addColorTexture(0, e)),
                    (t = a.blitFramebuffer).colorTextures[0] !== e && (t.colorTextures[0] = e,
                    t.dirtyId++,
                    t.dirtyFormat++),
                    t.width === n.width && t.height === n.height || (t.width = n.width,
                    t.height = n.height,
                    t.dirtyId++,
                    t.dirtySize++)
                }
                e || ((e = nn).width = n.width,
                e.height = n.height),
                r || (r = e);
                const h = e.width === r.width && e.height === r.height;
                this.bind(t),
                s.bindFramebuffer(s.READ_FRAMEBUFFER, a.framebuffer),
                s.blitFramebuffer(e.left, e.top, e.right, e.bottom, r.left, r.top, r.right, r.bottom, s.COLOR_BUFFER_BIT, h ? s.NEAREST : s.LINEAR),
                s.bindFramebuffer(s.READ_FRAMEBUFFER, t.glFramebuffers[this.CONTEXT_UID].framebuffer)
            }
            disposeFramebuffer(t, e) {
                const r = t.glFramebuffers[this.CONTEXT_UID]
                  , n = this.gl;
                if (!r)
                    return;
                delete t.glFramebuffers[this.CONTEXT_UID];
                const i = this.managedFramebuffers.indexOf(t);
                i >= 0 && this.managedFramebuffers.splice(i, 1),
                t.disposeRunner.remove(this),
                e || (n.deleteFramebuffer(r.framebuffer),
                r.msaaBuffer && n.deleteRenderbuffer(r.msaaBuffer),
                r.stencil && n.deleteRenderbuffer(r.stencil)),
                r.blitFramebuffer && this.disposeFramebuffer(r.blitFramebuffer, e)
            }
            disposeAll(t) {
                const e = this.managedFramebuffers;
                this.managedFramebuffers = [];
                for (let r = 0; r < e.length; r++)
                    this.disposeFramebuffer(e[r], t)
            }
            forceStencil() {
                const t = this.current;
                if (!t)
                    return;
                const e = t.glFramebuffers[this.CONTEXT_UID];
                if (!e || e.stencil)
                    return;
                t.stencil = !0;
                const r = t.width
                  , n = t.height
                  , i = this.gl
                  , s = i.createRenderbuffer();
                i.bindRenderbuffer(i.RENDERBUFFER, s),
                e.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, e.multisample, i.DEPTH24_STENCIL8, r, n) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, r, n),
                e.stencil = s,
                i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, s)
            }
            reset() {
                this.current = this.unknownFramebuffer,
                this.viewport = new Ve
            }
            destroy() {
                this.renderer = null
            }
        }
        sn.extension = {
            type: pe.RendererSystem,
            name: "framebuffer"
        },
        ve.add(sn);
        const on = {
            5126: 4,
            5123: 2,
            5121: 1
        };
        class an {
            constructor(t) {
                this.renderer = t,
                this._activeGeometry = null,
                this._activeVao = null,
                this.hasVao = !0,
                this.hasInstance = !0,
                this.canUseUInt32ElementIndex = !1,
                this.managedGeometries = {}
            }
            contextChange() {
                this.disposeAll(!0);
                const t = this.gl = this.renderer.gl
                  , e = this.renderer.context;
                if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
                2 !== e.webGLVersion) {
                    let e = this.renderer.context.extensions.vertexArrayObject;
                    w.PREFER_ENV === i.WEBGL_LEGACY && (e = null),
                    e ? (t.createVertexArray = () => e.createVertexArrayOES(),
                    t.bindVertexArray = t => e.bindVertexArrayOES(t),
                    t.deleteVertexArray = t => e.deleteVertexArrayOES(t)) : (this.hasVao = !1,
                    t.createVertexArray = () => null,
                    t.bindVertexArray = () => null,
                    t.deleteVertexArray = () => null)
                }
                if (2 !== e.webGLVersion) {
                    const e = t.getExtension("ANGLE_instanced_arrays");
                    e ? (t.vertexAttribDivisor = (t, r) => e.vertexAttribDivisorANGLE(t, r),
                    t.drawElementsInstanced = (t, r, n, i, s) => e.drawElementsInstancedANGLE(t, r, n, i, s),
                    t.drawArraysInstanced = (t, r, n, i) => e.drawArraysInstancedANGLE(t, r, n, i)) : this.hasInstance = !1
                }
                this.canUseUInt32ElementIndex = 2 === e.webGLVersion || !!e.extensions.uint32ElementIndex
            }
            bind(t, e) {
                e = e || this.renderer.shader.shader;
                const {gl: r} = this;
                let n = t.glVertexArrayObjects[this.CONTEXT_UID]
                  , i = !1;
                n || (this.managedGeometries[t.id] = t,
                t.disposeRunner.add(this),
                t.glVertexArrayObjects[this.CONTEXT_UID] = n = {},
                i = !0);
                const s = n[e.program.id] || this.initGeometryVao(t, e, i);
                this._activeGeometry = t,
                this._activeVao !== s && (this._activeVao = s,
                this.hasVao ? r.bindVertexArray(s) : this.activateVao(t, e.program)),
                this.updateBuffers()
            }
            reset() {
                this.unbind()
            }
            updateBuffers() {
                const t = this._activeGeometry
                  , e = this.renderer.buffer;
                for (let r = 0; r < t.buffers.length; r++) {
                    const n = t.buffers[r];
                    e.update(n)
                }
            }
            checkCompatibility(t, e) {
                const r = t.attributes
                  , n = e.attributeData;
                for (const t in n)
                    if (!r[t])
                        throw new Error(`shader and geometry incompatible, geometry missing the "${t}" attribute`)
            }
            getSignature(t, e) {
                const r = t.attributes
                  , n = e.attributeData
                  , i = ["g", t.id];
                for (const t in r)
                    n[t] && i.push(t, n[t].location);
                return i.join("-")
            }
            initGeometryVao(t, e, r=!0) {
                const n = this.gl
                  , i = this.CONTEXT_UID
                  , s = this.renderer.buffer
                  , o = e.program;
                o.glPrograms[i] || this.renderer.shader.generateProgram(e),
                this.checkCompatibility(t, o);
                const a = this.getSignature(t, o)
                  , h = t.glVertexArrayObjects[this.CONTEXT_UID];
                let l = h[a];
                if (l)
                    return h[o.id] = l,
                    l;
                const u = t.buffers
                  , c = t.attributes
                  , d = {}
                  , f = {};
                for (const t in u)
                    d[t] = 0,
                    f[t] = 0;
                for (const t in c)
                    !c[t].size && o.attributeData[t] ? c[t].size = o.attributeData[t].size : c[t].size || console.warn(`PIXI Geometry attribute '${t}' size cannot be determined (likely the bound shader does not have the attribute)`),
                    d[c[t].buffer] += c[t].size * on[c[t].type];
                for (const t in c) {
                    const e = c[t]
                      , r = e.size;
                    void 0 === e.stride && (d[e.buffer] === r * on[e.type] ? e.stride = 0 : e.stride = d[e.buffer]),
                    void 0 === e.start && (e.start = f[e.buffer],
                    f[e.buffer] += r * on[e.type])
                }
                l = n.createVertexArray(),
                n.bindVertexArray(l);
                for (let t = 0; t < u.length; t++) {
                    const e = u[t];
                    s.bind(e),
                    r && e._glBuffers[i].refCount++
                }
                return this.activateVao(t, o),
                h[o.id] = l,
                h[a] = l,
                n.bindVertexArray(null),
                s.unbind(E.ARRAY_BUFFER),
                l
            }
            disposeGeometry(t, e) {
                if (!this.managedGeometries[t.id])
                    return;
                delete this.managedGeometries[t.id];
                const r = t.glVertexArrayObjects[this.CONTEXT_UID]
                  , n = this.gl
                  , i = t.buffers
                  , s = this.renderer?.buffer;
                if (t.disposeRunner.remove(this),
                r) {
                    if (s)
                        for (let t = 0; t < i.length; t++) {
                            const r = i[t]._glBuffers[this.CONTEXT_UID];
                            r && (r.refCount--,
                            0 !== r.refCount || e || s.dispose(i[t], e))
                        }
                    if (!e)
                        for (const t in r)
                            if ("g" === t[0]) {
                                const e = r[t];
                                this._activeVao === e && this.unbind(),
                                n.deleteVertexArray(e)
                            }
                    delete t.glVertexArrayObjects[this.CONTEXT_UID]
                }
            }
            disposeAll(t) {
                const e = Object.keys(this.managedGeometries);
                for (let r = 0; r < e.length; r++)
                    this.disposeGeometry(this.managedGeometries[e[r]], t)
            }
            activateVao(t, e) {
                const r = this.gl
                  , n = this.CONTEXT_UID
                  , i = this.renderer.buffer
                  , s = t.buffers
                  , o = t.attributes;
                t.indexBuffer && i.bind(t.indexBuffer);
                let a = null;
                for (const t in o) {
                    const h = o[t]
                      , l = s[h.buffer]
                      , u = l._glBuffers[n];
                    if (e.attributeData[t]) {
                        a !== u && (i.bind(l),
                        a = u);
                        const n = e.attributeData[t].location;
                        if (r.enableVertexAttribArray(n),
                        r.vertexAttribPointer(n, h.size, h.type || r.FLOAT, h.normalized, h.stride, h.start),
                        h.instance) {
                            if (!this.hasInstance)
                                throw new Error("geometry error, GPU Instancing is not supported on this device");
                            r.vertexAttribDivisor(n, h.divisor)
                        }
                    }
                }
            }
            draw(t, e, r, n) {
                const {gl: i} = this
                  , s = this._activeGeometry;
                if (s.indexBuffer) {
                    const o = s.indexBuffer.data.BYTES_PER_ELEMENT
                      , a = 2 === o ? i.UNSIGNED_SHORT : i.UNSIGNED_INT;
                    2 === o || 4 === o && this.canUseUInt32ElementIndex ? s.instanced ? i.drawElementsInstanced(t, e || s.indexBuffer.data.length, a, (r || 0) * o, n || 1) : i.drawElements(t, e || s.indexBuffer.data.length, a, (r || 0) * o) : console.warn("unsupported index buffer type: uint32")
                } else
                    s.instanced ? i.drawArraysInstanced(t, r, e || s.getSize(), n || 1) : i.drawArrays(t, r, e || s.getSize());
                return this
            }
            unbind() {
                this.gl.bindVertexArray(null),
                this._activeVao = null,
                this._activeGeometry = null
            }
            destroy() {
                this.renderer = null
            }
        }
        an.extension = {
            type: pe.RendererSystem,
            name: "geometry"
        },
        ve.add(an);
        const hn = new Ze;
        class ln {
            constructor(t, e) {
                this._texture = t,
                this.mapCoord = new Ze,
                this.uClampFrame = new Float32Array(4),
                this.uClampOffset = new Float32Array(2),
                this._textureID = -1,
                this._updateID = 0,
                this.clampOffset = 0,
                this.clampMargin = void 0 === e ? .5 : e,
                this.isSimple = !1
            }
            get texture() {
                return this._texture
            }
            set texture(t) {
                this._texture = t,
                this._textureID = -1
            }
            multiplyUvs(t, e) {
                void 0 === e && (e = t);
                const r = this.mapCoord;
                for (let n = 0; n < t.length; n += 2) {
                    const i = t[n]
                      , s = t[n + 1];
                    e[n] = i * r.a + s * r.c + r.tx,
                    e[n + 1] = i * r.b + s * r.d + r.ty
                }
                return e
            }
            update(t) {
                const e = this._texture;
                if (!e || !e.valid)
                    return !1;
                if (!t && this._textureID === e._updateID)
                    return !1;
                this._textureID = e._updateID,
                this._updateID++;
                const r = e._uvs;
                this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);
                const n = e.orig
                  , i = e.trim;
                i && (hn.set(n.width / i.width, 0, 0, n.height / i.height, -i.x / i.width, -i.y / i.height),
                this.mapCoord.append(hn));
                const s = e.baseTexture
                  , o = this.uClampFrame
                  , a = this.clampMargin / s.resolution
                  , h = this.clampOffset;
                return o[0] = (e._frame.x + a + h) / s.width,
                o[1] = (e._frame.y + a + h) / s.height,
                o[2] = (e._frame.x + e._frame.width - a + h) / s.width,
                o[3] = (e._frame.y + e._frame.height - a + h) / s.height,
                this.uClampOffset[0] = h / s.realWidth,
                this.uClampOffset[1] = h / s.realHeight,
                this.isSimple = e._frame.width === s.width && e._frame.height === s.height && 0 === e.rotate,
                !0
            }
        }
        class un extends Br {
            constructor(t, e, r) {
                let n = null;
                "string" != typeof t && void 0 === e && void 0 === r && (n = t,
                t = void 0,
                e = void 0,
                r = void 0),
                super(t || "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", e || "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", r),
                this.maskSprite = n,
                this.maskMatrix = new Ze
            }
            get maskSprite() {
                return this._maskSprite
            }
            set maskSprite(t) {
                this._maskSprite = t,
                this._maskSprite && (this._maskSprite.renderable = !1)
            }
            apply(t, e, r, n) {
                const i = this._maskSprite
                  , s = i._texture;
                s.valid && (s.uvMatrix || (s.uvMatrix = new ln(s,0)),
                s.uvMatrix.update(),
                this.uniforms.npmAlpha = s.baseTexture.alphaMode ? 0 : 1,
                this.uniforms.mask = s,
                this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, i).prepend(s.uvMatrix.mapCoord),
                this.uniforms.alpha = i.worldAlpha,
                this.uniforms.maskClamp = s.uvMatrix.uClampFrame,
                t.applyFilter(this, e, r, n))
            }
        }
        class cn {
            constructor(t=null) {
                this.type = x.NONE,
                this.autoDetect = !0,
                this.maskObject = t || null,
                this.pooled = !1,
                this.isMaskData = !0,
                this.resolution = null,
                this.multisample = Br.defaultMultisample,
                this.enabled = !0,
                this.colorMask = 15,
                this._filters = null,
                this._stencilCounter = 0,
                this._scissorCounter = 0,
                this._scissorRect = null,
                this._scissorRectLocal = null,
                this._colorMask = 15,
                this._target = null
            }
            get filter() {
                return this._filters ? this._filters[0] : null
            }
            set filter(t) {
                t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
            }
            reset() {
                this.pooled && (this.maskObject = null,
                this.type = x.NONE,
                this.autoDetect = !0),
                this._target = null,
                this._scissorRectLocal = null
            }
            copyCountersOrReset(t) {
                t ? (this._stencilCounter = t._stencilCounter,
                this._scissorCounter = t._scissorCounter,
                this._scissorRect = t._scissorRect) : (this._stencilCounter = 0,
                this._scissorCounter = 0,
                this._scissorRect = null)
            }
        }
        class dn {
            constructor(t) {
                this.renderer = t,
                this.enableScissor = !0,
                this.alphaMaskPool = [],
                this.maskDataPool = [],
                this.maskStack = [],
                this.alphaMaskIndex = 0
            }
            setMaskStack(t) {
                this.maskStack = t,
                this.renderer.scissor.setMaskStack(t),
                this.renderer.stencil.setMaskStack(t)
            }
            push(t, e) {
                let r = e;
                if (!r.isMaskData) {
                    const t = this.maskDataPool.pop() || new cn;
                    t.pooled = !0,
                    t.maskObject = e,
                    r = t
                }
                const n = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null;
                if (r.copyCountersOrReset(n),
                r._colorMask = n ? n._colorMask : 15,
                r.autoDetect && this.detect(r),
                r._target = t,
                r.type !== x.SPRITE && this.maskStack.push(r),
                r.enabled)
                    switch (r.type) {
                    case x.SCISSOR:
                        this.renderer.scissor.push(r);
                        break;
                    case x.STENCIL:
                        this.renderer.stencil.push(r);
                        break;
                    case x.SPRITE:
                        r.copyCountersOrReset(null),
                        this.pushSpriteMask(r);
                        break;
                    case x.COLOR:
                        this.pushColorMask(r)
                    }
                r.type === x.SPRITE && this.maskStack.push(r)
            }
            pop(t) {
                const e = this.maskStack.pop();
                if (e && e._target === t) {
                    if (e.enabled)
                        switch (e.type) {
                        case x.SCISSOR:
                            this.renderer.scissor.pop(e);
                            break;
                        case x.STENCIL:
                            this.renderer.stencil.pop(e.maskObject);
                            break;
                        case x.SPRITE:
                            this.popSpriteMask(e);
                            break;
                        case x.COLOR:
                            this.popColorMask(e)
                        }
                    if (e.reset(),
                    e.pooled && this.maskDataPool.push(e),
                    0 !== this.maskStack.length) {
                        const t = this.maskStack[this.maskStack.length - 1];
                        t.type === x.SPRITE && t._filters && (t._filters[0].maskSprite = t.maskObject)
                    }
                }
            }
            detect(t) {
                const e = t.maskObject;
                e ? e.isSprite ? t.type = x.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = x.SCISSOR : t.type = x.STENCIL : t.type = x.COLOR
            }
            pushSpriteMask(t) {
                const {maskObject: e} = t
                  , r = t._target;
                let n = t._filters;
                n || (n = this.alphaMaskPool[this.alphaMaskIndex],
                n || (n = this.alphaMaskPool[this.alphaMaskIndex] = [new un]));
                const i = this.renderer
                  , s = i.renderTexture;
                let o, a;
                if (s.current) {
                    const e = s.current;
                    o = t.resolution || e.resolution,
                    a = t.multisample ?? e.multisample
                } else
                    o = t.resolution || i.resolution,
                    a = t.multisample ?? i.multisample;
                n[0].resolution = o,
                n[0].multisample = a,
                n[0].maskSprite = e;
                const h = r.filterArea;
                r.filterArea = e.getBounds(!0),
                i.filter.push(r, n),
                r.filterArea = h,
                t._filters || this.alphaMaskIndex++
            }
            popSpriteMask(t) {
                this.renderer.filter.pop(),
                t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--,
                this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
            }
            pushColorMask(t) {
                const e = t._colorMask
                  , r = t._colorMask = e & t.colorMask;
                r !== e && this.renderer.gl.colorMask(0 != (1 & r), 0 != (2 & r), 0 != (4 & r), 0 != (8 & r))
            }
            popColorMask(t) {
                const e = t._colorMask
                  , r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
                r !== e && this.renderer.gl.colorMask(0 != (1 & r), 0 != (2 & r), 0 != (4 & r), 0 != (8 & r))
            }
            destroy() {
                this.renderer = null
            }
        }
        dn.extension = {
            type: pe.RendererSystem,
            name: "mask"
        },
        ve.add(dn);
        class fn {
            constructor(t) {
                this.renderer = t,
                this.maskStack = [],
                this.glConst = 0
            }
            getStackLength() {
                return this.maskStack.length
            }
            setMaskStack(t) {
                const {gl: e} = this.renderer
                  , r = this.getStackLength();
                this.maskStack = t;
                const n = this.getStackLength();
                n !== r && (0 === n ? e.disable(this.glConst) : (e.enable(this.glConst),
                this._useCurrent()))
            }
            _useCurrent() {}
            destroy() {
                this.renderer = null,
                this.maskStack = null
            }
        }
        const pn = new Ze
          , mn = []
          , gn = class extends fn {
            constructor(t) {
                super(t),
                this.glConst = w.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
            }
            getStackLength() {
                const t = this.maskStack[this.maskStack.length - 1];
                return t ? t._scissorCounter : 0
            }
            calcScissorRect(t) {
                if (t._scissorRectLocal)
                    return;
                const e = t._scissorRect
                  , {maskObject: r} = t
                  , {renderer: n} = this
                  , i = n.renderTexture
                  , s = r.getBounds(!0, mn.pop() ?? new Ve);
                this.roundFrameToPixels(s, i.current ? i.current.resolution : n.resolution, i.sourceFrame, i.destinationFrame, n.projection.transform),
                e && s.fit(e),
                t._scissorRectLocal = s
            }
            static isMatrixRotated(t) {
                if (!t)
                    return !1;
                const {a: e, b: r, c: n, d: i} = t;
                return (Math.abs(r) > 1e-4 || Math.abs(n) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(i) > 1e-4)
            }
            testScissor(t) {
                const {maskObject: e} = t;
                if (!e.isFastRect || !e.isFastRect())
                    return !1;
                if (gn.isMatrixRotated(e.worldTransform))
                    return !1;
                if (gn.isMatrixRotated(this.renderer.projection.transform))
                    return !1;
                this.calcScissorRect(t);
                const r = t._scissorRectLocal;
                return r.width > 0 && r.height > 0
            }
            roundFrameToPixels(t, e, r, n, i) {
                gn.isMatrixRotated(i) || ((i = i ? pn.copyFrom(i) : pn.identity()).translate(-r.x, -r.y).scale(n.width / r.width, n.height / r.height).translate(n.x, n.y),
                this.renderer.filter.transformAABB(i, t),
                t.fit(n),
                t.x = Math.round(t.x * e),
                t.y = Math.round(t.y * e),
                t.width = Math.round(t.width * e),
                t.height = Math.round(t.height * e))
            }
            push(t) {
                t._scissorRectLocal || this.calcScissorRect(t);
                const {gl: e} = this.renderer;
                t._scissorRect || e.enable(e.SCISSOR_TEST),
                t._scissorCounter++,
                t._scissorRect = t._scissorRectLocal,
                this._useCurrent()
            }
            pop(t) {
                const {gl: e} = this.renderer;
                t && mn.push(t._scissorRectLocal),
                this.getStackLength() > 0 ? this._useCurrent() : e.disable(e.SCISSOR_TEST)
            }
            _useCurrent() {
                const t = this.maskStack[this.maskStack.length - 1]._scissorRect;
                let e;
                e = this.renderer.renderTexture.current ? t.y : this.renderer.height - t.height - t.y,
                this.renderer.gl.scissor(t.x, e, t.width, t.height)
            }
        }
        ;
        let vn = gn;
        vn.extension = {
            type: pe.RendererSystem,
            name: "scissor"
        },
        ve.add(vn);
        class yn extends fn {
            constructor(t) {
                super(t),
                this.glConst = w.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
            }
            getStackLength() {
                const t = this.maskStack[this.maskStack.length - 1];
                return t ? t._stencilCounter : 0
            }
            push(t) {
                const e = t.maskObject
                  , {gl: r} = this.renderer
                  , n = t._stencilCounter;
                0 === n && (this.renderer.framebuffer.forceStencil(),
                r.clearStencil(0),
                r.clear(r.STENCIL_BUFFER_BIT),
                r.enable(r.STENCIL_TEST)),
                t._stencilCounter++;
                const i = t._colorMask;
                0 !== i && (t._colorMask = 0,
                r.colorMask(!1, !1, !1, !1)),
                r.stencilFunc(r.EQUAL, n, 4294967295),
                r.stencilOp(r.KEEP, r.KEEP, r.INCR),
                e.renderable = !0,
                e.render(this.renderer),
                this.renderer.batch.flush(),
                e.renderable = !1,
                0 !== i && (t._colorMask = i,
                r.colorMask(0 != (1 & i), 0 != (2 & i), 0 != (4 & i), 0 != (8 & i))),
                this._useCurrent()
            }
            pop(t) {
                const e = this.renderer.gl;
                if (0 === this.getStackLength())
                    e.disable(e.STENCIL_TEST);
                else {
                    const r = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null
                      , n = r ? r._colorMask : 15;
                    0 !== n && (r._colorMask = 0,
                    e.colorMask(!1, !1, !1, !1)),
                    e.stencilOp(e.KEEP, e.KEEP, e.DECR),
                    t.renderable = !0,
                    t.render(this.renderer),
                    this.renderer.batch.flush(),
                    t.renderable = !1,
                    0 !== n && (r._colorMask = n,
                    e.colorMask(0 != (1 & n), 0 != (2 & n), 0 != (4 & n), 0 != (8 & n))),
                    this._useCurrent()
                }
            }
            _useCurrent() {
                const t = this.renderer.gl;
                t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
                t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
            }
        }
        yn.extension = {
            type: pe.RendererSystem,
            name: "stencil"
        },
        ve.add(yn);
        class _n {
            constructor(t) {
                this.renderer = t,
                this.plugins = {},
                Object.defineProperties(this.plugins, {
                    extract: {
                        enumerable: !1,
                        get() {
                            return Z("7.0.0", "renderer.plugins.extract has moved to renderer.extract"),
                            t.extract
                        }
                    },
                    prepare: {
                        enumerable: !1,
                        get() {
                            return Z("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"),
                            t.prepare
                        }
                    },
                    interaction: {
                        enumerable: !1,
                        get() {
                            return Z("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"),
                            t.events
                        }
                    }
                })
            }
            init() {
                const t = this.rendererPlugins;
                for (const e in t)
                    this.plugins[e] = new t[e](this.renderer)
            }
            destroy() {
                for (const t in this.plugins)
                    this.plugins[t].destroy(),
                    this.plugins[t] = null
            }
        }
        _n.extension = {
            type: [pe.RendererSystem, pe.CanvasRendererSystem],
            name: "_plugin"
        },
        ve.add(_n);
        class xn {
            constructor(t) {
                this.renderer = t,
                this.destinationFrame = null,
                this.sourceFrame = null,
                this.defaultFrame = null,
                this.projectionMatrix = new Ze,
                this.transform = null
            }
            update(t, e, r, n) {
                this.destinationFrame = t || this.destinationFrame || this.defaultFrame,
                this.sourceFrame = e || this.sourceFrame || t,
                this.calculateProjection(this.destinationFrame, this.sourceFrame, r, n),
                this.transform && this.projectionMatrix.append(this.transform);
                const i = this.renderer;
                i.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix,
                i.globalUniforms.update(),
                i.shader.shader && i.shader.syncUniformGroup(i.shader.shader.uniforms.globals)
            }
            calculateProjection(t, e, r, n) {
                const i = this.projectionMatrix
                  , s = n ? -1 : 1;
                i.identity(),
                i.a = 1 / e.width * 2,
                i.d = s * (1 / e.height * 2),
                i.tx = -1 - e.x * i.a,
                i.ty = -s - e.y * i.d
            }
            setTransform(t) {}
            destroy() {
                this.renderer = null
            }
        }
        xn.extension = {
            type: pe.RendererSystem,
            name: "projection"
        },
        ve.add(xn);
        const bn = new hr;
        class En {
            constructor(t) {
                this.renderer = t,
                this._tempMatrix = new Ze
            }
            generateTexture(t, e) {
                const {region: r, ...n} = e || {}
                  , i = r || t.getLocalBounds(null, !0);
                0 === i.width && (i.width = 1),
                0 === i.height && (i.height = 1);
                const s = Yr.create({
                    width: i.width,
                    height: i.height,
                    ...n
                });
                this._tempMatrix.tx = -i.x,
                this._tempMatrix.ty = -i.y;
                const o = t.transform;
                return t.transform = bn,
                this.renderer.render(t, {
                    renderTexture: s,
                    transform: this._tempMatrix,
                    skipUpdateTransform: !!t.parent,
                    blit: !0
                }),
                t.transform = o,
                s
            }
            destroy() {}
        }
        En.extension = {
            type: [pe.RendererSystem, pe.CanvasRendererSystem],
            name: "textureGenerator"
        },
        ve.add(En);
        const Tn = new Ve
          , wn = new Ve;
        class Sn {
            constructor(t) {
                this.renderer = t,
                this.defaultMaskStack = [],
                this.current = null,
                this.sourceFrame = new Ve,
                this.destinationFrame = new Ve,
                this.viewportFrame = new Ve
            }
            contextChange() {
                const t = this.renderer?.gl.getContextAttributes();
                this._rendererPremultipliedAlpha = !!(t && t.alpha && t.premultipliedAlpha)
            }
            bind(t=null, e, r) {
                const n = this.renderer;
                let i, s, o;
                this.current = t,
                t ? (i = t.baseTexture,
                o = i.resolution,
                e || (Tn.width = t.frame.width,
                Tn.height = t.frame.height,
                e = Tn),
                r || (wn.x = t.frame.x,
                wn.y = t.frame.y,
                wn.width = e.width,
                wn.height = e.height,
                r = wn),
                s = i.framebuffer) : (o = n.resolution,
                e || (Tn.width = n._view.screen.width,
                Tn.height = n._view.screen.height,
                e = Tn),
                r || ((r = Tn).width = e.width,
                r.height = e.height));
                const a = this.viewportFrame;
                a.x = r.x * o,
                a.y = r.y * o,
                a.width = r.width * o,
                a.height = r.height * o,
                t || (a.y = n.view.height - (a.y + a.height)),
                a.ceil(),
                this.renderer.framebuffer.bind(s, a),
                this.renderer.projection.update(r, e, o, !s),
                t ? this.renderer.mask.setMaskStack(i.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack),
                this.sourceFrame.copyFrom(e),
                this.destinationFrame.copyFrom(r)
            }
            clear(t, e) {
                const r = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor
                  , n = It.shared.setValue(t || r);
                (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && n.premultiply(n.alpha);
                const i = this.destinationFrame
                  , s = this.current ? this.current.baseTexture : this.renderer._view.screen
                  , o = i.width !== s.width || i.height !== s.height;
                if (o) {
                    let {x: t, y: e, width: r, height: n} = this.viewportFrame;
                    t = Math.round(t),
                    e = Math.round(e),
                    r = Math.round(r),
                    n = Math.round(n),
                    this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
                    this.renderer.gl.scissor(t, e, r, n)
                }
                this.renderer.framebuffer.clear(n.red, n.green, n.blue, n.alpha, e),
                o && this.renderer.scissor.pop()
            }
            resize() {
                this.bind(null)
            }
            reset() {
                this.bind(null)
            }
            destroy() {
                this.renderer = null
            }
        }
        Sn.extension = {
            type: pe.RendererSystem,
            name: "renderTexture"
        },
        ve.add(Sn);
        class An {
            constructor(t, e) {
                this.program = t,
                this.uniformData = e,
                this.uniformGroups = {},
                this.uniformDirtyGroups = {},
                this.uniformBufferBindings = {}
            }
            destroy() {
                this.uniformData = null,
                this.uniformGroups = null,
                this.uniformDirtyGroups = null,
                this.uniformBufferBindings = null,
                this.program = null
            }
        }
        function Cn(t, e, r) {
            const n = t.createShader(e);
            return t.shaderSource(n, r),
            t.compileShader(n),
            n
        }
        function Rn(t) {
            const e = new Array(t);
            for (let t = 0; t < e.length; t++)
                e[t] = !1;
            return e
        }
        function Pn(t, e) {
            switch (t) {
            case "float":
            case "int":
            case "uint":
            case "sampler2D":
            case "sampler2DArray":
                return 0;
            case "vec2":
                return new Float32Array(2 * e);
            case "vec3":
                return new Float32Array(3 * e);
            case "vec4":
                return new Float32Array(4 * e);
            case "ivec2":
                return new Int32Array(2 * e);
            case "ivec3":
                return new Int32Array(3 * e);
            case "ivec4":
                return new Int32Array(4 * e);
            case "uvec2":
                return new Uint32Array(2 * e);
            case "uvec3":
                return new Uint32Array(3 * e);
            case "uvec4":
                return new Uint32Array(4 * e);
            case "bool":
                return !1;
            case "bvec2":
                return Rn(2 * e);
            case "bvec3":
                return Rn(3 * e);
            case "bvec4":
                return Rn(4 * e);
            case "mat2":
                return new Float32Array([1, 0, 0, 1]);
            case "mat3":
                return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
            case "mat4":
                return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
            }
            return null
        }
        function In(t, e) {
            const r = t.getShaderSource(e).split("\n").map(( (t, e) => `${e}: ${t}`))
              , n = t.getShaderInfoLog(e)
              , i = n.split("\n")
              , s = {}
              , o = i.map((t => parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1")))).filter((t => !(!t || s[t] || (s[t] = !0,
            0))))
              , a = [""];
            o.forEach((t => {
                r[t - 1] = `%c${r[t - 1]}%c`,
                a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
            }
            ));
            const h = r.join("\n");
            a[0] = h,
            console.error(n),
            console.groupCollapsed("click to view full shader code"),
            console.warn(...a),
            console.groupEnd()
        }
        function Mn(t, e, r, n, i) {
            r.buffer.update(i)
        }
        const Dn = {
            float: "\n        data[offset] = v;\n    ",
            vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
            vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
            vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
            mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
            mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
            mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
        }
          , On = {
            float: 4,
            vec2: 8,
            vec3: 12,
            vec4: 16,
            int: 4,
            ivec2: 8,
            ivec3: 12,
            ivec4: 16,
            uint: 4,
            uvec2: 8,
            uvec3: 12,
            uvec4: 16,
            bool: 4,
            bvec2: 8,
            bvec3: 12,
            bvec4: 16,
            mat2: 32,
            mat3: 48,
            mat4: 64
        };
        let Bn, kn = 0;
        const Ln = {
            textureCount: 0,
            uboCount: 0
        };
        class Nn {
            constructor(t) {
                this.destroyed = !1,
                this.renderer = t,
                this.systemCheck(),
                this.gl = null,
                this.shader = null,
                this.program = null,
                this.cache = {},
                this._uboCache = {},
                this.id = kn++
            }
            systemCheck() {
                if (!function() {
                    if ("boolean" == typeof Bn)
                        return Bn;
                    try {
                        const t = new Function("param1","param2","param3","return param1[param2] === param3;");
                        Bn = !0 === t({
                            a: "b"
                        }, "a", "b")
                    } catch (t) {
                        Bn = !1
                    }
                    return Bn
                }())
                    throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
            }
            contextChange(t) {
                this.gl = t,
                this.reset()
            }
            bind(t, e) {
                t.disposeRunner.add(this),
                t.uniforms.globals = this.renderer.globalUniforms;
                const r = t.program
                  , n = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
                return this.shader = t,
                this.program !== r && (this.program = r,
                this.gl.useProgram(n.program)),
                e || (Ln.textureCount = 0,
                Ln.uboCount = 0,
                this.syncUniformGroup(t.uniformGroup, Ln)),
                n
            }
            setUniforms(t) {
                const e = this.shader.program
                  , r = e.glPrograms[this.renderer.CONTEXT_UID];
                e.syncUniforms(r.uniformData, t, this.renderer)
            }
            syncUniformGroup(t, e) {
                const r = this.getGlProgram();
                t.static && t.dirtyId === r.uniformDirtyGroups[t.id] || (r.uniformDirtyGroups[t.id] = t.dirtyId,
                this.syncUniforms(t, r, e))
            }
            syncUniforms(t, e, r) {
                (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, r)
            }
            createSyncGroups(t) {
                const e = this.getSignature(t, this.shader.program.uniformData, "u");
                return this.cache[e] || (this.cache[e] = function(t, e) {
                    const r = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
                    for (const n in t.uniforms) {
                        const i = e[n];
                        if (!i) {
                            t.uniforms[n]?.group && (t.uniforms[n].ubo ? r.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${n}, '${n}');\n                    `) : r.push(`\n                        renderer.shader.syncUniformGroup(uv.${n}, syncData);\n                    `));
                            continue
                        }
                        const s = t.uniforms[n];
                        let o = !1;
                        for (let t = 0; t < lr.length; t++)
                            if (lr[t].test(i, s)) {
                                r.push(lr[t].code(n, s)),
                                o = !0;
                                break
                            }
                        if (!o) {
                            const t = (1 !== i.size || i.isArray ? cr : ur)[i.type].replace("location", `ud["${n}"].location`);
                            r.push(`\n            cu = ud["${n}"];\n            cv = cu.value;\n            v = uv["${n}"];\n            ${t};`)
                        }
                    }
                    return new Function("ud","uv","renderer","syncData",r.join("\n"))
                }(t, this.shader.program.uniformData)),
                t.syncUniforms[this.shader.program.id] = this.cache[e],
                t.syncUniforms[this.shader.program.id]
            }
            syncUniformBufferGroup(t, e) {
                const r = this.getGlProgram();
                if (!t.static || 0 !== t.dirtyId || !r.uniformGroups[t.id]) {
                    t.dirtyId = 0;
                    const n = r.uniformGroups[t.id] || this.createSyncBufferGroup(t, r, e);
                    t.buffer.update(),
                    n(r.uniformData, t.uniforms, this.renderer, Ln, t.buffer)
                }
                this.renderer.buffer.bindBufferBase(t.buffer, r.uniformBufferBindings[e])
            }
            createSyncBufferGroup(t, e, r) {
                const {gl: n} = this.renderer;
                this.renderer.buffer.bind(t.buffer);
                const i = this.gl.getUniformBlockIndex(e.program, r);
                e.uniformBufferBindings[r] = this.shader.uniformBindCount,
                n.uniformBlockBinding(e.program, i, this.shader.uniformBindCount),
                this.shader.uniformBindCount++;
                const s = this.getSignature(t, this.shader.program.uniformData, "ubo");
                let o = this._uboCache[s];
                if (o || (o = this._uboCache[s] = function(t, e) {
                    if (!t.autoManage)
                        return {
                            size: 0,
                            syncFunc: Mn
                        };
                    const r = function(t, e) {
                        const r = [];
                        for (const n in t)
                            e[n] && r.push(e[n]);
                        return r.sort(( (t, e) => t.index - e.index)),
                        r
                    }(t.uniforms, e)
                      , {uboElements: n, size: i} = function(t) {
                        const e = t.map((t => ({
                            data: t,
                            offset: 0,
                            dataLen: 0,
                            dirty: 0
                        })));
                        let r = 0
                          , n = 0
                          , i = 0;
                        for (let t = 0; t < e.length; t++) {
                            const s = e[t];
                            if (r = On[s.data.type],
                            s.data.size > 1 && (r = Math.max(r, 16) * s.data.size),
                            s.dataLen = r,
                            n % r != 0 && n < 16) {
                                const t = n % r % 16;
                                n += t,
                                i += t
                            }
                            n + r > 16 ? (i = 16 * Math.ceil(i / 16),
                            s.offset = i,
                            i += r,
                            n = r) : (s.offset = i,
                            n += r,
                            i += r)
                        }
                        return i = 16 * Math.ceil(i / 16),
                        {
                            uboElements: e,
                            size: i
                        }
                    }(r)
                      , s = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
                    for (let e = 0; e < n.length; e++) {
                        const r = n[e]
                          , i = t.uniforms[r.data.name]
                          , o = r.data.name;
                        let a = !1;
                        for (let t = 0; t < lr.length; t++) {
                            const e = lr[t];
                            if (e.codeUbo && e.test(r.data, i)) {
                                s.push(`offset = ${r.offset / 4};`, lr[t].codeUbo(r.data.name, i)),
                                a = !0;
                                break
                            }
                        }
                        if (!a)
                            if (r.data.size > 1) {
                                const t = gr(r.data.type)
                                  , e = Math.max(On[r.data.type] / 16, 1)
                                  , n = t / e
                                  , i = (4 - n % 4) % 4;
                                s.push(`\n                cv = ud.${o}.value;\n                v = uv.${o};\n                offset = ${r.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${r.data.size * e}; i++)\n                {\n                    for(var j = 0; j < ${n}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${i};\n                }\n\n                `)
                            } else {
                                const t = Dn[r.data.type];
                                s.push(`\n                cv = ud.${o}.value;\n                v = uv.${o};\n                offset = ${r.offset / 4};\n                ${t};\n                `)
                            }
                    }
                    return s.push("\n       renderer.buffer.update(buffer);\n    "),
                    {
                        size: i,
                        syncFunc: new Function("ud","uv","renderer","syncData","buffer",s.join("\n"))
                    }
                }(t, this.shader.program.uniformData)),
                t.autoManage) {
                    const e = new Float32Array(o.size / 4);
                    t.buffer.update(e)
                }
                return e.uniformGroups[t.id] = o.syncFunc,
                e.uniformGroups[t.id]
            }
            getSignature(t, e, r) {
                const n = t.uniforms
                  , i = [`${r}-`];
                for (const t in n)
                    i.push(t),
                    e[t] && i.push(e[t].type);
                return i.join("-")
            }
            getGlProgram() {
                return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
            }
            generateProgram(t) {
                const e = this.gl
                  , r = t.program
                  , n = function(t, e) {
                    const r = Cn(t, t.VERTEX_SHADER, e.vertexSrc)
                      , n = Cn(t, t.FRAGMENT_SHADER, e.fragmentSrc)
                      , i = t.createProgram();
                    t.attachShader(i, r),
                    t.attachShader(i, n);
                    const s = e.extra?.transformFeedbackVaryings;
                    if (s && ("function" != typeof t.transformFeedbackVaryings ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : t.transformFeedbackVaryings(i, s.names, "separate" === s.bufferMode ? t.SEPARATE_ATTRIBS : t.INTERLEAVED_ATTRIBS)),
                    t.linkProgram(i),
                    t.getProgramParameter(i, t.LINK_STATUS) || function(t, e, r, n) {
                        t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(r, t.COMPILE_STATUS) || In(t, r),
                        t.getShaderParameter(n, t.COMPILE_STATUS) || In(t, n),
                        console.error("PixiJS Error: Could not initialize shader."),
                        "" !== t.getProgramInfoLog(e) && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(e)))
                    }(t, i, r, n),
                    e.attributeData = function(t, e) {
                        const r = {}
                          , n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                        for (let i = 0; i < n; i++) {
                            const n = e.getActiveAttrib(t, i);
                            if (n.name.startsWith("gl_"))
                                continue;
                            const s = _r(e, n.type)
                              , o = {
                                type: s,
                                name: n.name,
                                size: gr(s),
                                location: e.getAttribLocation(t, n.name)
                            };
                            r[n.name] = o
                        }
                        return r
                    }(i, t),
                    e.uniformData = function(t, e) {
                        const r = {}
                          , n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                        for (let i = 0; i < n; i++) {
                            const n = e.getActiveUniform(t, i)
                              , s = n.name.replace(/\[.*?\]$/, "")
                              , o = !!n.name.match(/\[.*?\]$/)
                              , a = _r(e, n.type);
                            r[s] = {
                                name: s,
                                index: i,
                                type: a,
                                size: n.size,
                                isArray: o,
                                value: Pn(a, n.size)
                            }
                        }
                        return r
                    }(i, t),
                    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) {
                        const r = Object.keys(e.attributeData);
                        r.sort(( (t, e) => t > e ? 1 : -1));
                        for (let n = 0; n < r.length; n++)
                            e.attributeData[r[n]].location = n,
                            t.bindAttribLocation(i, n, r[n]);
                        t.linkProgram(i)
                    }
                    t.deleteShader(r),
                    t.deleteShader(n);
                    const o = {};
                    for (const r in e.uniformData) {
                        const n = e.uniformData[r];
                        o[r] = {
                            location: t.getUniformLocation(i, r),
                            value: Pn(n.type, n.size)
                        }
                    }
                    return new An(i,o)
                }(e, r);
                return r.glPrograms[this.renderer.CONTEXT_UID] = n,
                n
            }
            reset() {
                this.program = null,
                this.shader = null
            }
            disposeShader(t) {
                this.shader === t && (this.shader = null)
            }
            destroy() {
                this.renderer = null,
                this.destroyed = !0
            }
        }
        Nn.extension = {
            type: pe.RendererSystem,
            name: "shader"
        },
        ve.add(Nn);
        class Fn {
            constructor(t) {
                this.renderer = t
            }
            run(t) {
                const {renderer: e} = this;
                e.runners.init.emit(e.options),
                t.hello && console.log(`PixiJS 7.2.4 - ${e.rendererLogId} - https://pixijs.com`),
                e.resize(e.screen.width, e.screen.height)
            }
            destroy() {}
        }
        Fn.defaultOptions = {
            hello: !1
        },
        Fn.extension = {
            type: [pe.RendererSystem, pe.CanvasRendererSystem],
            name: "startup"
        },
        ve.add(Fn);
        const Un = class {
            constructor() {
                this.gl = null,
                this.stateId = 0,
                this.polygonOffset = 0,
                this.blendMode = a.NONE,
                this._blendEq = !1,
                this.map = [],
                this.map[0] = this.setBlend,
                this.map[1] = this.setOffset,
                this.map[2] = this.setCullFace,
                this.map[3] = this.setDepthTest,
                this.map[4] = this.setFrontFace,
                this.map[5] = this.setDepthMask,
                this.checks = [],
                this.defaultState = new be,
                this.defaultState.blend = !0
            }
            contextChange(t) {
                this.gl = t,
                this.blendModes = function(t, e=[]) {
                    return e[a.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.ADD] = [t.ONE, t.ONE],
                    e[a.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.NONE] = [0, 0],
                    e[a.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE],
                    e[a.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA],
                    e[a.SRC_IN] = [t.DST_ALPHA, t.ZERO],
                    e[a.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO],
                    e[a.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA],
                    e[a.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE],
                    e[a.DST_IN] = [t.ZERO, t.SRC_ALPHA],
                    e[a.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA],
                    e[a.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA],
                    e[a.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA],
                    e[a.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD],
                    e
                }(t),
                this.set(this.defaultState),
                this.reset()
            }
            set(t) {
                if (t = t || this.defaultState,
                this.stateId !== t.data) {
                    let e = this.stateId ^ t.data
                      , r = 0;
                    for (; e; )
                        1 & e && this.map[r].call(this, !!(t.data & 1 << r)),
                        e >>= 1,
                        r++;
                    this.stateId = t.data
                }
                for (let e = 0; e < this.checks.length; e++)
                    this.checks[e](this, t)
            }
            forceState(t) {
                t = t || this.defaultState;
                for (let e = 0; e < this.map.length; e++)
                    this.map[e].call(this, !!(t.data & 1 << e));
                for (let e = 0; e < this.checks.length; e++)
                    this.checks[e](this, t);
                this.stateId = t.data
            }
            setBlend(t) {
                this.updateCheck(Un.checkBlendMode, t),
                this.gl[t ? "enable" : "disable"](this.gl.BLEND)
            }
            setOffset(t) {
                this.updateCheck(Un.checkPolygonOffset, t),
                this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
            }
            setDepthTest(t) {
                this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
            }
            setDepthMask(t) {
                this.gl.depthMask(t)
            }
            setCullFace(t) {
                this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE)
            }
            setFrontFace(t) {
                this.gl.frontFace(this.gl[t ? "CW" : "CCW"])
            }
            setBlendMode(t) {
                if (t === this.blendMode)
                    return;
                this.blendMode = t;
                const e = this.blendModes[t]
                  , r = this.gl;
                2 === e.length ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]),
                6 === e.length ? (this._blendEq = !0,
                r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1,
                r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD))
            }
            setPolygonOffset(t, e) {
                this.gl.polygonOffset(t, e)
            }
            reset() {
                this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
                this.forceState(this.defaultState),
                this._blendEq = !0,
                this.blendMode = -1,
                this.setBlendMode(0)
            }
            updateCheck(t, e) {
                const r = this.checks.indexOf(t);
                e && -1 === r ? this.checks.push(t) : e || -1 === r || this.checks.splice(r, 1)
            }
            static checkBlendMode(t, e) {
                t.setBlendMode(e.blendMode)
            }
            static checkPolygonOffset(t, e) {
                t.setPolygonOffset(1, e.polygonOffset)
            }
            destroy() {
                this.gl = null
            }
        }
        ;
        let Gn = Un;
        Gn.extension = {
            type: pe.RendererSystem,
            name: "state"
        },
        ve.add(Gn);
        class jn extends H {
            constructor() {
                super(...arguments),
                this.runners = {},
                this._systemsHash = {}
            }
            setup(t) {
                this.addRunners(...t.runners);
                const e = (t.priority ?? []).filter((e => t.systems[e]))
                  , r = [...e, ...Object.keys(t.systems).filter((t => !e.includes(t)))];
                for (const e of r)
                    this.addSystem(t.systems[e], e)
            }
            addRunners(...t) {
                t.forEach((t => {
                    this.runners[t] = new we(t)
                }
                ))
            }
            addSystem(t, e) {
                const r = new t(this);
                if (this[e])
                    throw new Error(`Whoops! The name "${e}" is already in use`);
                this[e] = r,
                this._systemsHash[e] = r;
                for (const t in this.runners)
                    this.runners[t].add(r);
                return this
            }
            emitWithCustomOptions(t, e) {
                const r = Object.keys(this._systemsHash);
                t.items.forEach((n => {
                    const i = r.find((t => this._systemsHash[t] === n));
                    n[t.name](e[i])
                }
                ))
            }
            destroy() {
                Object.values(this.runners).forEach((t => {
                    t.destroy()
                }
                )),
                this._systemsHash = {}
            }
        }
        const zn = class {
            constructor(t) {
                this.renderer = t,
                this.count = 0,
                this.checkCount = 0,
                this.maxIdle = zn.defaultMaxIdle,
                this.checkCountMax = zn.defaultCheckCountMax,
                this.mode = zn.defaultMode
            }
            postrender() {
                this.renderer.objectRenderer.renderingToScreen && (this.count++,
                this.mode !== y.MANUAL && (this.checkCount++,
                this.checkCount > this.checkCountMax && (this.checkCount = 0,
                this.run())))
            }
            run() {
                const t = this.renderer.texture
                  , e = t.managedTextures;
                let r = !1;
                for (let n = 0; n < e.length; n++) {
                    const i = e[n];
                    !i.framebuffer && this.count - i.touched > this.maxIdle && (t.destroyTexture(i, !0),
                    e[n] = null,
                    r = !0)
                }
                if (r) {
                    let t = 0;
                    for (let r = 0; r < e.length; r++)
                        null !== e[r] && (e[t++] = e[r]);
                    e.length = t
                }
            }
            unload(t) {
                const e = this.renderer.texture
                  , r = t._texture;
                r && !r.framebuffer && e.destroyTexture(r);
                for (let e = t.children.length - 1; e >= 0; e--)
                    this.unload(t.children[e])
            }
            destroy() {
                this.renderer = null
            }
        }
        ;
        let Hn = zn;
        Hn.defaultMode = y.AUTO,
        Hn.defaultMaxIdle = 3600,
        Hn.defaultCheckCountMax = 600,
        Hn.extension = {
            type: pe.RendererSystem,
            name: "textureGC"
        },
        ve.add(Hn);
        class $n {
            constructor(t) {
                this.texture = t,
                this.width = -1,
                this.height = -1,
                this.dirtyId = -1,
                this.dirtyStyleId = -1,
                this.mipmap = !1,
                this.wrapMode = 33071,
                this.type = c.UNSIGNED_BYTE,
                this.internalFormat = l.RGBA,
                this.samplerType = 0
            }
        }
        class Xn {
            constructor(t) {
                this.renderer = t,
                this.boundTextures = [],
                this.currentLocation = -1,
                this.managedTextures = [],
                this._unknownBoundTextures = !1,
                this.unknownTexture = new Pe,
                this.hasIntegerTextures = !1
            }
            contextChange() {
                const t = this.gl = this.renderer.gl;
                this.CONTEXT_UID = this.renderer.CONTEXT_UID,
                this.webGLVersion = this.renderer.context.webGLVersion,
                this.internalFormats = function(t) {
                    let e;
                    return e = "WebGL2RenderingContext"in globalThis && t instanceof globalThis.WebGL2RenderingContext ? {
                        [c.UNSIGNED_BYTE]: {
                            [l.RGBA]: t.RGBA8,
                            [l.RGB]: t.RGB8,
                            [l.RG]: t.RG8,
                            [l.RED]: t.R8,
                            [l.RGBA_INTEGER]: t.RGBA8UI,
                            [l.RGB_INTEGER]: t.RGB8UI,
                            [l.RG_INTEGER]: t.RG8UI,
                            [l.RED_INTEGER]: t.R8UI,
                            [l.ALPHA]: t.ALPHA,
                            [l.LUMINANCE]: t.LUMINANCE,
                            [l.LUMINANCE_ALPHA]: t.LUMINANCE_ALPHA
                        },
                        [c.BYTE]: {
                            [l.RGBA]: t.RGBA8_SNORM,
                            [l.RGB]: t.RGB8_SNORM,
                            [l.RG]: t.RG8_SNORM,
                            [l.RED]: t.R8_SNORM,
                            [l.RGBA_INTEGER]: t.RGBA8I,
                            [l.RGB_INTEGER]: t.RGB8I,
                            [l.RG_INTEGER]: t.RG8I,
                            [l.RED_INTEGER]: t.R8I
                        },
                        [c.UNSIGNED_SHORT]: {
                            [l.RGBA_INTEGER]: t.RGBA16UI,
                            [l.RGB_INTEGER]: t.RGB16UI,
                            [l.RG_INTEGER]: t.RG16UI,
                            [l.RED_INTEGER]: t.R16UI,
                            [l.DEPTH_COMPONENT]: t.DEPTH_COMPONENT16
                        },
                        [c.SHORT]: {
                            [l.RGBA_INTEGER]: t.RGBA16I,
                            [l.RGB_INTEGER]: t.RGB16I,
                            [l.RG_INTEGER]: t.RG16I,
                            [l.RED_INTEGER]: t.R16I
                        },
                        [c.UNSIGNED_INT]: {
                            [l.RGBA_INTEGER]: t.RGBA32UI,
                            [l.RGB_INTEGER]: t.RGB32UI,
                            [l.RG_INTEGER]: t.RG32UI,
                            [l.RED_INTEGER]: t.R32UI,
                            [l.DEPTH_COMPONENT]: t.DEPTH_COMPONENT24
                        },
                        [c.INT]: {
                            [l.RGBA_INTEGER]: t.RGBA32I,
                            [l.RGB_INTEGER]: t.RGB32I,
                            [l.RG_INTEGER]: t.RG32I,
                            [l.RED_INTEGER]: t.R32I
                        },
                        [c.FLOAT]: {
                            [l.RGBA]: t.RGBA32F,
                            [l.RGB]: t.RGB32F,
                            [l.RG]: t.RG32F,
                            [l.RED]: t.R32F,
                            [l.DEPTH_COMPONENT]: t.DEPTH_COMPONENT32F
                        },
                        [c.HALF_FLOAT]: {
                            [l.RGBA]: t.RGBA16F,
                            [l.RGB]: t.RGB16F,
                            [l.RG]: t.RG16F,
                            [l.RED]: t.R16F
                        },
                        [c.UNSIGNED_SHORT_5_6_5]: {
                            [l.RGB]: t.RGB565
                        },
                        [c.UNSIGNED_SHORT_4_4_4_4]: {
                            [l.RGBA]: t.RGBA4
                        },
                        [c.UNSIGNED_SHORT_5_5_5_1]: {
                            [l.RGBA]: t.RGB5_A1
                        },
                        [c.UNSIGNED_INT_2_10_10_10_REV]: {
                            [l.RGBA]: t.RGB10_A2,
                            [l.RGBA_INTEGER]: t.RGB10_A2UI
                        },
                        [c.UNSIGNED_INT_10F_11F_11F_REV]: {
                            [l.RGB]: t.R11F_G11F_B10F
                        },
                        [c.UNSIGNED_INT_5_9_9_9_REV]: {
                            [l.RGB]: t.RGB9_E5
                        },
                        [c.UNSIGNED_INT_24_8]: {
                            [l.DEPTH_STENCIL]: t.DEPTH24_STENCIL8
                        },
                        [c.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
                            [l.DEPTH_STENCIL]: t.DEPTH32F_STENCIL8
                        }
                    } : {
                        [c.UNSIGNED_BYTE]: {
                            [l.RGBA]: t.RGBA,
                            [l.RGB]: t.RGB,
                            [l.ALPHA]: t.ALPHA,
                            [l.LUMINANCE]: t.LUMINANCE,
                            [l.LUMINANCE_ALPHA]: t.LUMINANCE_ALPHA
                        },
                        [c.UNSIGNED_SHORT_5_6_5]: {
                            [l.RGB]: t.RGB
                        },
                        [c.UNSIGNED_SHORT_4_4_4_4]: {
                            [l.RGBA]: t.RGBA
                        },
                        [c.UNSIGNED_SHORT_5_5_5_1]: {
                            [l.RGBA]: t.RGBA
                        }
                    },
                    e
                }(t);
                const e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                this.boundTextures.length = e;
                for (let t = 0; t < e; t++)
                    this.boundTextures[t] = null;
                this.emptyTextures = {};
                const r = new $n(t.createTexture());
                t.bindTexture(t.TEXTURE_2D, r.texture),
                t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)),
                this.emptyTextures[t.TEXTURE_2D] = r,
                this.emptyTextures[t.TEXTURE_CUBE_MAP] = new $n(t.createTexture()),
                t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
                for (let e = 0; e < 6; e++)
                    t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
                t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
                t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
                for (let t = 0; t < this.boundTextures.length; t++)
                    this.bind(null, t)
            }
            bind(t, e=0) {
                const {gl: r} = this;
                if (t = t?.castToBaseTexture(),
                t?.valid && !t.parentTextureArray) {
                    t.touched = this.renderer.textureGC.count;
                    const n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
                    this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e,
                    r.activeTexture(r.TEXTURE0 + e)),
                    r.bindTexture(t.target, n.texture)),
                    n.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e,
                    r.activeTexture(r.TEXTURE0 + e)),
                    this.updateTexture(t)) : n.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t),
                    this.boundTextures[e] = t
                } else
                    this.currentLocation !== e && (this.currentLocation = e,
                    r.activeTexture(r.TEXTURE0 + e)),
                    r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture),
                    this.boundTextures[e] = null
            }
            reset() {
                this._unknownBoundTextures = !0,
                this.hasIntegerTextures = !1,
                this.currentLocation = -1;
                for (let t = 0; t < this.boundTextures.length; t++)
                    this.boundTextures[t] = this.unknownTexture
            }
            unbind(t) {
                const {gl: e, boundTextures: r} = this;
                if (this._unknownBoundTextures) {
                    this._unknownBoundTextures = !1;
                    for (let t = 0; t < r.length; t++)
                        r[t] === this.unknownTexture && this.bind(null, t)
                }
                for (let n = 0; n < r.length; n++)
                    r[n] === t && (this.currentLocation !== n && (e.activeTexture(e.TEXTURE0 + n),
                    this.currentLocation = n),
                    e.bindTexture(t.target, this.emptyTextures[t.target].texture),
                    r[n] = null)
            }
            ensureSamplerType(t) {
                const {boundTextures: e, hasIntegerTextures: r, CONTEXT_UID: n} = this;
                if (r)
                    for (let r = t - 1; r >= 0; --r) {
                        const t = e[r];
                        t && t._glTextures[n].samplerType !== d.FLOAT && this.renderer.texture.unbind(t)
                    }
            }
            initTexture(t) {
                const e = new $n(this.gl.createTexture());
                return e.dirtyId = -1,
                t._glTextures[this.CONTEXT_UID] = e,
                this.managedTextures.push(t),
                t.on("dispose", this.destroyTexture, this),
                e
            }
            initTextureType(t, e) {
                e.internalFormat = this.internalFormats[t.type]?.[t.format] ?? t.format,
                2 === this.webGLVersion && t.type === c.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type
            }
            updateTexture(t) {
                const e = t._glTextures[this.CONTEXT_UID];
                if (!e)
                    return;
                const r = this.renderer;
                if (this.initTextureType(t, e),
                t.resource?.upload(r, t, e))
                    e.samplerType !== d.FLOAT && (this.hasIntegerTextures = !0);
                else {
                    const n = t.realWidth
                      , i = t.realHeight
                      , s = r.gl;
                    (e.width !== n || e.height !== i || e.dirtyId < 0) && (e.width = n,
                    e.height = i,
                    s.texImage2D(t.target, 0, e.internalFormat, n, i, 0, t.format, e.type, null))
                }
                t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t),
                e.dirtyId = t.dirtyId
            }
            destroyTexture(t, e) {
                const {gl: r} = this;
                if ((t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t),
                r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
                t.off("dispose", this.destroyTexture, this),
                delete t._glTextures[this.CONTEXT_UID],
                !e)) {
                    const e = this.managedTextures.indexOf(t);
                    -1 !== e && Yt(this.managedTextures, e, 1)
                }
            }
            updateTextureStyle(t) {
                const e = t._glTextures[this.CONTEXT_UID];
                e && (t.mipmap !== m.POW2 && 2 === this.webGLVersion || t.isPowerOfTwo ? e.mipmap = t.mipmap >= 1 : e.mipmap = !1,
                2 === this.webGLVersion || t.isPowerOfTwo ? e.wrapMode = t.wrapMode : e.wrapMode = p.CLAMP,
                t.resource?.style(this.renderer, t, e) || this.setStyle(t, e),
                e.dirtyStyleId = t.dirtyStyleId)
            }
            setStyle(t, e) {
                const r = this.gl;
                if (e.mipmap && t.mipmap !== m.ON_MANUAL && r.generateMipmap(t.target),
                r.texParameteri(t.target, r.TEXTURE_WRAP_S, e.wrapMode),
                r.texParameteri(t.target, r.TEXTURE_WRAP_T, e.wrapMode),
                e.mipmap) {
                    r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === f.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);
                    const e = this.renderer.context.extensions.anisotropicFiltering;
                    if (e && t.anisotropicLevel > 0 && t.scaleMode === f.LINEAR) {
                        const n = Math.min(t.anisotropicLevel, r.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                        r.texParameterf(t.target, e.TEXTURE_MAX_ANISOTROPY_EXT, n)
                    }
                } else
                    r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === f.LINEAR ? r.LINEAR : r.NEAREST);
                r.texParameteri(t.target, r.TEXTURE_MAG_FILTER, t.scaleMode === f.LINEAR ? r.LINEAR : r.NEAREST)
            }
            destroy() {
                this.renderer = null
            }
        }
        Xn.extension = {
            type: pe.RendererSystem,
            name: "texture"
        },
        ve.add(Xn);
        class Vn {
            constructor(t) {
                this.renderer = t
            }
            contextChange() {
                this.gl = this.renderer.gl,
                this.CONTEXT_UID = this.renderer.CONTEXT_UID
            }
            bind(t) {
                const {gl: e, CONTEXT_UID: r} = this
                  , n = t._glTransformFeedbacks[r] || this.createGLTransformFeedback(t);
                e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, n)
            }
            unbind() {
                const {gl: t} = this;
                t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
            }
            beginTransformFeedback(t, e) {
                const {gl: r, renderer: n} = this;
                e && n.shader.bind(e),
                r.beginTransformFeedback(t)
            }
            endTransformFeedback() {
                const {gl: t} = this;
                t.endTransformFeedback()
            }
            createGLTransformFeedback(t) {
                const {gl: e, renderer: r, CONTEXT_UID: n} = this
                  , i = e.createTransformFeedback();
                t._glTransformFeedbacks[n] = i,
                e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, i);
                for (let i = 0; i < t.buffers.length; i++) {
                    const s = t.buffers[i];
                    s && (r.buffer.update(s),
                    s._glBuffers[n].refCount++,
                    e.bindBufferBase(e.TRANSFORM_FEEDBACK_BUFFER, i, s._glBuffers[n].buffer || null))
                }
                return e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null),
                t.disposeRunner.add(this),
                i
            }
            disposeTransformFeedback(t, e) {
                const r = t._glTransformFeedbacks[this.CONTEXT_UID]
                  , n = this.gl;
                t.disposeRunner.remove(this);
                const i = this.renderer.buffer;
                if (i)
                    for (let r = 0; r < t.buffers.length; r++) {
                        const n = t.buffers[r];
                        if (!n)
                            continue;
                        const s = n._glBuffers[this.CONTEXT_UID];
                        s && (s.refCount--,
                        0 !== s.refCount || e || i.dispose(n, e))
                    }
                r && (e || n.deleteTransformFeedback(r),
                delete t._glTransformFeedbacks[this.CONTEXT_UID])
            }
            destroy() {
                this.renderer = null
            }
        }
        Vn.extension = {
            type: pe.RendererSystem,
            name: "transformFeedback"
        },
        ve.add(Vn);
        class Wn {
            constructor(t) {
                this.renderer = t
            }
            init(t) {
                this.screen = new Ve(0,0,t.width,t.height),
                this.element = t.view || w.ADAPTER.createCanvas(),
                this.resolution = t.resolution || w.RESOLUTION,
                this.autoDensity = !!t.autoDensity
            }
            resizeView(t, e) {
                this.element.width = Math.round(t * this.resolution),
                this.element.height = Math.round(e * this.resolution);
                const r = this.element.width / this.resolution
                  , n = this.element.height / this.resolution;
                this.screen.width = r,
                this.screen.height = n,
                this.autoDensity && (this.element.style.width = `${r}px`,
                this.element.style.height = `${n}px`),
                this.renderer.emit("resize", r, n),
                this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
            }
            destroy(t) {
                t && this.element.parentNode?.removeChild(this.element),
                this.renderer = null,
                this.element = null,
                this.screen = null
            }
        }
        Wn.defaultOptions = {
            width: 800,
            height: 600,
            resolution: w.RESOLUTION,
            autoDensity: !1
        },
        Wn.extension = {
            type: [pe.RendererSystem, pe.CanvasRendererSystem],
            name: "_view"
        },
        ve.add(Wn),
        w.PREFER_ENV = i.WEBGL2,
        w.STRICT_TEXTURE_CACHE = !1,
        w.RENDER_OPTIONS = {
            ...Fr.defaultOptions,
            ...kr.defaultOptions,
            ...Wn.defaultOptions,
            ...Fn.defaultOptions
        },
        Object.defineProperties(w, {
            WRAP_MODE: {
                get() {
                    return Pe.defaultOptions.wrapMode
                },
                set(t) {
                    Z("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"),
                    Pe.defaultOptions.wrapMode = t
                }
            },
            SCALE_MODE: {
                get() {
                    return Pe.defaultOptions.scaleMode
                },
                set(t) {
                    Z("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"),
                    Pe.defaultOptions.scaleMode = t
                }
            },
            MIPMAP_TEXTURES: {
                get() {
                    return Pe.defaultOptions.mipmap
                },
                set(t) {
                    Z("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"),
                    Pe.defaultOptions.mipmap = t
                }
            },
            ANISOTROPIC_LEVEL: {
                get() {
                    return Pe.defaultOptions.anisotropicLevel
                },
                set(t) {
                    Z("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"),
                    Pe.defaultOptions.anisotropicLevel = t
                }
            },
            FILTER_RESOLUTION: {
                get() {
                    return Z("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"),
                    Br.defaultResolution
                },
                set(t) {
                    Br.defaultResolution = t
                }
            },
            FILTER_MULTISAMPLE: {
                get() {
                    return Z("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"),
                    Br.defaultMultisample
                },
                set(t) {
                    Br.defaultMultisample = t
                }
            },
            SPRITE_MAX_TEXTURES: {
                get() {
                    return Dr.defaultMaxTextures
                },
                set(t) {
                    Z("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"),
                    Dr.defaultMaxTextures = t
                }
            },
            SPRITE_BATCH_SIZE: {
                get() {
                    return Dr.defaultBatchSize
                },
                set(t) {
                    Z("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"),
                    Dr.defaultBatchSize = t
                }
            },
            CAN_UPLOAD_SAME_BUFFER: {
                get() {
                    return Dr.canUploadSameBuffer
                },
                set(t) {
                    Z("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"),
                    Dr.canUploadSameBuffer = t
                }
            },
            GC_MODE: {
                get() {
                    return Hn.defaultMode
                },
                set(t) {
                    Z("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"),
                    Hn.defaultMode = t
                }
            },
            GC_MAX_IDLE: {
                get() {
                    return Hn.defaultMaxIdle
                },
                set(t) {
                    Z("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"),
                    Hn.defaultMaxIdle = t
                }
            },
            GC_MAX_CHECK_COUNT: {
                get() {
                    return Hn.defaultCheckCountMax
                },
                set(t) {
                    Z("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"),
                    Hn.defaultCheckCountMax = t
                }
            },
            PRECISION_VERTEX: {
                get() {
                    return wr.defaultVertexPrecision
                },
                set(t) {
                    Z("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"),
                    wr.defaultVertexPrecision = t
                }
            },
            PRECISION_FRAGMENT: {
                get() {
                    return wr.defaultFragmentPrecision
                },
                set(t) {
                    Z("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"),
                    wr.defaultFragmentPrecision = t
                }
            }
        });
        var Yn = (t => (t[t.INTERACTION = 50] = "INTERACTION",
        t[t.HIGH = 25] = "HIGH",
        t[t.NORMAL = 0] = "NORMAL",
        t[t.LOW = -25] = "LOW",
        t[t.UTILITY = -50] = "UTILITY",
        t))(Yn || {});
        class qn {
            constructor(t, e=null, r=0, n=!1) {
                this.next = null,
                this.previous = null,
                this._destroyed = !1,
                this.fn = t,
                this.context = e,
                this.priority = r,
                this.once = n
            }
            match(t, e=null) {
                return this.fn === t && this.context === e
            }
            emit(t) {
                this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
                const e = this.next;
                return this.once && this.destroy(!0),
                this._destroyed && (this.next = null),
                e
            }
            connect(t) {
                this.previous = t,
                t.next && (t.next.previous = this),
                this.next = t.next,
                t.next = this
            }
            destroy(t=!1) {
                this._destroyed = !0,
                this.fn = null,
                this.context = null,
                this.previous && (this.previous.next = this.next),
                this.next && (this.next.previous = this.previous);
                const e = this.next;
                return this.next = t ? null : e,
                this.previous = null,
                e
            }
        }
        const Kn = class {
            constructor() {
                this.autoStart = !1,
                this.deltaTime = 1,
                this.lastTime = -1,
                this.speed = 1,
                this.started = !1,
                this._requestId = null,
                this._maxElapsedMS = 100,
                this._minElapsedMS = 0,
                this._protected = !1,
                this._lastFrame = -1,
                this._head = new qn(null,null,1 / 0),
                this.deltaMS = 1 / Kn.targetFPMS,
                this.elapsedMS = 1 / Kn.targetFPMS,
                this._tick = t => {
                    this._requestId = null,
                    this.started && (this.update(t),
                    this.started && null === this._requestId && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
                }
            }
            _requestIfNeeded() {
                null === this._requestId && this._head.next && (this.lastTime = performance.now(),
                this._lastFrame = this.lastTime,
                this._requestId = requestAnimationFrame(this._tick))
            }
            _cancelIfNeeded() {
                null !== this._requestId && (cancelAnimationFrame(this._requestId),
                this._requestId = null)
            }
            _startIfPossible() {
                this.started ? this._requestIfNeeded() : this.autoStart && this.start()
            }
            add(t, e, r=Yn.NORMAL) {
                return this._addListener(new qn(t,e,r))
            }
            addOnce(t, e, r=Yn.NORMAL) {
                return this._addListener(new qn(t,e,r,!0))
            }
            _addListener(t) {
                let e = this._head.next
                  , r = this._head;
                if (e) {
                    for (; e; ) {
                        if (t.priority > e.priority) {
                            t.connect(r);
                            break
                        }
                        r = e,
                        e = e.next
                    }
                    t.previous || t.connect(r)
                } else
                    t.connect(r);
                return this._startIfPossible(),
                this
            }
            remove(t, e) {
                let r = this._head.next;
                for (; r; )
                    r = r.match(t, e) ? r.destroy() : r.next;
                return this._head.next || this._cancelIfNeeded(),
                this
            }
            get count() {
                if (!this._head)
                    return 0;
                let t = 0
                  , e = this._head;
                for (; e = e.next; )
                    t++;
                return t
            }
            start() {
                this.started || (this.started = !0,
                this._requestIfNeeded())
            }
            stop() {
                this.started && (this.started = !1,
                this._cancelIfNeeded())
            }
            destroy() {
                if (!this._protected) {
                    this.stop();
                    let t = this._head.next;
                    for (; t; )
                        t = t.destroy(!0);
                    this._head.destroy(),
                    this._head = null
                }
            }
            update(t=performance.now()) {
                let e;
                if (t > this.lastTime) {
                    if (e = this.elapsedMS = t - this.lastTime,
                    e > this._maxElapsedMS && (e = this._maxElapsedMS),
                    e *= this.speed,
                    this._minElapsedMS) {
                        const e = t - this._lastFrame | 0;
                        if (e < this._minElapsedMS)
                            return;
                        this._lastFrame = t - e % this._minElapsedMS
                    }
                    this.deltaMS = e,
                    this.deltaTime = this.deltaMS * Kn.targetFPMS;
                    const r = this._head;
                    let n = r.next;
                    for (; n; )
                        n = n.emit(this.deltaTime);
                    r.next || this._cancelIfNeeded()
                } else
                    this.deltaTime = this.deltaMS = this.elapsedMS = 0;
                this.lastTime = t
            }
            get FPS() {
                return 1e3 / this.elapsedMS
            }
            get minFPS() {
                return 1e3 / this._maxElapsedMS
            }
            set minFPS(t) {
                const e = Math.min(this.maxFPS, t)
                  , r = Math.min(Math.max(0, e) / 1e3, Kn.targetFPMS);
                this._maxElapsedMS = 1 / r
            }
            get maxFPS() {
                return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
            }
            set maxFPS(t) {
                if (0 === t)
                    this._minElapsedMS = 0;
                else {
                    const e = Math.max(this.minFPS, t);
                    this._minElapsedMS = 1 / (e / 1e3)
                }
            }
            static get shared() {
                if (!Kn._shared) {
                    const t = Kn._shared = new Kn;
                    t.autoStart = !0,
                    t._protected = !0
                }
                return Kn._shared
            }
            static get system() {
                if (!Kn._system) {
                    const t = Kn._system = new Kn;
                    t.autoStart = !0,
                    t._protected = !0
                }
                return Kn._system
            }
        }
        ;
        let Zn = Kn;
        Zn.targetFPMS = .06,
        Object.defineProperties(w, {
            TARGET_FPMS: {
                get() {
                    return Zn.targetFPMS
                },
                set(t) {
                    Z("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"),
                    Zn.targetFPMS = t
                }
            }
        });
        class Jn {
            static init(t) {
                t = Object.assign({
                    autoStart: !0,
                    sharedTicker: !1
                }, t),
                Object.defineProperty(this, "ticker", {
                    set(t) {
                        this._ticker && this._ticker.remove(this.render, this),
                        this._ticker = t,
                        t && t.add(this.render, this, Yn.LOW)
                    },
                    get() {
                        return this._ticker
                    }
                }),
                this.stop = () => {
                    this._ticker.stop()
                }
                ,
                this.start = () => {
                    this._ticker.start()
                }
                ,
                this._ticker = null,
                this.ticker = t.sharedTicker ? Zn.shared : new Zn,
                t.autoStart && this.start()
            }
            static destroy() {
                if (this._ticker) {
                    const t = this._ticker;
                    this.ticker = null,
                    t.destroy()
                }
            }
        }
        Jn.extension = pe.Application,
        ve.add(Jn);
        const Qn = [];
        function ti(t) {
            for (const e of Qn)
                if (e.test(t))
                    return new e(t);
            throw new Error("Unable to auto-detect a suitable renderer.")
        }
        ve.handleByList(pe.Renderer, Qn);
        const ei = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}"
          , ri = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
        class ni {
            constructor(t) {
                this.renderer = t
            }
            contextChange(t) {
                let e;
                if (1 === this.renderer.context.webGLVersion) {
                    const r = t.getParameter(t.FRAMEBUFFER_BINDING);
                    t.bindFramebuffer(t.FRAMEBUFFER, null),
                    e = t.getParameter(t.SAMPLES),
                    t.bindFramebuffer(t.FRAMEBUFFER, r)
                } else {
                    const r = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
                    t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                    e = t.getParameter(t.SAMPLES),
                    t.bindFramebuffer(t.DRAW_FRAMEBUFFER, r)
                }
                e >= b.HIGH ? this.multisample = b.HIGH : e >= b.MEDIUM ? this.multisample = b.MEDIUM : e >= b.LOW ? this.multisample = b.LOW : this.multisample = b.NONE
            }
            destroy() {}
        }
        ni.extension = {
            type: pe.RendererSystem,
            name: "_multisample"
        },
        ve.add(ni);
        class ii {
            constructor(t) {
                this.buffer = t || null,
                this.updateID = -1,
                this.byteLength = -1,
                this.refCount = 0
            }
        }
        class si {
            constructor(t) {
                this.renderer = t,
                this.managedBuffers = {},
                this.boundBufferBases = {}
            }
            destroy() {
                this.renderer = null
            }
            contextChange() {
                this.disposeAll(!0),
                this.gl = this.renderer.gl,
                this.CONTEXT_UID = this.renderer.CONTEXT_UID
            }
            bind(t) {
                const {gl: e, CONTEXT_UID: r} = this
                  , n = t._glBuffers[r] || this.createGLBuffer(t);
                e.bindBuffer(t.type, n.buffer)
            }
            unbind(t) {
                const {gl: e} = this;
                e.bindBuffer(t, null)
            }
            bindBufferBase(t, e) {
                const {gl: r, CONTEXT_UID: n} = this;
                if (this.boundBufferBases[e] !== t) {
                    const i = t._glBuffers[n] || this.createGLBuffer(t);
                    this.boundBufferBases[e] = t,
                    r.bindBufferBase(r.UNIFORM_BUFFER, e, i.buffer)
                }
            }
            bindBufferRange(t, e, r) {
                const {gl: n, CONTEXT_UID: i} = this;
                r = r || 0;
                const s = t._glBuffers[i] || this.createGLBuffer(t);
                n.bindBufferRange(n.UNIFORM_BUFFER, e || 0, s.buffer, 256 * r, 256)
            }
            update(t) {
                const {gl: e, CONTEXT_UID: r} = this
                  , n = t._glBuffers[r] || this.createGLBuffer(t);
                if (t._updateID !== n.updateID)
                    if (n.updateID = t._updateID,
                    e.bindBuffer(t.type, n.buffer),
                    n.byteLength >= t.data.byteLength)
                        e.bufferSubData(t.type, 0, t.data);
                    else {
                        const r = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
                        n.byteLength = t.data.byteLength,
                        e.bufferData(t.type, t.data, r)
                    }
            }
            dispose(t, e) {
                if (!this.managedBuffers[t.id])
                    return;
                delete this.managedBuffers[t.id];
                const r = t._glBuffers[this.CONTEXT_UID]
                  , n = this.gl;
                t.disposeRunner.remove(this),
                r && (e || n.deleteBuffer(r.buffer),
                delete t._glBuffers[this.CONTEXT_UID])
            }
            disposeAll(t) {
                const e = Object.keys(this.managedBuffers);
                for (let r = 0; r < e.length; r++)
                    this.dispose(this.managedBuffers[e[r]], t)
            }
            createGLBuffer(t) {
                const {CONTEXT_UID: e, gl: r} = this;
                return t._glBuffers[e] = new ii(r.createBuffer()),
                this.managedBuffers[t.id] = t,
                t.disposeRunner.add(this),
                t._glBuffers[e]
            }
        }
        si.extension = {
            type: pe.RendererSystem,
            name: "buffer"
        },
        ve.add(si);
        class oi {
            constructor(t) {
                this.renderer = t
            }
            render(t, e) {
                const r = this.renderer;
                let n, i, s, o;
                if (e && (n = e.renderTexture,
                i = e.clear,
                s = e.transform,
                o = e.skipUpdateTransform),
                this.renderingToScreen = !n,
                r.runners.prerender.emit(),
                r.emit("prerender"),
                r.projection.transform = s,
                !r.context.isLost) {
                    if (n || (this.lastObjectRendered = t),
                    !o) {
                        const e = t.enableTempParent();
                        t.updateTransform(),
                        t.disableTempParent(e)
                    }
                    r.renderTexture.bind(n),
                    r.batch.currentRenderer.start(),
                    (i ?? r.background.clearBeforeRender) && r.renderTexture.clear(),
                    t.render(r),
                    r.batch.currentRenderer.flush(),
                    n && (e.blit && r.framebuffer.blit(),
                    n.baseTexture.update()),
                    r.runners.postrender.emit(),
                    r.projection.transform = null,
                    r.emit("postrender")
                }
            }
            destroy() {
                this.renderer = null,
                this.lastObjectRendered = null
            }
        }
        oi.extension = {
            type: pe.RendererSystem,
            name: "objectRenderer"
        },
        ve.add(oi);
        const ai = class extends jn {
            constructor(t) {
                super(),
                this.type = s.WEBGL,
                t = Object.assign({}, w.RENDER_OPTIONS, t),
                this.gl = null,
                this.CONTEXT_UID = 0,
                this.globalUniforms = new Ar({
                    projectionMatrix: new Ze
                },!0);
                const e = {
                    runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
                    systems: ai.__systems,
                    priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
                };
                this.setup(e),
                "useContextAlpha"in t && (Z("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"),
                t.premultipliedAlpha = t.useContextAlpha && "notMultiplied" !== t.useContextAlpha,
                t.backgroundAlpha = !1 === t.useContextAlpha ? 1 : t.backgroundAlpha),
                this._plugin.rendererPlugins = ai.__plugins,
                this.options = t,
                this.startup.run(this.options)
            }
            static test(t) {
                return !t?.forceCanvas && et()
            }
            render(t, e) {
                this.objectRenderer.render(t, e)
            }
            resize(t, e) {
                this._view.resizeView(t, e)
            }
            reset() {
                return this.runners.reset.emit(),
                this
            }
            clear() {
                this.renderTexture.bind(),
                this.renderTexture.clear()
            }
            destroy(t=!1) {
                this.runners.destroy.items.reverse(),
                this.emitWithCustomOptions(this.runners.destroy, {
                    _view: t
                }),
                super.destroy()
            }
            get plugins() {
                return this._plugin.plugins
            }
            get multisample() {
                return this._multisample.multisample
            }
            get width() {
                return this._view.element.width
            }
            get height() {
                return this._view.element.height
            }
            get resolution() {
                return this._view.resolution
            }
            set resolution(t) {
                this._view.resolution = t,
                this.runners.resolutionChange.emit(t)
            }
            get autoDensity() {
                return this._view.autoDensity
            }
            get view() {
                return this._view.element
            }
            get screen() {
                return this._view.screen
            }
            get lastObjectRendered() {
                return this.objectRenderer.lastObjectRendered
            }
            get renderingToScreen() {
                return this.objectRenderer.renderingToScreen
            }
            get rendererLogId() {
                return `WebGL ${this.context.webGLVersion}`
            }
            get clearBeforeRender() {
                return Z("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."),
                this.background.clearBeforeRender
            }
            get useContextAlpha() {
                return Z("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."),
                this.context.useContextAlpha
            }
            get preserveDrawingBuffer() {
                return Z("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"),
                this.context.preserveDrawingBuffer
            }
            get backgroundColor() {
                return Z("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
                this.background.color
            }
            set backgroundColor(t) {
                Z("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
                this.background.color = t
            }
            get backgroundAlpha() {
                return Z("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
                this.background.alpha
            }
            set backgroundAlpha(t) {
                Z("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
                this.background.alpha = t
            }
            get powerPreference() {
                return Z("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"),
                this.context.powerPreference
            }
            generateTexture(t, e) {
                return this.textureGenerator.generateTexture(t, e)
            }
        }
        ;
        let hi = ai;
        hi.extension = {
            type: pe.Renderer,
            priority: 1
        },
        hi.__plugins = {},
        hi.__systems = {},
        ve.handleByMap(pe.RendererPlugin, hi.__plugins),
        ve.handleByMap(pe.RendererSystem, hi.__systems),
        ve.add(hi);
        class li extends Se {
            constructor(t, e) {
                const {width: r, height: n} = e || {};
                super(r, n),
                this.items = [],
                this.itemDirtyIds = [];
                for (let e = 0; e < t; e++) {
                    const t = new Pe;
                    this.items.push(t),
                    this.itemDirtyIds.push(-2)
                }
                this.length = t,
                this._load = null,
                this.baseTexture = null
            }
            initFromArray(t, e) {
                for (let r = 0; r < this.length; r++)
                    t[r] && (t[r].castToBaseTexture ? this.addBaseTextureAt(t[r].castToBaseTexture(), r) : t[r]instanceof Se ? this.addResourceAt(t[r], r) : this.addResourceAt(Te(t[r], e), r))
            }
            dispose() {
                for (let t = 0, e = this.length; t < e; t++)
                    this.items[t].destroy();
                this.items = null,
                this.itemDirtyIds = null,
                this._load = null
            }
            addResourceAt(t, e) {
                if (!this.items[e])
                    throw new Error(`Index ${e} is out of bounds`);
                return t.valid && !this.valid && this.resize(t.width, t.height),
                this.items[e].setResource(t),
                this
            }
            bind(t) {
                if (null !== this.baseTexture)
                    throw new Error("Only one base texture per TextureArray is allowed");
                super.bind(t);
                for (let e = 0; e < this.length; e++)
                    this.items[e].parentTextureArray = t,
                    this.items[e].on("update", t.update, t)
            }
            unbind(t) {
                super.unbind(t);
                for (let e = 0; e < this.length; e++)
                    this.items[e].parentTextureArray = null,
                    this.items[e].off("update", t.update, t)
            }
            load() {
                if (this._load)
                    return this._load;
                const t = this.items.map((t => t.resource)).filter((t => t)).map((t => t.load()));
                return this._load = Promise.all(t).then(( () => {
                    const {realWidth: t, realHeight: e} = this.items[0];
                    return this.resize(t, e),
                    Promise.resolve(this)
                }
                )),
                this._load
            }
        }
        const ui = class extends li {
            constructor(t, e) {
                const {width: r, height: n, autoLoad: i, linkBaseTexture: s} = e || {};
                if (t && t.length !== ui.SIDES)
                    throw new Error(`Invalid length. Got ${t.length}, expected 6`);
                super(6, {
                    width: r,
                    height: n
                });
                for (let t = 0; t < ui.SIDES; t++)
                    this.items[t].target = u.TEXTURE_CUBE_MAP_POSITIVE_X + t;
                this.linkBaseTexture = !1 !== s,
                t && this.initFromArray(t, e),
                !1 !== i && this.load()
            }
            bind(t) {
                super.bind(t),
                t.target = u.TEXTURE_CUBE_MAP
            }
            addBaseTextureAt(t, e, r) {
                if (void 0 === r && (r = this.linkBaseTexture),
                !this.items[e])
                    throw new Error(`Index ${e} is out of bounds`);
                if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0) {
                    if (!t.resource)
                        throw new Error("CubeResource does not support copying of renderTexture.");
                    this.addResourceAt(t.resource, e)
                } else
                    t.target = u.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    t.parentTextureArray = this.baseTexture,
                    this.items[e] = t;
                return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
                this.items[e] = t,
                this
            }
            upload(t, e, r) {
                const n = this.itemDirtyIds;
                for (let i = 0; i < ui.SIDES; i++) {
                    const s = this.items[i];
                    (n[i] < s.dirtyId || r.dirtyId < e.dirtyId) && (s.valid && s.resource ? (s.resource.upload(t, s, r),
                    n[i] = s.dirtyId) : n[i] < -1 && (t.gl.texImage2D(s.target, 0, r.internalFormat, e.realWidth, e.realHeight, 0, e.format, r.type, null),
                    n[i] = -1))
                }
                return !0
            }
            static test(t) {
                return Array.isArray(t) && t.length === ui.SIDES
            }
        }
        ;
        let ci = ui;
        ci.SIDES = 6;
        class di extends zr {
            constructor(t, e) {
                let r, n;
                e = e || {},
                "string" == typeof t ? (r = di.EMPTY,
                n = t) : (r = t,
                n = null),
                super(r),
                this.url = n,
                this.crossOrigin = e.crossOrigin ?? !0,
                this.alphaMode = "number" == typeof e.alphaMode ? e.alphaMode : null,
                this._load = null,
                !1 !== e.autoLoad && this.load()
            }
            load() {
                return this._load || (this._load = new Promise((async (t, e) => {
                    if (null !== this.url)
                        try {
                            const e = await w.ADAPTER.fetch(this.url, {
                                mode: this.crossOrigin ? "cors" : "no-cors"
                            });
                            if (this.destroyed)
                                return;
                            const r = await e.blob();
                            if (this.destroyed)
                                return;
                            const n = await createImageBitmap(r, {
                                premultiplyAlpha: null === this.alphaMode || this.alphaMode === g.UNPACK ? "premultiply" : "none"
                            });
                            if (this.destroyed)
                                return;
                            this.source = n,
                            this.update(),
                            t(this)
                        } catch (t) {
                            if (this.destroyed)
                                return;
                            e(t),
                            this.onError.emit(t)
                        }
                    else
                        t(this)
                }
                ))),
                this._load
            }
            upload(t, e, r) {
                return this.source instanceof ImageBitmap ? ("number" == typeof this.alphaMode && (e.alphaMode = this.alphaMode),
                super.upload(t, e, r)) : (this.load(),
                !1)
            }
            dispose() {
                this.source instanceof ImageBitmap && this.source.close(),
                super.dispose(),
                this._load = null
            }
            static test(t) {
                return !!globalThis.createImageBitmap && "undefined" != typeof ImageBitmap && ("string" == typeof t || t instanceof ImageBitmap)
            }
            static get EMPTY() {
                return di._EMPTY = di._EMPTY ?? w.ADAPTER.createCanvas(0, 0),
                di._EMPTY
            }
        }
        const fi = class extends zr {
            constructor(t, e) {
                e = e || {},
                super(w.ADAPTER.createCanvas()),
                this._width = 0,
                this._height = 0,
                this.svg = t,
                this.scale = e.scale || 1,
                this._overrideWidth = e.width,
                this._overrideHeight = e.height,
                this._resolve = null,
                this._crossorigin = e.crossorigin,
                this._load = null,
                !1 !== e.autoLoad && this.load()
            }
            load() {
                return this._load || (this._load = new Promise((t => {
                    if (this._resolve = () => {
                        this.resize(this.source.width, this.source.height),
                        t(this)
                    }
                    ,
                    fi.SVG_XML.test(this.svg.trim())) {
                        if (!btoa)
                            throw new Error("Your browser doesn't support base64 conversions.");
                        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
                    }
                    this._loadSvg()
                }
                ))),
                this._load
            }
            _loadSvg() {
                const t = new Image;
                zr.crossOrigin(t, this.svg, this._crossorigin),
                t.src = this.svg,
                t.onerror = e => {
                    this._resolve && (t.onerror = null,
                    this.onError.emit(e))
                }
                ,
                t.onload = () => {
                    if (!this._resolve)
                        return;
                    const e = t.width
                      , r = t.height;
                    if (!e || !r)
                        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
                    let n = e * this.scale
                      , i = r * this.scale;
                    (this._overrideWidth || this._overrideHeight) && (n = this._overrideWidth || this._overrideHeight / r * e,
                    i = this._overrideHeight || this._overrideWidth / e * r),
                    n = Math.round(n),
                    i = Math.round(i);
                    const s = this.source;
                    s.width = n,
                    s.height = i,
                    s._pixiId = `canvas_${Zt()}`,
                    s.getContext("2d").drawImage(t, 0, 0, e, r, 0, 0, n, i),
                    this._resolve(),
                    this._resolve = null
                }
            }
            static getSize(t) {
                const e = fi.SVG_SIZE.exec(t)
                  , r = {};
                return e && (r[e[1]] = Math.round(parseFloat(e[3])),
                r[e[5]] = Math.round(parseFloat(e[7]))),
                r
            }
            dispose() {
                super.dispose(),
                this._resolve = null,
                this._crossorigin = null
            }
            static test(t, e) {
                return "svg" === e || "string" == typeof t && t.startsWith("data:image/svg+xml") || "string" == typeof t && fi.SVG_XML.test(t)
            }
        }
        ;
        let pi = fi;
        pi.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,
        pi.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
        const mi = class extends zr {
            constructor(t, e) {
                if (e = e || {},
                !(t instanceof HTMLVideoElement)) {
                    const r = document.createElement("video");
                    r.setAttribute("preload", "auto"),
                    r.setAttribute("webkit-playsinline", ""),
                    r.setAttribute("playsinline", ""),
                    "string" == typeof t && (t = [t]);
                    const n = t[0].src || t[0];
                    zr.crossOrigin(r, n, e.crossorigin);
                    for (let e = 0; e < t.length; ++e) {
                        const n = document.createElement("source");
                        let {src: i, mime: s} = t[e];
                        i = i || t[e];
                        const o = i.split("?").shift().toLowerCase()
                          , a = o.slice(o.lastIndexOf(".") + 1);
                        s = s || mi.MIME_TYPES[a] || `video/${a}`,
                        n.src = i,
                        n.type = s,
                        r.appendChild(n)
                    }
                    t = r
                }
                super(t),
                this.noSubImage = !0,
                this._autoUpdate = !0,
                this._isConnectedToTicker = !1,
                this._updateFPS = e.updateFPS || 0,
                this._msToNextUpdate = 0,
                this.autoPlay = !1 !== e.autoPlay,
                this._load = null,
                this._resolve = null,
                this._onCanPlay = this._onCanPlay.bind(this),
                this._onError = this._onError.bind(this),
                !1 !== e.autoLoad && this.load()
            }
            update(t=0) {
                if (!this.destroyed) {
                    const t = Zn.shared.elapsedMS * this.source.playbackRate;
                    this._msToNextUpdate = Math.floor(this._msToNextUpdate - t),
                    (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(),
                    this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
                }
            }
            load() {
                if (this._load)
                    return this._load;
                const t = this.source;
                return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0),
                t.addEventListener("play", this._onPlayStart.bind(this)),
                t.addEventListener("pause", this._onPlayStop.bind(this)),
                this._isSourceReady() ? this._onCanPlay() : (t.addEventListener("canplay", this._onCanPlay),
                t.addEventListener("canplaythrough", this._onCanPlay),
                t.addEventListener("error", this._onError, !0)),
                this._load = new Promise((e => {
                    this.valid ? e(this) : (this._resolve = e,
                    t.load())
                }
                )),
                this._load
            }
            _onError(t) {
                this.source.removeEventListener("error", this._onError, !0),
                this.onError.emit(t)
            }
            _isSourcePlaying() {
                const t = this.source;
                return !t.paused && !t.ended && this._isSourceReady()
            }
            _isSourceReady() {
                return this.source.readyState > 2
            }
            _onPlayStart() {
                this.valid || this._onCanPlay(),
                this.autoUpdate && !this._isConnectedToTicker && (Zn.shared.add(this.update, this),
                this._isConnectedToTicker = !0)
            }
            _onPlayStop() {
                this._isConnectedToTicker && (Zn.shared.remove(this.update, this),
                this._isConnectedToTicker = !1)
            }
            _onCanPlay() {
                const t = this.source;
                t.removeEventListener("canplay", this._onCanPlay),
                t.removeEventListener("canplaythrough", this._onCanPlay);
                const e = this.valid;
                this.resize(t.videoWidth, t.videoHeight),
                !e && this._resolve && (this._resolve(this),
                this._resolve = null),
                this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
            }
            dispose() {
                this._isConnectedToTicker && (Zn.shared.remove(this.update, this),
                this._isConnectedToTicker = !1);
                const t = this.source;
                t && (t.removeEventListener("error", this._onError, !0),
                t.pause(),
                t.src = "",
                t.load()),
                super.dispose()
            }
            get autoUpdate() {
                return this._autoUpdate
            }
            set autoUpdate(t) {
                t !== this._autoUpdate && (this._autoUpdate = t,
                !this._autoUpdate && this._isConnectedToTicker ? (Zn.shared.remove(this.update, this),
                this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Zn.shared.add(this.update, this),
                this._isConnectedToTicker = !0))
            }
            get updateFPS() {
                return this._updateFPS
            }
            set updateFPS(t) {
                t !== this._updateFPS && (this._updateFPS = t)
            }
            static test(t, e) {
                return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || mi.TYPES.includes(e)
            }
        }
        ;
        let gi = mi;
        gi.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"],
        gi.MIME_TYPES = {
            ogv: "video/ogg",
            mov: "video/quicktime",
            m4v: "video/mp4"
        },
        Ee.push(di, Hr, class extends zr {
            constructor(t) {
                super(t)
            }
            static test(t) {
                const {OffscreenCanvas: e} = globalThis;
                return !!(e && t instanceof e) || globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
            }
        }
        , gi, pi, Ae, ci, class extends li {
            constructor(t, e) {
                const {width: r, height: n} = e || {};
                let i, s;
                Array.isArray(t) ? (i = t,
                s = t.length) : s = t,
                super(s, {
                    width: r,
                    height: n
                }),
                i && this.initFromArray(i, e)
            }
            addBaseTextureAt(t, e) {
                if (!t.resource)
                    throw new Error("ArrayResource does not support RenderTexture");
                return this.addResourceAt(t.resource, e),
                this
            }
            bind(t) {
                super.bind(t),
                t.target = u.TEXTURE_2D_ARRAY
            }
            upload(t, e, r) {
                const {length: n, itemDirtyIds: i, items: s} = this
                  , {gl: o} = t;
                r.dirtyId < 0 && o.texImage3D(o.TEXTURE_2D_ARRAY, 0, r.internalFormat, this._width, this._height, n, 0, e.format, r.type, null);
                for (let t = 0; t < n; t++) {
                    const n = s[t];
                    i[t] < n.dirtyId && (i[t] = n.dirtyId,
                    n.valid && o.texSubImage3D(o.TEXTURE_2D_ARRAY, 0, 0, 0, t, n.resource.width, n.resource.height, 1, e.format, r.type, n.resource.source))
                }
                return !0
            }
        }
        )
    },
    58820: function(t, e, r) {
        "use strict";
        r.d(e, {
            YZ: function() {
                return i
            },
            W2: function() {
                return u
            },
            s$: function() {
                return s
            }
        });
        var n = r(33813);
        class i {
            constructor() {
                this.minX = 1 / 0,
                this.minY = 1 / 0,
                this.maxX = -1 / 0,
                this.maxY = -1 / 0,
                this.rect = null,
                this.updateID = -1
            }
            isEmpty() {
                return this.minX > this.maxX || this.minY > this.maxY
            }
            clear() {
                this.minX = 1 / 0,
                this.minY = 1 / 0,
                this.maxX = -1 / 0,
                this.maxY = -1 / 0
            }
            getRectangle(t) {
                return this.minX > this.maxX || this.minY > this.maxY ? n.Ae.EMPTY : ((t = t || new n.Ae(0,0,1,1)).x = this.minX,
                t.y = this.minY,
                t.width = this.maxX - this.minX,
                t.height = this.maxY - this.minY,
                t)
            }
            addPoint(t) {
                this.minX = Math.min(this.minX, t.x),
                this.maxX = Math.max(this.maxX, t.x),
                this.minY = Math.min(this.minY, t.y),
                this.maxY = Math.max(this.maxY, t.y)
            }
            addPointMatrix(t, e) {
                const {a: r, b: n, c: i, d: s, tx: o, ty: a} = t
                  , h = r * e.x + i * e.y + o
                  , l = n * e.x + s * e.y + a;
                this.minX = Math.min(this.minX, h),
                this.maxX = Math.max(this.maxX, h),
                this.minY = Math.min(this.minY, l),
                this.maxY = Math.max(this.maxY, l)
            }
            addQuad(t) {
                let e = this.minX
                  , r = this.minY
                  , n = this.maxX
                  , i = this.maxY
                  , s = t[0]
                  , o = t[1];
                e = s < e ? s : e,
                r = o < r ? o : r,
                n = s > n ? s : n,
                i = o > i ? o : i,
                s = t[2],
                o = t[3],
                e = s < e ? s : e,
                r = o < r ? o : r,
                n = s > n ? s : n,
                i = o > i ? o : i,
                s = t[4],
                o = t[5],
                e = s < e ? s : e,
                r = o < r ? o : r,
                n = s > n ? s : n,
                i = o > i ? o : i,
                s = t[6],
                o = t[7],
                e = s < e ? s : e,
                r = o < r ? o : r,
                n = s > n ? s : n,
                i = o > i ? o : i,
                this.minX = e,
                this.minY = r,
                this.maxX = n,
                this.maxY = i
            }
            addFrame(t, e, r, n, i) {
                this.addFrameMatrix(t.worldTransform, e, r, n, i)
            }
            addFrameMatrix(t, e, r, n, i) {
                const s = t.a
                  , o = t.b
                  , a = t.c
                  , h = t.d
                  , l = t.tx
                  , u = t.ty;
                let c = this.minX
                  , d = this.minY
                  , f = this.maxX
                  , p = this.maxY
                  , m = s * e + a * r + l
                  , g = o * e + h * r + u;
                c = m < c ? m : c,
                d = g < d ? g : d,
                f = m > f ? m : f,
                p = g > p ? g : p,
                m = s * n + a * r + l,
                g = o * n + h * r + u,
                c = m < c ? m : c,
                d = g < d ? g : d,
                f = m > f ? m : f,
                p = g > p ? g : p,
                m = s * e + a * i + l,
                g = o * e + h * i + u,
                c = m < c ? m : c,
                d = g < d ? g : d,
                f = m > f ? m : f,
                p = g > p ? g : p,
                m = s * n + a * i + l,
                g = o * n + h * i + u,
                c = m < c ? m : c,
                d = g < d ? g : d,
                f = m > f ? m : f,
                p = g > p ? g : p,
                this.minX = c,
                this.minY = d,
                this.maxX = f,
                this.maxY = p
            }
            addVertexData(t, e, r) {
                let n = this.minX
                  , i = this.minY
                  , s = this.maxX
                  , o = this.maxY;
                for (let a = e; a < r; a += 2) {
                    const e = t[a]
                      , r = t[a + 1];
                    n = e < n ? e : n,
                    i = r < i ? r : i,
                    s = e > s ? e : s,
                    o = r > o ? r : o
                }
                this.minX = n,
                this.minY = i,
                this.maxX = s,
                this.maxY = o
            }
            addVertices(t, e, r, n) {
                this.addVerticesMatrix(t.worldTransform, e, r, n)
            }
            addVerticesMatrix(t, e, r, n, i=0, s=i) {
                const o = t.a
                  , a = t.b
                  , h = t.c
                  , l = t.d
                  , u = t.tx
                  , c = t.ty;
                let d = this.minX
                  , f = this.minY
                  , p = this.maxX
                  , m = this.maxY;
                for (let t = r; t < n; t += 2) {
                    const r = e[t]
                      , n = e[t + 1]
                      , g = o * r + h * n + u
                      , v = l * n + a * r + c;
                    d = Math.min(d, g - i),
                    p = Math.max(p, g + i),
                    f = Math.min(f, v - s),
                    m = Math.max(m, v + s)
                }
                this.minX = d,
                this.minY = f,
                this.maxX = p,
                this.maxY = m
            }
            addBounds(t) {
                const e = this.minX
                  , r = this.minY
                  , n = this.maxX
                  , i = this.maxY;
                this.minX = t.minX < e ? t.minX : e,
                this.minY = t.minY < r ? t.minY : r,
                this.maxX = t.maxX > n ? t.maxX : n,
                this.maxY = t.maxY > i ? t.maxY : i
            }
            addBoundsMask(t, e) {
                const r = t.minX > e.minX ? t.minX : e.minX
                  , n = t.minY > e.minY ? t.minY : e.minY
                  , i = t.maxX < e.maxX ? t.maxX : e.maxX
                  , s = t.maxY < e.maxY ? t.maxY : e.maxY;
                if (r <= i && n <= s) {
                    const t = this.minX
                      , e = this.minY
                      , o = this.maxX
                      , a = this.maxY;
                    this.minX = r < t ? r : t,
                    this.minY = n < e ? n : e,
                    this.maxX = i > o ? i : o,
                    this.maxY = s > a ? s : a
                }
            }
            addBoundsMatrix(t, e) {
                this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
            }
            addBoundsArea(t, e) {
                const r = t.minX > e.x ? t.minX : e.x
                  , n = t.minY > e.y ? t.minY : e.y
                  , i = t.maxX < e.x + e.width ? t.maxX : e.x + e.width
                  , s = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
                if (r <= i && n <= s) {
                    const t = this.minX
                      , e = this.minY
                      , o = this.maxX
                      , a = this.maxY;
                    this.minX = r < t ? r : t,
                    this.minY = n < e ? n : e,
                    this.maxX = i > o ? i : o,
                    this.maxY = s > a ? s : a
                }
            }
            pad(t=0, e=t) {
                this.isEmpty() || (this.minX -= t,
                this.maxX += t,
                this.minY -= e,
                this.maxY += e)
            }
            addFramePad(t, e, r, n, i, s) {
                t -= i,
                e -= s,
                r += i,
                n += s,
                this.minX = this.minX < t ? this.minX : t,
                this.maxX = this.maxX > r ? this.maxX : r,
                this.minY = this.minY < e ? this.minY : e,
                this.maxY = this.maxY > n ? this.maxY : n
            }
        }
        class s extends n.P6.EventEmitter {
            constructor() {
                super(),
                this.tempDisplayObjectParent = null,
                this.transform = new n.wx,
                this.alpha = 1,
                this.visible = !0,
                this.renderable = !0,
                this.cullable = !1,
                this.cullArea = null,
                this.parent = null,
                this.worldAlpha = 1,
                this._lastSortedIndex = 0,
                this._zIndex = 0,
                this.filterArea = null,
                this.filters = null,
                this._enabledFilters = null,
                this._bounds = new i,
                this._localBounds = null,
                this._boundsID = 0,
                this._boundsRect = null,
                this._localBoundsRect = null,
                this._mask = null,
                this._maskRefCount = 0,
                this._destroyed = !1,
                this.isSprite = !1,
                this.isMask = !1
            }
            static mixin(t) {
                const e = Object.keys(t);
                for (let r = 0; r < e.length; ++r) {
                    const n = e[r];
                    Object.defineProperty(s.prototype, n, Object.getOwnPropertyDescriptor(t, n))
                }
            }
            get destroyed() {
                return this._destroyed
            }
            _recursivePostUpdateTransform() {
                this.parent ? (this.parent._recursivePostUpdateTransform(),
                this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
            }
            updateTransform() {
                this._boundsID++,
                this.transform.updateTransform(this.parent.transform),
                this.worldAlpha = this.alpha * this.parent.worldAlpha
            }
            getBounds(t, e) {
                return t || (this.parent ? (this._recursivePostUpdateTransform(),
                this.updateTransform()) : (this.parent = this._tempDisplayObjectParent,
                this.updateTransform(),
                this.parent = null)),
                this._bounds.updateID !== this._boundsID && (this.calculateBounds(),
                this._bounds.updateID = this._boundsID),
                e || (this._boundsRect || (this._boundsRect = new n.Ae),
                e = this._boundsRect),
                this._bounds.getRectangle(e)
            }
            getLocalBounds(t) {
                t || (this._localBoundsRect || (this._localBoundsRect = new n.Ae),
                t = this._localBoundsRect),
                this._localBounds || (this._localBounds = new i);
                const e = this.transform
                  , r = this.parent;
                this.parent = null,
                this.transform = this._tempDisplayObjectParent.transform;
                const s = this._bounds
                  , o = this._boundsID;
                this._bounds = this._localBounds;
                const a = this.getBounds(!1, t);
                return this.parent = r,
                this.transform = e,
                this._bounds = s,
                this._bounds.updateID += this._boundsID - o,
                a
            }
            toGlobal(t, e, r=!1) {
                return r || (this._recursivePostUpdateTransform(),
                this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
                this.displayObjectUpdateTransform(),
                this.parent = null)),
                this.worldTransform.apply(t, e)
            }
            toLocal(t, e, r, n) {
                return e && (t = e.toGlobal(t, r, n)),
                n || (this._recursivePostUpdateTransform(),
                this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
                this.displayObjectUpdateTransform(),
                this.parent = null)),
                this.worldTransform.applyInverse(t, r)
            }
            setParent(t) {
                if (!t || !t.addChild)
                    throw new Error("setParent: Argument must be a Container");
                return t.addChild(this),
                t
            }
            removeFromParent() {
                this.parent?.removeChild(this)
            }
            setTransform(t=0, e=0, r=1, n=1, i=0, s=0, o=0, a=0, h=0) {
                return this.position.x = t,
                this.position.y = e,
                this.scale.x = r || 1,
                this.scale.y = n || 1,
                this.rotation = i,
                this.skew.x = s,
                this.skew.y = o,
                this.pivot.x = a,
                this.pivot.y = h,
                this
            }
            destroy(t) {
                this.removeFromParent(),
                this._destroyed = !0,
                this.transform = null,
                this.parent = null,
                this._bounds = null,
                this.mask = null,
                this.cullArea = null,
                this.filters = null,
                this.filterArea = null,
                this.hitArea = null,
                this.eventMode = "auto",
                this.interactiveChildren = !1,
                this.emit("destroyed"),
                this.removeAllListeners()
            }
            get _tempDisplayObjectParent() {
                return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new o),
                this.tempDisplayObjectParent
            }
            enableTempParent() {
                const t = this.parent;
                return this.parent = this._tempDisplayObjectParent,
                t
            }
            disableTempParent(t) {
                this.parent = t
            }
            get x() {
                return this.position.x
            }
            set x(t) {
                this.transform.position.x = t
            }
            get y() {
                return this.position.y
            }
            set y(t) {
                this.transform.position.y = t
            }
            get worldTransform() {
                return this.transform.worldTransform
            }
            get localTransform() {
                return this.transform.localTransform
            }
            get position() {
                return this.transform.position
            }
            set position(t) {
                this.transform.position.copyFrom(t)
            }
            get scale() {
                return this.transform.scale
            }
            set scale(t) {
                this.transform.scale.copyFrom(t)
            }
            get pivot() {
                return this.transform.pivot
            }
            set pivot(t) {
                this.transform.pivot.copyFrom(t)
            }
            get skew() {
                return this.transform.skew
            }
            set skew(t) {
                this.transform.skew.copyFrom(t)
            }
            get rotation() {
                return this.transform.rotation
            }
            set rotation(t) {
                this.transform.rotation = t
            }
            get angle() {
                return this.transform.rotation * n.jl
            }
            set angle(t) {
                this.transform.rotation = t * n.ZX
            }
            get zIndex() {
                return this._zIndex
            }
            set zIndex(t) {
                this._zIndex = t,
                this.parent && (this.parent.sortDirty = !0)
            }
            get worldVisible() {
                let t = this;
                do {
                    if (!t.visible)
                        return !1;
                    t = t.parent
                } while (t);
                return !0
            }
            get mask() {
                return this._mask
            }
            set mask(t) {
                if (this._mask !== t) {
                    if (this._mask) {
                        const t = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                        t && (t._maskRefCount--,
                        0 === t._maskRefCount && (t.renderable = !0,
                        t.isMask = !1))
                    }
                    if (this._mask = t,
                    this._mask) {
                        const t = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                        t && (0 === t._maskRefCount && (t.renderable = !1,
                        t.isMask = !0),
                        t._maskRefCount++)
                    }
                }
            }
        }
        class o extends s {
            constructor() {
                super(...arguments),
                this.sortDirty = null
            }
        }
        s.prototype.displayObjectUpdateTransform = s.prototype.updateTransform;
        const a = new n.y3;
        function h(t, e) {
            return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex
        }
        const l = class extends s {
            constructor() {
                super(),
                this.children = [],
                this.sortableChildren = l.defaultSortableChildren,
                this.sortDirty = !1
            }
            onChildrenChange(t) {}
            addChild(...t) {
                if (t.length > 1)
                    for (let e = 0; e < t.length; e++)
                        this.addChild(t[e]);
                else {
                    const e = t[0];
                    e.parent && e.parent.removeChild(e),
                    e.parent = this,
                    this.sortDirty = !0,
                    e.transform._parentID = -1,
                    this.children.push(e),
                    this._boundsID++,
                    this.onChildrenChange(this.children.length - 1),
                    this.emit("childAdded", e, this, this.children.length - 1),
                    e.emit("added", this)
                }
                return t[0]
            }
            addChildAt(t, e) {
                if (e < 0 || e > this.children.length)
                    throw new Error(`${t}addChildAt: The index ${e} supplied is out of bounds ${this.children.length}`);
                return t.parent && t.parent.removeChild(t),
                t.parent = this,
                this.sortDirty = !0,
                t.transform._parentID = -1,
                this.children.splice(e, 0, t),
                this._boundsID++,
                this.onChildrenChange(e),
                t.emit("added", this),
                this.emit("childAdded", t, this, e),
                t
            }
            swapChildren(t, e) {
                if (t === e)
                    return;
                const r = this.getChildIndex(t)
                  , n = this.getChildIndex(e);
                this.children[r] = e,
                this.children[n] = t,
                this.onChildrenChange(r < n ? r : n)
            }
            getChildIndex(t) {
                const e = this.children.indexOf(t);
                if (-1 === e)
                    throw new Error("The supplied DisplayObject must be a child of the caller");
                return e
            }
            setChildIndex(t, e) {
                if (e < 0 || e >= this.children.length)
                    throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
                const r = this.getChildIndex(t);
                n.P6.removeItems(this.children, r, 1),
                this.children.splice(e, 0, t),
                this.onChildrenChange(e)
            }
            getChildAt(t) {
                if (t < 0 || t >= this.children.length)
                    throw new Error(`getChildAt: Index (${t}) does not exist.`);
                return this.children[t]
            }
            removeChild(...t) {
                if (t.length > 1)
                    for (let e = 0; e < t.length; e++)
                        this.removeChild(t[e]);
                else {
                    const e = t[0]
                      , r = this.children.indexOf(e);
                    if (-1 === r)
                        return null;
                    e.parent = null,
                    e.transform._parentID = -1,
                    n.P6.removeItems(this.children, r, 1),
                    this._boundsID++,
                    this.onChildrenChange(r),
                    e.emit("removed", this),
                    this.emit("childRemoved", e, this, r)
                }
                return t[0]
            }
            removeChildAt(t) {
                const e = this.getChildAt(t);
                return e.parent = null,
                e.transform._parentID = -1,
                n.P6.removeItems(this.children, t, 1),
                this._boundsID++,
                this.onChildrenChange(t),
                e.emit("removed", this),
                this.emit("childRemoved", e, this, t),
                e
            }
            removeChildren(t=0, e=this.children.length) {
                const r = t
                  , n = e - r;
                let i;
                if (n > 0 && n <= e) {
                    i = this.children.splice(r, n);
                    for (let t = 0; t < i.length; ++t)
                        i[t].parent = null,
                        i[t].transform && (i[t].transform._parentID = -1);
                    this._boundsID++,
                    this.onChildrenChange(t);
                    for (let t = 0; t < i.length; ++t)
                        i[t].emit("removed", this),
                        this.emit("childRemoved", i[t], this, t);
                    return i
                }
                if (0 === n && 0 === this.children.length)
                    return [];
                throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
            }
            sortChildren() {
                let t = !1;
                for (let e = 0, r = this.children.length; e < r; ++e) {
                    const r = this.children[e];
                    r._lastSortedIndex = e,
                    t || 0 === r.zIndex || (t = !0)
                }
                t && this.children.length > 1 && this.children.sort(h),
                this.sortDirty = !1
            }
            updateTransform() {
                this.sortableChildren && this.sortDirty && this.sortChildren(),
                this._boundsID++,
                this.transform.updateTransform(this.parent.transform),
                this.worldAlpha = this.alpha * this.parent.worldAlpha;
                for (let t = 0, e = this.children.length; t < e; ++t) {
                    const e = this.children[t];
                    e.visible && e.updateTransform()
                }
            }
            calculateBounds() {
                this._bounds.clear(),
                this._calculateBounds();
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    if (e.visible && e.renderable)
                        if (e.calculateBounds(),
                        e._mask) {
                            const t = e._mask.isMaskData ? e._mask.maskObject : e._mask;
                            t ? (t.calculateBounds(),
                            this._bounds.addBoundsMask(e._bounds, t._bounds)) : this._bounds.addBounds(e._bounds)
                        } else
                            e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds)
                }
                this._bounds.updateID = this._boundsID
            }
            getLocalBounds(t, e=!1) {
                const r = super.getLocalBounds(t);
                if (!e)
                    for (let t = 0, e = this.children.length; t < e; ++t) {
                        const e = this.children[t];
                        e.visible && e.updateTransform()
                    }
                return r
            }
            _calculateBounds() {}
            _renderWithCulling(t) {
                const e = t.renderTexture.sourceFrame;
                if (!(e.width > 0 && e.height > 0))
                    return;
                let r, n;
                this.cullArea ? (r = this.cullArea,
                n = this.worldTransform) : this._render !== l.prototype._render && (r = this.getBounds(!0));
                const i = t.projection.transform;
                if (i && (n ? (n = a.copyFrom(n),
                n.prepend(i)) : n = i),
                r && e.intersects(r, n))
                    this._render(t);
                else if (this.cullArea)
                    return;
                for (let e = 0, r = this.children.length; e < r; ++e) {
                    const r = this.children[e]
                      , n = r.cullable;
                    r.cullable = n || !this.cullArea,
                    r.render(t),
                    r.cullable = n
                }
            }
            render(t) {
                if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
                    if (this._mask || this.filters?.length)
                        this.renderAdvanced(t);
                    else if (this.cullable)
                        this._renderWithCulling(t);
                    else {
                        this._render(t);
                        for (let e = 0, r = this.children.length; e < r; ++e)
                            this.children[e].render(t)
                    }
            }
            renderAdvanced(t) {
                const e = this.filters
                  , r = this._mask;
                if (e) {
                    this._enabledFilters || (this._enabledFilters = []),
                    this._enabledFilters.length = 0;
                    for (let t = 0; t < e.length; t++)
                        e[t].enabled && this._enabledFilters.push(e[t])
                }
                const i = e && this._enabledFilters?.length || r && (!r.isMaskData || r.enabled && (r.autoDetect || r.type !== n.A7.NONE));
                if (i && t.batch.flush(),
                e && this._enabledFilters?.length && t.filter.push(this, this._enabledFilters),
                r && t.mask.push(this, this._mask),
                this.cullable)
                    this._renderWithCulling(t);
                else {
                    this._render(t);
                    for (let e = 0, r = this.children.length; e < r; ++e)
                        this.children[e].render(t)
                }
                i && t.batch.flush(),
                r && t.mask.pop(this),
                e && this._enabledFilters?.length && t.filter.pop()
            }
            _render(t) {}
            destroy(t) {
                super.destroy(),
                this.sortDirty = !1;
                const e = "boolean" == typeof t ? t : t?.children
                  , r = this.removeChildren(0, this.children.length);
                if (e)
                    for (let e = 0; e < r.length; ++e)
                        r[e].destroy(t)
            }
            get width() {
                return this.scale.x * this.getLocalBounds().width
            }
            set width(t) {
                const e = this.getLocalBounds().width;
                this.scale.x = 0 !== e ? t / e : 1,
                this._width = t
            }
            get height() {
                return this.scale.y * this.getLocalBounds().height
            }
            set height(t) {
                const e = this.getLocalBounds().height;
                this.scale.y = 0 !== e ? t / e : 1,
                this._height = t
            }
        }
        ;
        let u = l;
        u.defaultSortableChildren = !1,
        u.prototype.containerUpdateTransform = u.prototype.updateTransform,
        Object.defineProperties(n.Xd, {
            SORTABLE_CHILDREN: {
                get() {
                    return u.defaultSortableChildren
                },
                set(t) {
                    n.P6.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"),
                    u.defaultSortableChildren = t
                }
            }
        })
    },
    92099: function(t, e, r) {
        "use strict";
        r.d(e, {
            U: function() {
                return i
            }
        });
        var n = r(33813);
        class i extends n.wn {
            constructor(t=1) {
                super(n.kP, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", {
                    uAlpha: 1
                }),
                this.alpha = t
            }
            get alpha() {
                return this.uniforms.uAlpha
            }
            set alpha(t) {
                this.uniforms.uAlpha = t
            }
        }
    },
    56844: function(t, e, r) {
        "use strict";
        r.d(e, {
            T: function() {
                return a
            },
            Y: function() {
                return o
            }
        });
        var n = r(33813);
        const i = {
            5: [.153388, .221461, .250301],
            7: [.071303, .131514, .189879, .214607],
            9: [.028532, .067234, .124009, .179044, .20236],
            11: [.0093, .028002, .065984, .121703, .175713, .198596],
            13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
            15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
        }
          , s = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
        class o extends n.wn {
            constructor(t, e=8, r=4, o=n.wn.defaultResolution, a=5) {
                const h = function(t, e) {
                    const r = Math.ceil(t / 2);
                    let n, i = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }", s = "";
                    n = e ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
                    for (let e = 0; e < t; e++) {
                        let t = n.replace("%index%", e.toString());
                        t = t.replace("%sampleIndex%", e - (r - 1) + ".0"),
                        s += t,
                        s += "\n"
                    }
                    return i = i.replace("%blur%", s),
                    i = i.replace("%size%", t.toString()),
                    i
                }(a, t)
                  , l = function(t) {
                    const e = i[t]
                      , r = e.length;
                    let n, o = s, a = "";
                    for (let i = 0; i < t; i++) {
                        let s = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", i.toString());
                        n = i,
                        i >= r && (n = t - i - 1),
                        s = s.replace("%value%", e[n].toString()),
                        a += s,
                        a += "\n"
                    }
                    return o = o.replace("%blur%", a),
                    o = o.replace("%size%", t.toString()),
                    o
                }(a);
                super(h, l),
                this.horizontal = t,
                this.resolution = o,
                this._quality = 0,
                this.quality = r,
                this.blur = e
            }
            apply(t, e, r, i) {
                if (r ? this.horizontal ? this.uniforms.strength = 1 / r.width * (r.width / e.width) : this.uniforms.strength = 1 / r.height * (r.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height),
                this.uniforms.strength *= this.strength,
                this.uniforms.strength /= this.passes,
                1 === this.passes)
                    t.applyFilter(this, e, r, i);
                else {
                    const s = t.getFilterTexture()
                      , o = t.renderer;
                    let a = e
                      , h = s;
                    this.state.blend = !1,
                    t.applyFilter(this, a, h, n.yl.CLEAR);
                    for (let e = 1; e < this.passes - 1; e++) {
                        t.bindAndClear(a, n.yl.BLIT),
                        this.uniforms.uSampler = h;
                        const e = h;
                        h = a,
                        a = e,
                        o.shader.bind(this),
                        o.geometry.draw(5)
                    }
                    this.state.blend = !0,
                    t.applyFilter(this, h, r, i),
                    t.returnFilterTexture(s)
                }
            }
            get blur() {
                return this.strength
            }
            set blur(t) {
                this.padding = 1 + 2 * Math.abs(t),
                this.strength = t
            }
            get quality() {
                return this._quality
            }
            set quality(t) {
                this._quality = t,
                this.passes = t
            }
        }
        class a extends n.wn {
            constructor(t=8, e=4, r=n.wn.defaultResolution, i=5) {
                super(),
                this._repeatEdgePixels = !1,
                this.blurXFilter = new o(!0,t,e,r,i),
                this.blurYFilter = new o(!1,t,e,r,i),
                this.resolution = r,
                this.quality = e,
                this.blur = t,
                this.repeatEdgePixels = !1
            }
            apply(t, e, r, i) {
                const s = Math.abs(this.blurXFilter.strength)
                  , o = Math.abs(this.blurYFilter.strength);
                if (s && o) {
                    const s = t.getFilterTexture();
                    this.blurXFilter.apply(t, e, s, n.yl.CLEAR),
                    this.blurYFilter.apply(t, s, r, i),
                    t.returnFilterTexture(s)
                } else
                    o ? this.blurYFilter.apply(t, e, r, i) : this.blurXFilter.apply(t, e, r, i)
            }
            updatePadding() {
                this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength))
            }
            get blur() {
                return this.blurXFilter.blur
            }
            set blur(t) {
                this.blurXFilter.blur = this.blurYFilter.blur = t,
                this.updatePadding()
            }
            get quality() {
                return this.blurXFilter.quality
            }
            set quality(t) {
                this.blurXFilter.quality = this.blurYFilter.quality = t
            }
            get blurX() {
                return this.blurXFilter.blur
            }
            set blurX(t) {
                this.blurXFilter.blur = t,
                this.updatePadding()
            }
            get blurY() {
                return this.blurYFilter.blur
            }
            set blurY(t) {
                this.blurYFilter.blur = t,
                this.updatePadding()
            }
            get blendMode() {
                return this.blurYFilter.blendMode
            }
            set blendMode(t) {
                this.blurYFilter.blendMode = t
            }
            get repeatEdgePixels() {
                return this._repeatEdgePixels
            }
            set repeatEdgePixels(t) {
                this._repeatEdgePixels = t,
                this.updatePadding()
            }
        }
    },
    96715: function(t, e, r) {
        "use strict";
        r.d(e, {
            ZA: function() {
                return a
            },
            mh: function() {
                return l
            },
            Hf: function() {
                return c
            }
        });
        var n = r(58820);
        function i(t) {
            this._activeParentLayer && this._activeParentLayer !== t._activeLayer || (this.visible ? (this.displayOrder = t.incDisplayOrder(),
            this.worldAlpha <= 0 || !this.renderable || (t._activeLayer = null,
            this.containerRenderWebGL(t),
            t._activeLayer = this._activeParentLayer)) : this.displayOrder = 0)
        }
        var s = r(33813);
        const o = class extends s.P6.EventEmitter {
            constructor(t=0, e=!1) {
                super(),
                this.useRenderTexture = !1,
                this.useDoubleBuffer = !1,
                this.sortPriority = 0,
                this.clearColor = new Float32Array([0, 0, 0, 0]),
                this.canDrawWithoutLayer = !1,
                this.canDrawInParentStage = !0,
                this._activeLayer = null,
                this._activeStage = null,
                this._activeChildren = [],
                this._lastUpdateId = -1,
                this.zIndex = t || 0,
                this.enableSort = !!e,
                "function" == typeof e && this.on("sort", e)
            }
            doSort(t, e) {
                if (this.listeners("sort", !0))
                    for (let t = 0; t < e.length; t++)
                        this.emit("sort", e[t]);
                e.sort(o.compareZIndex)
            }
            static compareZIndex(t, e) {
                return t.zOrder < e.zOrder ? -1 : t.zOrder > e.zOrder ? 1 : t.updateOrder - e.updateOrder
            }
            clear() {
                this._activeLayer = null,
                this._activeStage = null,
                this._activeChildren.length = 0
            }
            _resolveChildDisplayObject(t, e) {
                this.check(t),
                e._activeParentLayer = this._activeLayer,
                this._activeLayer ? this._activeLayer._activeChildren.push(e) : this._activeChildren.push(e)
            }
            _resolveLayer(t, e) {
                this.check(t),
                this._activeLayer && o.conflict(),
                this._activeLayer = e,
                this._activeStage = t
            }
            check(t) {
                if (this._lastUpdateId < o._layerUpdateId)
                    this._lastUpdateId = o._layerUpdateId,
                    this.clear(),
                    this._activeStage = t;
                else if (this.canDrawInParentStage) {
                    let e = this._activeStage;
                    for (; e && e !== t; )
                        e = e._activeParentStage;
                    this._activeStage = e,
                    null === e && this.clear()
                }
            }
            static conflict() {
                o._lastLayerConflict + 5e3 < Date.now() && (o._lastLayerConflict = Date.now(),
                console.log("@pixi/layers found two layers with the same group in one stage - that's not healthy. Please place a breakpoint here and debug it"))
            }
        }
        ;
        let a = o;
        a._layerUpdateId = 0,
        a._lastLayerConflict = 0;
        class h {
            constructor(t) {
                this.layer = t,
                this.renderTexture = null,
                this.doubleBuffer = null,
                this.currentBufferIndex = 0,
                this._tempRenderTarget = null,
                this._tempRenderTargetSource = new s.Ae,
                this._tempRenderTargetDestination = new s.Ae
            }
            init(t) {
                const e = t ? t.screen.width : 100
                  , r = t ? t.screen.height : 100
                  , n = t ? t.resolution : s.Xd.RESOLUTION;
                this.renderTexture = s.TI.create({
                    width: e,
                    height: r,
                    resolution: n
                }),
                this.layer.group.useDoubleBuffer && (this.doubleBuffer = [s.TI.create({
                    width: e,
                    height: r,
                    resolution: n
                }), s.TI.create({
                    width: e,
                    height: r,
                    resolution: n
                })])
            }
            getRenderTexture() {
                return this.renderTexture || this.init(),
                this.renderTexture
            }
            pushTexture(t) {
                const e = t.screen;
                this.renderTexture || this.init(t);
                const r = this.renderTexture
                  , n = this.layer.group
                  , i = this.doubleBuffer;
                if (r.width === e.width && r.height === e.height && r.baseTexture.resolution === t.resolution || (r.baseTexture.resolution = t.resolution,
                r.resize(e.width, e.height),
                i && (i[0].baseTexture.resolution = t.resolution,
                i[0].resize(e.width, e.height),
                i[1].baseTexture.resolution = t.resolution,
                i[1].resize(e.width, e.height))),
                i && (i[0].framebuffer.multisample = r.framebuffer.multisample,
                i[1].framebuffer.multisample = r.framebuffer.multisample),
                this._tempRenderTarget = t.renderTexture.current,
                this._tempRenderTargetSource.copyFrom(t.renderTexture.sourceFrame),
                this._tempRenderTargetDestination.copyFrom(t.renderTexture.destinationFrame),
                t.batch.flush(),
                n.useDoubleBuffer) {
                    let e = i[this.currentBufferIndex];
                    e.baseTexture._glTextures[t.CONTEXT_UID] || (t.renderTexture.bind(e, void 0, void 0),
                    t.texture.bind(e),
                    n.clearColor && t.renderTexture.clear(n.clearColor)),
                    t.texture.unbind(r.baseTexture),
                    r.baseTexture._glTextures = e.baseTexture._glTextures,
                    r.baseTexture.framebuffer = e.baseTexture.framebuffer,
                    e = i[1 - this.currentBufferIndex],
                    t.renderTexture.bind(e, void 0, void 0)
                } else
                    t.renderTexture.bind(r, void 0, void 0);
                n.clearColor && t.renderTexture.clear(n.clearColor);
                const s = t.filter.defaultFilterStack;
                s.length > 1 && (s[s.length - 1].renderTexture = t.renderTexture.current)
            }
            popTexture(t) {
                t.batch.flush(),
                t.framebuffer.blit();
                const e = t.filter.defaultFilterStack;
                e.length > 1 && (e[e.length - 1].renderTexture = this._tempRenderTarget),
                t.renderTexture.bind(this._tempRenderTarget, this._tempRenderTargetSource, this._tempRenderTargetDestination),
                this._tempRenderTarget = null;
                const r = this.renderTexture
                  , n = this.layer.group
                  , i = this.doubleBuffer;
                if (n.useDoubleBuffer) {
                    t.texture.unbind(r.baseTexture),
                    this.currentBufferIndex = 1 - this.currentBufferIndex;
                    const e = i[this.currentBufferIndex];
                    r.baseTexture._glTextures = e.baseTexture._glTextures,
                    r.baseTexture.framebuffer = e.baseTexture.framebuffer
                }
            }
            destroy() {
                this.renderTexture && (this.renderTexture.destroy(),
                this.doubleBuffer && (this.doubleBuffer[0].destroy(!0),
                this.doubleBuffer[1].destroy(!0)))
            }
        }
        class l extends n.W2 {
            constructor(t=null) {
                super(),
                this.isLayer = !0,
                this.group = null,
                this._activeChildren = [],
                this._tempChildren = null,
                this._activeStageParent = null,
                this._sortedChildren = [],
                this._tempLayerParent = null,
                this.insertChildrenBeforeActive = !0,
                this.insertChildrenAfterActive = !0,
                t ? (this.group = t,
                this.zIndex = t.zIndex) : this.group = new a(0,!1),
                this._tempChildren = this.children
            }
            get useRenderTexture() {
                return this.group.useRenderTexture
            }
            set useRenderTexture(t) {
                this.group.useRenderTexture = t
            }
            get useDoubleBuffer() {
                return this.group.useDoubleBuffer
            }
            set useDoubleBuffer(t) {
                this.group.useDoubleBuffer = t
            }
            get clearColor() {
                return this.group.clearColor
            }
            set clearColor(t) {
                this.group.clearColor = t
            }
            get sortPriority() {
                return this.group.sortPriority
            }
            set sortPriority(t) {
                this.group.sortPriority = t
            }
            getRenderTexture() {
                return this.textureCache || (this.textureCache = new h(this)),
                this.textureCache.getRenderTexture()
            }
            doSort() {
                this.group.doSort(this, this._sortedChildren)
            }
            destroy(t) {
                this.textureCache && (this.textureCache.destroy(),
                this.textureCache = null),
                super.destroy(t)
            }
            render(t) {
                this.prerender(t) && (this.group.useRenderTexture && (this.textureCache || (this.textureCache = new h(this)),
                this.textureCache.pushTexture(t)),
                this.containerRenderWebGL(t),
                this.postrender(t),
                this.group.useRenderTexture && this.textureCache.popTexture(t))
            }
            layerRenderCanvas(t) {
                this.prerender(t) && (this.containerRenderCanvas(t),
                this.postrender(t))
            }
            _onBeginLayerSubtreeTraversal(t) {
                const e = this._activeChildren;
                this._activeStageParent = t,
                this.group._resolveLayer(t, this);
                const r = this.group._activeChildren;
                e.length = 0;
                for (let t = 0; t < r.length; t++)
                    r[t]._activeParentLayer = this,
                    e.push(r[t]);
                r.length = 0
            }
            _onEndLayerSubtreeTraversal() {
                const t = this.children
                  , e = this._activeChildren
                  , r = this._sortedChildren;
                for (let t = 0; t < e.length; t++)
                    this.emit("display", e[t]);
                if (r.length = 0,
                this.insertChildrenBeforeActive)
                    for (let e = 0; e < t.length; e++)
                        r.push(t[e]);
                for (let t = 0; t < e.length; t++)
                    r.push(e[t]);
                if (!this.insertChildrenBeforeActive && this.insertChildrenAfterActive)
                    for (let e = 0; e < t.length; e++)
                        r.push(t[e]);
                this.group.enableSort && this.doSort()
            }
            prerender(t) {
                return !(this._activeParentLayer && this._activeParentLayer != t._activeLayer || (this.visible ? (this.displayOrder = t.incDisplayOrder(),
                this.worldAlpha <= 0 || !this.renderable || (this.children !== this._sortedChildren && this._tempChildren !== this.children && (this._tempChildren = this.children),
                this._boundsID++,
                this.children = this._sortedChildren,
                this._tempLayerParent = t._activeLayer,
                t._activeLayer = this,
                0)) : (this.displayOrder = 0,
                1)))
            }
            postrender(t) {
                this.children = this._tempChildren,
                t._activeLayer = this._tempLayerParent,
                this._tempLayerParent = null
            }
        }
        l.prototype.renderCanvas = l.prototype.layerRenderCanvas;
        const u = class extends l {
            constructor() {
                super(...arguments),
                this.isStage = !0,
                this._tempGroups = [],
                this._activeLayers = [],
                this._activeParentStage = null
            }
            clear() {
                this._activeLayers.length = 0,
                this._tempGroups.length = 0
            }
            destroy(t) {
                this.clear(),
                super.destroy(t)
            }
            updateStage() {
                this._activeParentStage = null,
                a._layerUpdateId++,
                this._updateStageInner()
            }
            updateAsChildStage(t) {
                this._activeParentStage = t,
                u._updateOrderCounter = 0,
                this._updateStageInner()
            }
            _updateStageInner() {
                this.clear(),
                this._addRecursive(this);
                const t = this._activeLayers;
                for (let e = 0; e < t.length; e++) {
                    const r = t[e];
                    if (r.group.sortPriority) {
                        r._onEndLayerSubtreeTraversal();
                        const t = r._sortedChildren;
                        for (let e = 0; e < t.length; e++)
                            this._addRecursiveChildren(t[e])
                    }
                }
                for (let e = 0; e < t.length; e++) {
                    const r = t[e];
                    r.group.sortPriority || r._onEndLayerSubtreeTraversal()
                }
            }
            _addRecursive(t) {
                if (!t.visible)
                    return;
                if (t.isLayer) {
                    const e = t;
                    this._activeLayers.push(e),
                    e._onBeginLayerSubtreeTraversal(this)
                }
                if (t !== this && t.isStage)
                    return void t.updateAsChildStage(this);
                t._activeParentLayer = null;
                let e = t.parentGroup;
                e && e._resolveChildDisplayObject(this, t);
                const r = t.parentLayer;
                if (r && (e = r.group,
                e._resolveChildDisplayObject(this, t)),
                t.updateOrder = ++u._updateOrderCounter,
                t.alpha <= 0 || !t.renderable || !t.layerableChildren || e && e.sortPriority)
                    return;
                const n = t.children;
                if (n && n.length)
                    for (let t = 0; t < n.length; t++)
                        this._addRecursive(n[t])
            }
            _addRecursiveChildren(t) {
                if (t.alpha <= 0 || !t.renderable || !t.layerableChildren)
                    return;
                const e = t.children;
                if (e && e.length)
                    for (let t = 0; t < e.length; t++)
                        this._addRecursive(e[t])
            }
        }
        ;
        let c = u;
        c._updateOrderCounter = 0,
        function() {
            if (void 0 !== n.s$.prototype.displayOrder)
                return;
            Object.assign(n.s$.prototype, {
                parentLayer: null,
                _activeParentLayer: null,
                parentGroup: null,
                zOrder: 0,
                zIndex: 0,
                updateOrder: 0,
                displayOrder: 0,
                layerableChildren: !0,
                isLayer: !1
            });
            const t = n.W2.prototype;
            t.containerRenderWebGL = t.render,
            t.render = i
        }(),
        function(t) {
            const e = t.prototype;
            var r;
            e._oldRender || (Object.assign(e, {
                _lastDisplayOrder: 0,
                _activeLayer: null,
                incDisplayOrder() {
                    return ++this._lastDisplayOrder
                },
                _oldRender: s.Th.prototype.render
            }),
            e._oldRender = e.render,
            e.render = (r = e.render,
            function(t, e, n, i, s) {
                e && (e.renderTexture || e.baseTexture) || (this._lastDisplayOrder = 0),
                this._activeLayer = null,
                t.isStage && t.updateStage(),
                r.call(this, t, e, n, i, s)
            }
            ))
        }(s.Th)
    },
    98544: function(t, e, r) {
        "use strict";
        r.d(e, {
            Ag: function() {
                return P
            },
            rt: function() {
                return X
            }
        });
        var n = r(33813);
        class i extends n.wn {
            constructor(t=4, e=3, r=!1) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", r ? "\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n" : "\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}"),
                this._kernels = [],
                this._blur = 4,
                this._quality = 3,
                this.uniforms.uOffset = new Float32Array(2),
                this._pixelSize = new n.E9,
                this.pixelSize = 1,
                this._clamp = r,
                Array.isArray(t) ? this.kernels = t : (this._blur = t,
                this.quality = e)
            }
            apply(t, e, r, n) {
                const i = this._pixelSize.x / e._frame.width
                  , s = this._pixelSize.y / e._frame.height;
                let o;
                if (1 === this._quality || 0 === this._blur)
                    o = this._kernels[0] + .5,
                    this.uniforms.uOffset[0] = o * i,
                    this.uniforms.uOffset[1] = o * s,
                    t.applyFilter(this, e, r, n);
                else {
                    const a = t.getFilterTexture();
                    let h, l = e, u = a;
                    const c = this._quality - 1;
                    for (let e = 0; e < c; e++)
                        o = this._kernels[e] + .5,
                        this.uniforms.uOffset[0] = o * i,
                        this.uniforms.uOffset[1] = o * s,
                        t.applyFilter(this, l, u, 1),
                        h = l,
                        l = u,
                        u = h;
                    o = this._kernels[c] + .5,
                    this.uniforms.uOffset[0] = o * i,
                    this.uniforms.uOffset[1] = o * s,
                    t.applyFilter(this, l, r, n),
                    t.returnFilterTexture(a)
                }
            }
            _updatePadding() {
                this.padding = Math.ceil(this._kernels.reduce(( (t, e) => t + e + .5), 0))
            }
            _generateKernels() {
                const t = this._blur
                  , e = this._quality
                  , r = [t];
                if (t > 0) {
                    let n = t;
                    const i = t / e;
                    for (let t = 1; t < e; t++)
                        n -= i,
                        r.push(n)
                }
                this._kernels = r,
                this._updatePadding()
            }
            get kernels() {
                return this._kernels
            }
            set kernels(t) {
                Array.isArray(t) && t.length > 0 ? (this._kernels = t,
                this._quality = t.length,
                this._blur = Math.max(...t)) : (this._kernels = [0],
                this._quality = 1)
            }
            get clamp() {
                return this._clamp
            }
            set pixelSize(t) {
                "number" == typeof t ? (this._pixelSize.x = t,
                this._pixelSize.y = t) : Array.isArray(t) ? (this._pixelSize.x = t[0],
                this._pixelSize.y = t[1]) : t instanceof n.E9 ? (this._pixelSize.x = t.x,
                this._pixelSize.y = t.y) : (this._pixelSize.x = 1,
                this._pixelSize.y = 1)
            }
            get pixelSize() {
                return this._pixelSize
            }
            get quality() {
                return this._quality
            }
            set quality(t) {
                this._quality = Math.max(1, Math.round(t)),
                this._generateKernels()
            }
            get blur() {
                return this._blur
            }
            set blur(t) {
                this._blur = t,
                this._generateKernels()
            }
        }
        var s = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
        class o extends n.wn {
            constructor(t=.5) {
                super(s, "\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n"),
                this.threshold = t
            }
            get threshold() {
                return this.uniforms.threshold
            }
            set threshold(t) {
                this.uniforms.threshold = t
            }
        }
        const a = class extends n.wn {
            constructor(t) {
                super(s, "uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n"),
                this.bloomScale = 1,
                this.brightness = 1,
                this._resolution = n.Xd.FILTER_RESOLUTION,
                "number" == typeof t && (t = {
                    threshold: t
                });
                const e = Object.assign(a.defaults, t);
                this.bloomScale = e.bloomScale,
                this.brightness = e.brightness;
                const {kernels: r, blur: h, quality: l, pixelSize: u, resolution: c} = e;
                this._extractFilter = new o(e.threshold),
                this._extractFilter.resolution = c,
                this._blurFilter = r ? new i(r) : new i(h,l),
                this.pixelSize = u,
                this.resolution = c
            }
            apply(t, e, r, n, i) {
                const s = t.getFilterTexture();
                this._extractFilter.apply(t, e, s, 1, i);
                const o = t.getFilterTexture();
                this._blurFilter.apply(t, s, o, 1),
                this.uniforms.bloomScale = this.bloomScale,
                this.uniforms.brightness = this.brightness,
                this.uniforms.bloomTexture = o,
                t.applyFilter(this, e, r, n),
                t.returnFilterTexture(o),
                t.returnFilterTexture(s)
            }
            get resolution() {
                return this._resolution
            }
            set resolution(t) {
                this._resolution = t,
                this._extractFilter && (this._extractFilter.resolution = t),
                this._blurFilter && (this._blurFilter.resolution = t)
            }
            get threshold() {
                return this._extractFilter.threshold
            }
            set threshold(t) {
                this._extractFilter.threshold = t
            }
            get kernels() {
                return this._blurFilter.kernels
            }
            set kernels(t) {
                this._blurFilter.kernels = t
            }
            get blur() {
                return this._blurFilter.blur
            }
            set blur(t) {
                this._blurFilter.blur = t
            }
            get quality() {
                return this._blurFilter.quality
            }
            set quality(t) {
                this._blurFilter.quality = t
            }
            get pixelSize() {
                return this._blurFilter.pixelSize
            }
            set pixelSize(t) {
                this._blurFilter.pixelSize = t
            }
        }
        ;
        a.defaults = {
            threshold: .5,
            bloomScale: 1,
            brightness: 1,
            kernels: null,
            blur: 8,
            quality: 4,
            pixelSize: 1,
            resolution: n.Xd.FILTER_RESOLUTION
        },
        r(92099),
        r(56844);
        const h = class extends n.wn {
            constructor(t) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n"),
                this.uniforms.dimensions = new Float32Array(2),
                Object.assign(this, h.defaults, t)
            }
            apply(t, e, r, n) {
                const {width: i, height: s} = e.filterFrame;
                this.uniforms.dimensions[0] = i,
                this.uniforms.dimensions[1] = s,
                t.applyFilter(this, e, r, n)
            }
            get radius() {
                return this.uniforms.radius
            }
            set radius(t) {
                this.uniforms.radius = t
            }
            get strength() {
                return this.uniforms.strength
            }
            set strength(t) {
                this.uniforms.strength = t
            }
            get center() {
                return this.uniforms.center
            }
            set center(t) {
                this.uniforms.center = t
            }
        }
        ;
        var l, u;
        h.defaults = {
            center: [.5, .5],
            radius: 100,
            strength: 1
        },
        (l = l || {}).stringify = (u = {
            "visit_linear-gradient": function(t) {
                return u.visit_gradient(t)
            },
            "visit_repeating-linear-gradient": function(t) {
                return u.visit_gradient(t)
            },
            "visit_radial-gradient": function(t) {
                return u.visit_gradient(t)
            },
            "visit_repeating-radial-gradient": function(t) {
                return u.visit_gradient(t)
            },
            visit_gradient: function(t) {
                var e = u.visit(t.orientation);
                return e && (e += ", "),
                t.type + "(" + e + u.visit(t.colorStops) + ")"
            },
            visit_shape: function(t) {
                var e = t.value
                  , r = u.visit(t.at)
                  , n = u.visit(t.style);
                return n && (e += " " + n),
                r && (e += " at " + r),
                e
            },
            "visit_default-radial": function(t) {
                var e = ""
                  , r = u.visit(t.at);
                return r && (e += r),
                e
            },
            "visit_extent-keyword": function(t) {
                var e = t.value
                  , r = u.visit(t.at);
                return r && (e += " at " + r),
                e
            },
            "visit_position-keyword": function(t) {
                return t.value
            },
            visit_position: function(t) {
                return u.visit(t.value.x) + " " + u.visit(t.value.y)
            },
            "visit_%": function(t) {
                return t.value + "%"
            },
            visit_em: function(t) {
                return t.value + "em"
            },
            visit_px: function(t) {
                return t.value + "px"
            },
            visit_literal: function(t) {
                return u.visit_color(t.value, t)
            },
            visit_hex: function(t) {
                return u.visit_color("#" + t.value, t)
            },
            visit_rgb: function(t) {
                return u.visit_color("rgb(" + t.value.join(", ") + ")", t)
            },
            visit_rgba: function(t) {
                return u.visit_color("rgba(" + t.value.join(", ") + ")", t)
            },
            visit_color: function(t, e) {
                var r = t
                  , n = u.visit(e.length);
                return n && (r += " " + n),
                r
            },
            visit_angular: function(t) {
                return t.value + "deg"
            },
            visit_directional: function(t) {
                return "to " + t.value
            },
            visit_array: function(t) {
                var e = ""
                  , r = t.length;
                return t.forEach((function(t, n) {
                    e += u.visit(t),
                    n < r - 1 && (e += ", ")
                }
                )),
                e
            },
            visit: function(t) {
                if (!t)
                    return "";
                if (t instanceof Array)
                    return u.visit_array(t, "");
                if (t.type) {
                    var e = u["visit_" + t.type];
                    if (e)
                        return e(t);
                    throw Error("Missing visitor visit_" + t.type)
                }
                throw Error("Invalid node.")
            }
        },
        function(t) {
            return u.visit(t)
        }
        ),
        (l = l || {}).parse = function() {
            var t = {
                linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
                repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
                radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
                repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
                sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
                extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
                positionKeywords: /^(left|center|right|top|bottom)/i,
                pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
                percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
                emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
                angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
                startCall: /^\(/,
                endCall: /^\)/,
                comma: /^,/,
                hexColor: /^\#([0-9a-fA-F]+)/,
                literalColor: /^([a-zA-Z]+)/,
                rgbColor: /^rgb/i,
                rgbaColor: /^rgba/i,
                number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
            }
              , e = "";
            function r(t) {
                var r = new Error(e + ": " + t);
                throw r.source = e,
                r
            }
            function n() {
                return i("linear-gradient", t.linearGradient, o) || i("repeating-linear-gradient", t.repeatingLinearGradient, o) || i("radial-gradient", t.radialGradient, a) || i("repeating-radial-gradient", t.repeatingRadialGradient, a)
            }
            function i(e, n, i) {
                return s(n, (function(n) {
                    var s = i();
                    return s && (y(t.comma) || r("Missing comma before color stops")),
                    {
                        type: e,
                        orientation: s,
                        colorStops: d(f)
                    }
                }
                ))
            }
            function s(e, n) {
                var i = y(e);
                if (i) {
                    y(t.startCall) || r("Missing (");
                    var s = n(i);
                    return y(t.endCall) || r("Missing )"),
                    s
                }
            }
            function o() {
                return v("directional", t.sideOrCorner, 1) || v("angular", t.angleValue, 1)
            }
            function a() {
                var r, n, i = h();
                return i && ((r = []).push(i),
                n = e,
                y(t.comma) && ((i = h()) ? r.push(i) : e = n)),
                r
            }
            function h() {
                var t = function() {
                    var t = v("shape", /^(circle)/i, 0);
                    return t && (t.style = g() || l()),
                    t
                }() || function() {
                    var t = v("shape", /^(ellipse)/i, 0);
                    return t && (t.style = m() || l()),
                    t
                }();
                if (t)
                    t.at = u();
                else {
                    var e = l();
                    if (e) {
                        t = e;
                        var r = u();
                        r && (t.at = r)
                    } else {
                        var n = c();
                        n && (t = {
                            type: "default-radial",
                            at: n
                        })
                    }
                }
                return t
            }
            function l() {
                return v("extent-keyword", t.extentKeywords, 1)
            }
            function u() {
                if (v("position", /^at/, 0)) {
                    var t = c();
                    return t || r("Missing positioning value"),
                    t
                }
            }
            function c() {
                var t = {
                    x: m(),
                    y: m()
                };
                if (t.x || t.y)
                    return {
                        type: "position",
                        value: t
                    }
            }
            function d(e) {
                var n = e()
                  , i = [];
                if (n)
                    for (i.push(n); y(t.comma); )
                        (n = e()) ? i.push(n) : r("One extra comma");
                return i
            }
            function f() {
                var e = v("hex", t.hexColor, 1) || s(t.rgbaColor, (function() {
                    return {
                        type: "rgba",
                        value: d(p)
                    }
                }
                )) || s(t.rgbColor, (function() {
                    return {
                        type: "rgb",
                        value: d(p)
                    }
                }
                )) || v("literal", t.literalColor, 0);
                return e || r("Expected color definition"),
                e.length = m(),
                e
            }
            function p() {
                return y(t.number)[1]
            }
            function m() {
                return v("%", t.percentageValue, 1) || v("position-keyword", t.positionKeywords, 1) || g()
            }
            function g() {
                return v("px", t.pixelValue, 1) || v("em", t.emValue, 1)
            }
            function v(t, e, r) {
                var n = y(e);
                if (n)
                    return {
                        type: t,
                        value: n[r]
                    }
            }
            function y(t) {
                var r, n;
                return (n = /^[\n\r\t\s]+/.exec(e)) && _(n[0].length),
                (r = t.exec(e)) && _(r[0].length),
                r
            }
            function _(t) {
                e = e.substr(t)
            }
            return function(t) {
                return e = t.toString(),
                function() {
                    var t = d(n);
                    return e.length > 0 && r("Invalid input not EOF"),
                    t
                }()
            }
        }();
        var c = l.parse;
        l.stringify;
        var d = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
        }
          , f = {
            red: 0,
            orange: 60,
            yellow: 120,
            green: 180,
            blue: 240,
            purple: 300
        }
          , p = {
            name: "rgb",
            min: [0, 0, 0],
            max: [255, 255, 255],
            channel: ["red", "green", "blue"],
            alias: ["RGB"]
        }
          , m = {
            name: "hsl",
            min: [0, 0, 0],
            max: [360, 100, 100],
            channel: ["hue", "saturation", "lightness"],
            alias: ["HSL"],
            rgb: function(t) {
                var e, r, n, i, s, o = t[0] / 360, a = t[1] / 100, h = t[2] / 100;
                if (0 === a)
                    return [s = 255 * h, s, s];
                e = 2 * h - (r = h < .5 ? h * (1 + a) : h + a - h * a),
                i = [0, 0, 0];
                for (var l = 0; l < 3; l++)
                    (n = o + 1 / 3 * -(l - 1)) < 0 ? n++ : n > 1 && n--,
                    s = 6 * n < 1 ? e + 6 * (r - e) * n : 2 * n < 1 ? r : 3 * n < 2 ? e + (r - e) * (2 / 3 - n) * 6 : e,
                    i[l] = 255 * s;
                return i
            }
        };
        function g(t) {
            switch (typeof t) {
            case "string":
                return function(t) {
                    const e = function(t) {
                        Array.isArray(t) && t.raw && (t = String.raw(...arguments));
                        var e, r = function(t) {
                            var e, r, n = [], i = 1;
                            if ("string" == typeof t)
                                if (d[t])
                                    n = d[t].slice(),
                                    r = "rgb";
                                else if ("transparent" === t)
                                    i = 0,
                                    r = "rgb",
                                    n = [0, 0, 0];
                                else if (/^#[A-Fa-f0-9]+$/.test(t)) {
                                    var s = t.slice(1);
                                    i = 1,
                                    (h = s.length) <= 4 ? (n = [parseInt(s[0] + s[0], 16), parseInt(s[1] + s[1], 16), parseInt(s[2] + s[2], 16)],
                                    4 === h && (i = parseInt(s[3] + s[3], 16) / 255)) : (n = [parseInt(s[0] + s[1], 16), parseInt(s[2] + s[3], 16), parseInt(s[4] + s[5], 16)],
                                    8 === h && (i = parseInt(s[6] + s[7], 16) / 255)),
                                    n[0] || (n[0] = 0),
                                    n[1] || (n[1] = 0),
                                    n[2] || (n[2] = 0),
                                    r = "rgb"
                                } else if (e = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(t)) {
                                    var o = e[1]
                                      , a = "rgb" === o;
                                    r = s = o.replace(/a$/, "");
                                    var h = "cmyk" === s ? 4 : "gray" === s ? 1 : 3;
                                    n = e[2].trim().split(/\s*[,\/]\s*|\s+/).map((function(t, e) {
                                        if (/%$/.test(t))
                                            return e === h ? parseFloat(t) / 100 : "rgb" === s ? 255 * parseFloat(t) / 100 : parseFloat(t);
                                        if ("h" === s[e]) {
                                            if (/deg$/.test(t))
                                                return parseFloat(t);
                                            if (void 0 !== f[t])
                                                return f[t]
                                        }
                                        return parseFloat(t)
                                    }
                                    )),
                                    o === s && n.push(1),
                                    i = a || void 0 === n[h] ? 1 : n[h],
                                    n = n.slice(0, h)
                                } else
                                    t.length > 10 && /[0-9](?:\s|\/)/.test(t) && (n = t.match(/([0-9]+)/g).map((function(t) {
                                        return parseFloat(t)
                                    }
                                    )),
                                    r = t.match(/([a-z])/gi).join("").toLowerCase());
                            else
                                isNaN(t) ? Array.isArray(t) || t.length ? (n = [t[0], t[1], t[2]],
                                r = "rgb",
                                i = 4 === t.length ? t[3] : 1) : t instanceof Object && (null != t.r || null != t.red || null != t.R ? (r = "rgb",
                                n = [t.r || t.red || t.R || 0, t.g || t.green || t.G || 0, t.b || t.blue || t.B || 0]) : (r = "hsl",
                                n = [t.h || t.hue || t.H || 0, t.s || t.saturation || t.S || 0, t.l || t.lightness || t.L || t.b || t.brightness]),
                                i = t.a || t.alpha || t.opacity || 1,
                                null != t.opacity && (i /= 100)) : (r = "rgb",
                                n = [t >>> 16, (65280 & t) >>> 8, 255 & t]);
                            return {
                                space: r,
                                values: n,
                                alpha: i
                            }
                        }(t);
                        if (!r.space)
                            return [];
                        const n = "h" === r.space[0] ? m.min : p.min
                          , i = "h" === r.space[0] ? m.max : p.max;
                        return (e = Array(3))[0] = Math.min(Math.max(r.values[0], n[0]), i[0]),
                        e[1] = Math.min(Math.max(r.values[1], n[1]), i[1]),
                        e[2] = Math.min(Math.max(r.values[2], n[2]), i[2]),
                        "h" === r.space[0] && (e = m.rgb(e)),
                        e.push(Math.min(Math.max(r.alpha, 0), 1)),
                        e
                    }(t);
                    if (!e)
                        throw new Error(`Unable to parse color "${t}" as RGBA.`);
                    return [e[0] / 255, e[1] / 255, e[2] / 255, e[3]]
                }(t);
            case "number":
                return n.P6.hex2rgb(t);
            default:
                return t
            }
        }
        function v(t) {
            return g(function(t) {
                switch (t.type) {
                case "hex":
                    return `#${t.value}`;
                case "literal":
                    return t.value;
                default:
                    return `${t.type}(${t.value.join(",")})`
                }
            }(t))
        }
        function y(t) {
            return t.toString().length > 6 ? parseFloat(t.toString().substring(0, 6)) : t
        }
        p.hsl = function(t) {
            var e, r, n = t[0] / 255, i = t[1] / 255, s = t[2] / 255, o = Math.min(n, i, s), a = Math.max(n, i, s), h = a - o;
            return a === o ? e = 0 : n === a ? e = (i - s) / h : i === a ? e = 2 + (s - n) / h : s === a && (e = 4 + (n - i) / h),
            (e = Math.min(60 * e, 360)) < 0 && (e += 360),
            r = (o + a) / 2,
            [e, 100 * (a === o ? 0 : r <= .5 ? h / (a + o) : h / (2 - a - o)), 100 * r]
        }
        ;
        var _ = Object.defineProperty
          , x = Object.defineProperties
          , b = Object.getOwnPropertyDescriptors
          , E = Object.getOwnPropertySymbols
          , T = Object.prototype.hasOwnProperty
          , w = Object.prototype.propertyIsEnumerable
          , S = (t, e, r) => e in t ? _(t, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : t[e] = r
          , A = (t, e) => {
            for (var r in e || (e = {}))
                T.call(e, r) && S(t, r, e[r]);
            if (E)
                for (var r of E(e))
                    w.call(e, r) && S(t, r, e[r]);
            return t
        }
        ;
        const C = class extends n.wn {
            constructor(t) {
                t && "css"in t && (t = ( (t, e) => x(t, b(e)))(A({}, function(t) {
                    const e = c(function(t) {
                        let e = t.replace(/\s{2,}/gu, " ");
                        return e = e.replace(/;/g, ""),
                        e = e.replace(/ ,/g, ","),
                        e = e.replace(/\( /g, "("),
                        e = e.replace(/ \)/g, ")"),
                        e.trim()
                    }(t));
                    if (0 === e.length)
                        throw new Error("Invalid CSS gradient.");
                    if (1 !== e.length)
                        throw new Error("Unsupported CSS gradient (multiple gradients is not supported).");
                    const r = e[0]
                      , n = function(t) {
                        const e = {
                            "linear-gradient": 0,
                            "radial-gradient": 1
                        };
                        if (!(t in e))
                            throw new Error(`Unsupported gradient type "${t}"`);
                        return e[t]
                    }(r.type)
                      , i = function(t) {
                        const e = function(t) {
                            const e = [];
                            for (let r = 0; r < t.length; r++) {
                                const n = t[r];
                                let i = -1;
                                "literal" === n.type && n.length && "type"in n.length && "%" === n.length.type && "value"in n.length && (i = parseFloat(n.length.value) / 100),
                                e.push(i)
                            }
                            const r = t => {
                                for (let r = t; r < e.length; r++)
                                    if (-1 !== e[r])
                                        return {
                                            indexDelta: r - t,
                                            offset: e[r]
                                        };
                                return {
                                    indexDelta: e.length - 1 - t,
                                    offset: 1
                                }
                            }
                            ;
                            let n = 0;
                            for (let t = 0; t < e.length; t++) {
                                const i = e[t];
                                if (-1 !== i)
                                    n = i;
                                else if (0 === t)
                                    e[t] = 0;
                                else if (t + 1 === e.length)
                                    e[t] = 1;
                                else {
                                    const i = r(t)
                                      , s = (i.offset - n) / (1 + i.indexDelta);
                                    for (let r = 0; r <= i.indexDelta; r++)
                                        e[t + r] = n + (r + 1) * s;
                                    t += i.indexDelta,
                                    n = e[t]
                                }
                            }
                            return e.map(y)
                        }(t)
                          , r = [];
                        for (let n = 0; n < t.length; n++) {
                            const i = v(t[n]);
                            r.push({
                                offset: e[n],
                                color: i.slice(0, 3),
                                alpha: i[3]
                            })
                        }
                        return r
                    }(r.colorStops)
                      , s = function(t) {
                        if (void 0 === t)
                            return 0;
                        if ("type"in t && "value"in t)
                            switch (t.type) {
                            case "angular":
                                return parseFloat(t.value);
                            case "directional":
                                return function(t) {
                                    const e = {
                                        left: 270,
                                        top: 0,
                                        bottom: 180,
                                        right: 90,
                                        "left top": 315,
                                        "top left": 315,
                                        "left bottom": 225,
                                        "bottom left": 225,
                                        "right top": 45,
                                        "top right": 45,
                                        "right bottom": 135,
                                        "bottom right": 135
                                    };
                                    if (!(t in e))
                                        throw new Error(`Unsupported directional value "${t}"`);
                                    return e[t]
                                }(t.value)
                            }
                        return 0
                    }(r.orientation);
                    return {
                        type: n,
                        stops: i,
                        angle: s
                    }
                }(t.css || "")), {
                    alpha: t.alpha,
                    maxColors: t.maxColors
                }));
                const e = A(A({}, C.defaults), t);
                if (!e.stops || e.stops.length < 2)
                    throw new Error("ColorGradientFilter requires at least 2 color stops.");
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vFilterCoord = vTextureCoord * inputSize.xy / outputFrame.zw;\n}\n", "const float PI = 3.1415926538;\nconst float PI_2 = PI*2.;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\nuniform sampler2D uSampler;\n\nconst int TYPE_LINEAR = 0;\nconst int TYPE_RADIAL = 1;\nconst int TYPE_CONIC = 2;\nconst int MAX_STOPS = 32;\n\nuniform int uNumStops;\nuniform float uAlphas[3*MAX_STOPS];\nuniform vec3 uColors[MAX_STOPS];\nuniform float uOffsets[MAX_STOPS];\nuniform int uType;\nuniform float uAngle;\nuniform float uAlpha;\nuniform int uMaxColors;\n\nstruct ColorStop {\n    float offset;\n    vec3 color;\n    float alpha;\n};\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n    sin(angle), cos(angle));\n}\n\nfloat projectLinearPosition(vec2 pos, float angle){\n    vec2 center = vec2(0.5);\n    vec2 result = pos - center;\n    result = rotate2d(angle) * result;\n    result = result + center;\n    return clamp(result.x, 0., 1.);\n}\n\nfloat projectRadialPosition(vec2 pos) {\n    float r = distance(vFilterCoord, vec2(0.5));\n    return clamp(2.*r, 0., 1.);\n}\n\nfloat projectAnglePosition(vec2 pos, float angle) {\n    vec2 center = pos - vec2(0.5);\n    float polarAngle=atan(-center.y, center.x);\n    return mod(polarAngle + angle, PI_2) / PI_2;\n}\n\nfloat projectPosition(vec2 pos, int type, float angle) {\n    if (type == TYPE_LINEAR) {\n        return projectLinearPosition(pos, angle);\n    } else if (type == TYPE_RADIAL) {\n        return projectRadialPosition(pos);\n    } else if (type == TYPE_CONIC) {\n        return projectAnglePosition(pos, angle);\n    }\n\n    return pos.y;\n}\n\nvoid main(void) {\n    // current/original color\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n\n    // skip calculations if gradient alpha is 0\n    if (0.0 == uAlpha) {\n        gl_FragColor = currentColor;\n        return;\n    }\n\n    // project position\n    float y = projectPosition(vFilterCoord, uType, radians(uAngle));\n\n    // check gradient bounds\n    float offsetMin = uOffsets[0];\n    float offsetMax = 0.0;\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (i == uNumStops-1){ // last index\n            offsetMax = uOffsets[i];\n        }\n    }\n\n    if (y  < offsetMin || y > offsetMax) {\n        gl_FragColor = currentColor;\n        return;\n    }\n\n    // limit colors\n    if (uMaxColors > 0) {\n        float stepSize = 1./float(uMaxColors);\n        float stepNumber = float(floor(y/stepSize));\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\n    }\n\n    // find color stops\n    ColorStop from;\n    ColorStop to;\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (y >= uOffsets[i]) {\n            from = ColorStop(uOffsets[i], uColors[i], uAlphas[i]);\n            to = ColorStop(uOffsets[i+1], uColors[i+1], uAlphas[i+1]);\n        }\n\n        if (i == uNumStops-1){ // last index\n            break;\n        }\n    }\n\n    // mix colors from stops\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\n\n    float segmentHeight = to.offset - from.offset;\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\n\n    float gradientAlpha = uAlpha * currentColor.a;\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n    // mix resulting color with current color\n    gl_FragColor = gradientColor + currentColor*(1.-gradientColor.a);\n}\n"),
                this._stops = [],
                this.autoFit = !1,
                Object.assign(this, e)
            }
            get stops() {
                return this._stops
            }
            set stops(t) {
                const e = function(t) {
                    return [...t].sort(( (t, e) => t.offset - e.offset))
                }(t)
                  , r = new Float32Array(3 * e.length);
                for (let t = 0; t < e.length; t++) {
                    const n = g(e[t].color)
                      , i = 3 * t;
                    r[i + 0] = n[0],
                    r[i + 1] = n[1],
                    r[i + 2] = n[2]
                }
                this.uniforms.uColors = r,
                this.uniforms.uOffsets = e.map((t => t.offset)),
                this.uniforms.uAlphas = e.map((t => t.alpha)),
                this.uniforms.uNumStops = e.length,
                this._stops = e
            }
            set type(t) {
                this.uniforms.uType = t
            }
            get type() {
                return this.uniforms.uType
            }
            set angle(t) {
                this.uniforms.uAngle = t - 90
            }
            get angle() {
                return this.uniforms.uAngle + 90
            }
            set alpha(t) {
                this.uniforms.uAlpha = t
            }
            get alpha() {
                return this.uniforms.uAlpha
            }
            set maxColors(t) {
                this.uniforms.uMaxColors = t
            }
            get maxColors() {
                return this.uniforms.uMaxColors
            }
        }
        ;
        let R = C;
        R.LINEAR = 0,
        R.RADIAL = 1,
        R.CONIC = 2,
        R.defaults = {
            type: C.LINEAR,
            stops: [{
                offset: 0,
                color: 16711680,
                alpha: 1
            }, {
                offset: 1,
                color: 255,
                alpha: 1
            }],
            alpha: 1,
            angle: 90,
            maxColors: 0
        };
        class P extends n.wn {
            constructor(t=0, e=1) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 color;\nuniform float alpha;\n\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(mix(currentColor.rgb, color.rgb, currentColor.a * alpha), currentColor.a);\n}\n"),
                this._color = 0,
                this._alpha = 1,
                this.uniforms.color = new Float32Array(3),
                this.color = t,
                this.alpha = e
            }
            set color(t) {
                const e = this.uniforms.color;
                "number" == typeof t ? (n.P6.hex2rgb(t, e),
                this._color = t) : (e[0] = t[0],
                e[1] = t[1],
                e[2] = t[2],
                this._color = n.P6.rgb2hex(e))
            }
            get color() {
                return this._color
            }
            set alpha(t) {
                this.uniforms.alpha = t,
                this._alpha = t
            }
            get alpha() {
                return this._alpha
            }
        }
        const I = class extends n.wn {
            constructor(t) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 dir = vec2(vTextureCoord.xy * filterArea.xy / dimensions - vec2(0.5, 0.5));\n    \n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0)\n    {\n        float _c = curvature > 0. ? curvature : 1.;\n        float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n        vec2 uv = dir * k;\n\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n"),
                this.time = 0,
                this.seed = 0,
                this.uniforms.dimensions = new Float32Array(2),
                Object.assign(this, I.defaults, t)
            }
            apply(t, e, r, n) {
                const {width: i, height: s} = e.filterFrame;
                this.uniforms.dimensions[0] = i,
                this.uniforms.dimensions[1] = s,
                this.uniforms.seed = this.seed,
                this.uniforms.time = this.time,
                t.applyFilter(this, e, r, n)
            }
            set curvature(t) {
                this.uniforms.curvature = t
            }
            get curvature() {
                return this.uniforms.curvature
            }
            set lineWidth(t) {
                this.uniforms.lineWidth = t
            }
            get lineWidth() {
                return this.uniforms.lineWidth
            }
            set lineContrast(t) {
                this.uniforms.lineContrast = t
            }
            get lineContrast() {
                return this.uniforms.lineContrast
            }
            set verticalLine(t) {
                this.uniforms.verticalLine = t
            }
            get verticalLine() {
                return this.uniforms.verticalLine
            }
            set noise(t) {
                this.uniforms.noise = t
            }
            get noise() {
                return this.uniforms.noise
            }
            set noiseSize(t) {
                this.uniforms.noiseSize = t
            }
            get noiseSize() {
                return this.uniforms.noiseSize
            }
            set vignetting(t) {
                this.uniforms.vignetting = t
            }
            get vignetting() {
                return this.uniforms.vignetting
            }
            set vignettingAlpha(t) {
                this.uniforms.vignettingAlpha = t
            }
            get vignettingAlpha() {
                return this.uniforms.vignettingAlpha
            }
            set vignettingBlur(t) {
                this.uniforms.vignettingBlur = t
            }
            get vignettingBlur() {
                return this.uniforms.vignettingBlur
            }
        }
        ;
        I.defaults = {
            curvature: 1,
            lineWidth: 1,
            lineContrast: .25,
            verticalLine: !1,
            noise: 0,
            noiseSize: 1,
            seed: 0,
            vignetting: .3,
            vignettingAlpha: 1,
            vignettingBlur: .3,
            time: 0
        };
        var M = Object.defineProperty
          , D = Object.getOwnPropertySymbols
          , O = Object.prototype.hasOwnProperty
          , B = Object.prototype.propertyIsEnumerable
          , k = (t, e, r) => e in t ? M(t, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : t[e] = r
          , L = (t, e) => {
            for (var r in e || (e = {}))
                O.call(e, r) && k(t, r, e[r]);
            if (D)
                for (var r of D(e))
                    B.call(e, r) && k(t, r, e[r]);
            return t
        }
        ;
        const N = class extends n.wn {
            constructor(t) {
                super(),
                this.angle = 45,
                this._distance = 5,
                this._resolution = n.Xd.FILTER_RESOLUTION;
                const e = t ? L(L({}, N.defaults), t) : N.defaults
                  , {kernels: r, blur: s, quality: o, pixelSize: a, resolution: h} = e;
                this._offset = new n.AB(this._updatePadding,this),
                this._tintFilter = new n.wn("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\n\nuniform vec2 shift;\nuniform vec4 inputSize;\n\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}"),
                this._tintFilter.uniforms.color = new Float32Array(4),
                this._tintFilter.uniforms.shift = this._offset,
                this._tintFilter.resolution = h,
                this._blurFilter = r ? new i(r) : new i(s,o),
                this.pixelSize = a,
                this.resolution = h;
                const {shadowOnly: l, rotation: u, distance: c, offset: d, alpha: f, color: p} = e;
                this.shadowOnly = l,
                void 0 !== u && void 0 !== c ? (this.rotation = u,
                this.distance = c) : this.offset = d,
                this.alpha = f,
                this.color = p
            }
            apply(t, e, r, n) {
                const i = t.getFilterTexture();
                this._tintFilter.apply(t, e, i, 1),
                this._blurFilter.apply(t, i, r, n),
                !0 !== this.shadowOnly && t.applyFilter(this, e, r, 0),
                t.returnFilterTexture(i)
            }
            _updatePadding() {
                const t = Math.max(Math.abs(this._offset.x), Math.abs(this._offset.y));
                this.padding = t + 2 * this.blur
            }
            _updateShift() {
                this._tintFilter.uniforms.shift.set(this.distance * Math.cos(this.angle), this.distance * Math.sin(this.angle))
            }
            set offset(t) {
                this._offset.copyFrom(t),
                this._updatePadding()
            }
            get offset() {
                return this._offset
            }
            get resolution() {
                return this._resolution
            }
            set resolution(t) {
                this._resolution = t,
                this._tintFilter && (this._tintFilter.resolution = t),
                this._blurFilter && (this._blurFilter.resolution = t)
            }
            get distance() {
                return this._distance
            }
            set distance(t) {
                n.P6.deprecation("5.3.0", "DropShadowFilter distance is deprecated, use offset"),
                this._distance = t,
                this._updatePadding(),
                this._updateShift()
            }
            get rotation() {
                return this.angle / n.ZX
            }
            set rotation(t) {
                n.P6.deprecation("5.3.0", "DropShadowFilter rotation is deprecated, use offset"),
                this.angle = t * n.ZX,
                this._updateShift()
            }
            get alpha() {
                return this._tintFilter.uniforms.alpha
            }
            set alpha(t) {
                this._tintFilter.uniforms.alpha = t
            }
            get color() {
                return n.P6.rgb2hex(this._tintFilter.uniforms.color)
            }
            set color(t) {
                n.P6.hex2rgb(t, this._tintFilter.uniforms.color)
            }
            get kernels() {
                return this._blurFilter.kernels
            }
            set kernels(t) {
                this._blurFilter.kernels = t
            }
            get blur() {
                return this._blurFilter.blur
            }
            set blur(t) {
                this._blurFilter.blur = t,
                this._updatePadding()
            }
            get quality() {
                return this._blurFilter.quality
            }
            set quality(t) {
                this._blurFilter.quality = t
            }
            get pixelSize() {
                return this._blurFilter.pixelSize
            }
            set pixelSize(t) {
                this._blurFilter.pixelSize = t
            }
        }
        ;
        N.defaults = {
            offset: {
                x: 4,
                y: 4
            },
            color: 0,
            alpha: .5,
            shadowOnly: !1,
            kernels: null,
            blur: 2,
            quality: 3,
            pixelSize: 1,
            resolution: n.Xd.FILTER_RESOLUTION
        };
        const F = class extends n.wn {
            constructor(t) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n"),
                this.offset = 100,
                this.fillMode = F.TRANSPARENT,
                this.average = !1,
                this.seed = 0,
                this.minSize = 8,
                this.sampleSize = 512,
                this._slices = 0,
                this._offsets = new Float32Array(1),
                this._sizes = new Float32Array(1),
                this._direction = -1,
                this.uniforms.dimensions = new Float32Array(2),
                this._canvas = document.createElement("canvas"),
                this._canvas.width = 4,
                this._canvas.height = this.sampleSize,
                this.texture = n.xE.from(this._canvas, {
                    scaleMode: n.aH.NEAREST
                }),
                Object.assign(this, F.defaults, t)
            }
            apply(t, e, r, n) {
                const {width: i, height: s} = e.filterFrame;
                this.uniforms.dimensions[0] = i,
                this.uniforms.dimensions[1] = s,
                this.uniforms.aspect = s / i,
                this.uniforms.seed = this.seed,
                this.uniforms.offset = this.offset,
                this.uniforms.fillMode = this.fillMode,
                t.applyFilter(this, e, r, n)
            }
            _randomizeSizes() {
                const t = this._sizes
                  , e = this._slices - 1
                  , r = this.sampleSize
                  , n = Math.min(this.minSize / r, .9 / this._slices);
                if (this.average) {
                    const r = this._slices;
                    let i = 1;
                    for (let s = 0; s < e; s++) {
                        const e = i / (r - s)
                          , o = Math.max(e * (1 - .6 * Math.random()), n);
                        t[s] = o,
                        i -= o
                    }
                    t[e] = i
                } else {
                    let r = 1;
                    const i = Math.sqrt(1 / this._slices);
                    for (let s = 0; s < e; s++) {
                        const e = Math.max(i * r * Math.random(), n);
                        t[s] = e,
                        r -= e
                    }
                    t[e] = r
                }
                this.shuffle()
            }
            shuffle() {
                const t = this._sizes;
                for (let e = this._slices - 1; e > 0; e--) {
                    const r = Math.random() * e >> 0
                      , n = t[e];
                    t[e] = t[r],
                    t[r] = n
                }
            }
            _randomizeOffsets() {
                for (let t = 0; t < this._slices; t++)
                    this._offsets[t] = Math.random() * (Math.random() < .5 ? -1 : 1)
            }
            refresh() {
                this._randomizeSizes(),
                this._randomizeOffsets(),
                this.redraw()
            }
            redraw() {
                const t = this.sampleSize
                  , e = this.texture
                  , r = this._canvas.getContext("2d");
                r.clearRect(0, 0, 8, t);
                let n, i = 0;
                for (let e = 0; e < this._slices; e++) {
                    n = Math.floor(256 * this._offsets[e]);
                    const s = this._sizes[e] * t
                      , o = n > 0 ? n : 0
                      , a = n < 0 ? -n : 0;
                    r.fillStyle = `rgba(${o}, ${a}, 0, 1)`,
                    r.fillRect(0, i >> 0, t, s + 1 >> 0),
                    i += s
                }
                e.baseTexture.update(),
                this.uniforms.displacementMap = e
            }
            set sizes(t) {
                const e = Math.min(this._slices, t.length);
                for (let r = 0; r < e; r++)
                    this._sizes[r] = t[r]
            }
            get sizes() {
                return this._sizes
            }
            set offsets(t) {
                const e = Math.min(this._slices, t.length);
                for (let r = 0; r < e; r++)
                    this._offsets[r] = t[r]
            }
            get offsets() {
                return this._offsets
            }
            get slices() {
                return this._slices
            }
            set slices(t) {
                this._slices !== t && (this._slices = t,
                this.uniforms.slices = t,
                this._sizes = this.uniforms.slicesWidth = new Float32Array(t),
                this._offsets = this.uniforms.slicesOffset = new Float32Array(t),
                this.refresh())
            }
            get direction() {
                return this._direction
            }
            set direction(t) {
                if (this._direction === t)
                    return;
                this._direction = t;
                const e = t * n.ZX;
                this.uniforms.sinDir = Math.sin(e),
                this.uniforms.cosDir = Math.cos(e)
            }
            get red() {
                return this.uniforms.red
            }
            set red(t) {
                this.uniforms.red = t
            }
            get green() {
                return this.uniforms.green
            }
            set green(t) {
                this.uniforms.green = t
            }
            get blue() {
                return this.uniforms.blue
            }
            set blue(t) {
                this.uniforms.blue = t
            }
            destroy() {
                var t;
                null == (t = this.texture) || t.destroy(!0),
                this.texture = this._canvas = this.red = this.green = this.blue = this._sizes = this._offsets = null
            }
        }
        ;
        let U = F;
        U.defaults = {
            slices: 5,
            offset: 100,
            direction: 0,
            fillMode: 0,
            average: !1,
            seed: 0,
            red: [0, 0],
            green: [0, 0],
            blue: [0, 0],
            minSize: 8,
            sampleSize: 512
        },
        U.TRANSPARENT = 0,
        U.ORIGINAL = 1,
        U.LOOP = 2,
        U.CLAMP = 3,
        U.MIRROR = 4;
        const G = class extends n.wn {
            constructor(t) {
                const e = Object.assign({}, G.defaults, t)
                  , {outerStrength: r, innerStrength: n, color: i, knockout: s, quality: o, alpha: a} = e
                  , h = Math.round(e.distance);
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\n\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\nuniform float alpha;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (DIST - curDistance) * curColor.a;\n       }\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    if (knockout) {\n      float resultAlpha = (outerGlowAlpha + innerGlowAlpha) * alpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      vec4 outerGlowColor = outerGlowStrength * glowColor.rgba * alpha;\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n".replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / o / h).toFixed(7)}`).replace(/__DIST__/gi, `${h.toFixed(0)}.0`)),
                this.uniforms.glowColor = new Float32Array([0, 0, 0, 1]),
                this.uniforms.alpha = 1,
                Object.assign(this, {
                    color: i,
                    outerStrength: r,
                    innerStrength: n,
                    padding: h,
                    knockout: s,
                    alpha: a
                })
            }
            get color() {
                return n.P6.rgb2hex(this.uniforms.glowColor)
            }
            set color(t) {
                n.P6.hex2rgb(t, this.uniforms.glowColor)
            }
            get outerStrength() {
                return this.uniforms.outerStrength
            }
            set outerStrength(t) {
                this.uniforms.outerStrength = t
            }
            get innerStrength() {
                return this.uniforms.innerStrength
            }
            set innerStrength(t) {
                this.uniforms.innerStrength = t
            }
            get knockout() {
                return this.uniforms.knockout
            }
            set knockout(t) {
                this.uniforms.knockout = t
            }
            get alpha() {
                return this.uniforms.alpha
            }
            set alpha(t) {
                this.uniforms.alpha = t
            }
        }
        ;
        G.defaults = {
            distance: 10,
            outerStrength: 4,
            innerStrength: 0,
            color: 16777215,
            quality: .1,
            knockout: !1,
            alpha: 1
        };
        const j = class extends n.wn {
            constructor(t) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\nuniform float alpha;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n\n}\n".replace("${perlin}", "vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n")),
                this.parallel = !0,
                this.time = 0,
                this._angle = 0,
                this.uniforms.dimensions = new Float32Array(2);
                const e = Object.assign(j.defaults, t);
                this._angleLight = new n.E9,
                this.angle = e.angle,
                this.gain = e.gain,
                this.lacunarity = e.lacunarity,
                this.alpha = e.alpha,
                this.parallel = e.parallel,
                this.center = e.center,
                this.time = e.time
            }
            apply(t, e, r, n) {
                const {width: i, height: s} = e.filterFrame;
                this.uniforms.light = this.parallel ? this._angleLight : this.center,
                this.uniforms.parallel = this.parallel,
                this.uniforms.dimensions[0] = i,
                this.uniforms.dimensions[1] = s,
                this.uniforms.aspect = s / i,
                this.uniforms.time = this.time,
                this.uniforms.alpha = this.alpha,
                t.applyFilter(this, e, r, n)
            }
            get angle() {
                return this._angle
            }
            set angle(t) {
                this._angle = t;
                const e = t * n.ZX;
                this._angleLight.x = Math.cos(e),
                this._angleLight.y = Math.sin(e)
            }
            get gain() {
                return this.uniforms.gain
            }
            set gain(t) {
                this.uniforms.gain = t
            }
            get lacunarity() {
                return this.uniforms.lacunarity
            }
            set lacunarity(t) {
                this.uniforms.lacunarity = t
            }
            get alpha() {
                return this.uniforms.alpha
            }
            set alpha(t) {
                this.uniforms.alpha = t
            }
        }
        ;
        j.defaults = {
            angle: 30,
            gain: .5,
            lacunarity: 2.5,
            time: 0,
            parallel: !0,
            center: [0, 0],
            alpha: 1
        };
        const z = class extends n.wn {
            constructor(t) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float uHue;\nuniform float uAlpha;\nuniform bool uColorize;\nuniform float uSaturation;\nuniform float uLightness;\n\n// https://en.wikipedia.org/wiki/Luma_(video)\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\n\nfloat getWeightedAverage(vec3 rgb) {\n    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;\n}\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\nconst vec3 k = vec3(0.57735, 0.57735, 0.57735);\n\nvec3 hueShift(vec3 color, float angle) {\n    float cosAngle = cos(angle);\n    return vec3(\n    color * cosAngle +\n    cross(k, color) * sin(angle) +\n    k * dot(k, color) * (1.0 - cosAngle)\n    );\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    vec4 result = color;\n\n    // colorize\n    if (uColorize) {\n        result.rgb = vec3(getWeightedAverage(result.rgb), 0., 0.);\n    }\n\n    // hue\n    result.rgb = hueShift(result.rgb, uHue);\n\n    // saturation\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\n    float average = (result.r + result.g + result.b) / 3.0;\n\n    if (uSaturation > 0.) {\n        result.rgb += (average - result.rgb) * (1. - 1. / (1.001 - uSaturation));\n    } else {\n        result.rgb -= (average - result.rgb) * uSaturation;\n    }\n\n    // lightness\n    result.rgb = mix(result.rgb, vec3(ceil(uLightness)) * color.a, abs(uLightness));\n\n    // alpha\n    gl_FragColor = mix(color, result, uAlpha);\n}\n"),
                this._hue = 0;
                const e = Object.assign({}, z.defaults, t);
                Object.assign(this, e)
            }
            get hue() {
                return this._hue
            }
            set hue(t) {
                this._hue = t,
                this.uniforms.uHue = this._hue * (Math.PI / 180)
            }
            get alpha() {
                return this.uniforms.uAlpha
            }
            set alpha(t) {
                this.uniforms.uAlpha = t
            }
            get colorize() {
                return this.uniforms.uColorize
            }
            set colorize(t) {
                this.uniforms.uColorize = t
            }
            get lightness() {
                return this.uniforms.uLightness
            }
            set lightness(t) {
                this.uniforms.uLightness = t
            }
            get saturation() {
                return this.uniforms.uSaturation
            }
            set saturation(t) {
                this.uniforms.uSaturation = t
            }
        }
        ;
        z.defaults = {
            hue: 0,
            saturation: 0,
            lightness: 0,
            colorize: !1,
            alpha: 1
        };
        const H = class extends n.wn {
            constructor(t, e=0) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n"),
                this.seed = 0,
                this.uniforms.dimensions = new Float32Array(2),
                "number" == typeof t ? (this.seed = t,
                t = void 0) : this.seed = e,
                Object.assign(this, H.defaults, t)
            }
            apply(t, e, r, n) {
                var i, s;
                this.uniforms.dimensions[0] = null == (i = e.filterFrame) ? void 0 : i.width,
                this.uniforms.dimensions[1] = null == (s = e.filterFrame) ? void 0 : s.height,
                this.uniforms.seed = this.seed,
                t.applyFilter(this, e, r, n)
            }
            set sepia(t) {
                this.uniforms.sepia = t
            }
            get sepia() {
                return this.uniforms.sepia
            }
            set noise(t) {
                this.uniforms.noise = t
            }
            get noise() {
                return this.uniforms.noise
            }
            set noiseSize(t) {
                this.uniforms.noiseSize = t
            }
            get noiseSize() {
                return this.uniforms.noiseSize
            }
            set scratch(t) {
                this.uniforms.scratch = t
            }
            get scratch() {
                return this.uniforms.scratch
            }
            set scratchDensity(t) {
                this.uniforms.scratchDensity = t
            }
            get scratchDensity() {
                return this.uniforms.scratchDensity
            }
            set scratchWidth(t) {
                this.uniforms.scratchWidth = t
            }
            get scratchWidth() {
                return this.uniforms.scratchWidth
            }
            set vignetting(t) {
                this.uniforms.vignetting = t
            }
            get vignetting() {
                return this.uniforms.vignetting
            }
            set vignettingAlpha(t) {
                this.uniforms.vignettingAlpha = t
            }
            get vignettingAlpha() {
                return this.uniforms.vignettingAlpha
            }
            set vignettingBlur(t) {
                this.uniforms.vignettingBlur = t
            }
            get vignettingBlur() {
                return this.uniforms.vignettingBlur
            }
        }
        ;
        H.defaults = {
            sepia: .3,
            noise: .3,
            noiseSize: 1,
            scratch: .5,
            scratchDensity: .3,
            scratchWidth: 1,
            vignetting: .3,
            vignettingAlpha: 1,
            vignettingBlur: .3
        };
        const $ = class extends n.wn {
            constructor(t=1, e=0, r=.1, n=1, i=!1) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterClamp;\n\nuniform float uAlpha;\nuniform vec2 uThickness;\nuniform vec4 uColor;\nuniform bool uKnockout;\n\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\nconst float ANGLE_STEP = ${angleStep};\n\nfloat outlineMaxAlphaAtPos(vec2 pos) {\n    if (uThickness.x == 0. || uThickness.y == 0.) {\n        return 0.;\n    }\n\n    vec4 displacedColor;\n    vec2 displacedPos;\n    float maxAlpha = 0.;\n\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\n        displacedColor = texture2D(uSampler, clamp(displacedPos, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, displacedColor.a);\n    }\n\n    return maxAlpha;\n}\n\nvoid main(void) {\n    vec4 sourceColor = texture2D(uSampler, vTextureCoord);\n    vec4 contentColor = sourceColor * float(!uKnockout);\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\n    gl_FragColor = contentColor + outlineColor;\n}\n".replace(/\$\{angleStep\}/, $.getAngleStep(r))),
                this._thickness = 1,
                this._alpha = 1,
                this._knockout = !1,
                this.uniforms.uThickness = new Float32Array([0, 0]),
                this.uniforms.uColor = new Float32Array([0, 0, 0, 1]),
                this.uniforms.uAlpha = n,
                this.uniforms.uKnockout = i,
                Object.assign(this, {
                    thickness: t,
                    color: e,
                    quality: r,
                    alpha: n,
                    knockout: i
                })
            }
            static getAngleStep(t) {
                const e = Math.max(t * $.MAX_SAMPLES, $.MIN_SAMPLES);
                return (2 * Math.PI / e).toFixed(7)
            }
            apply(t, e, r, n) {
                this.uniforms.uThickness[0] = this._thickness / e._frame.width,
                this.uniforms.uThickness[1] = this._thickness / e._frame.height,
                this.uniforms.uAlpha = this._alpha,
                this.uniforms.uKnockout = this._knockout,
                t.applyFilter(this, e, r, n)
            }
            get alpha() {
                return this._alpha
            }
            set alpha(t) {
                this._alpha = t
            }
            get color() {
                return n.P6.rgb2hex(this.uniforms.uColor)
            }
            set color(t) {
                n.P6.hex2rgb(t, this.uniforms.uColor)
            }
            get knockout() {
                return this._knockout
            }
            set knockout(t) {
                this._knockout = t
            }
            get thickness() {
                return this._thickness
            }
            set thickness(t) {
                this._thickness = t,
                this.padding = t
            }
        }
        ;
        let X = $;
        X.MIN_SAMPLES = 1,
        X.MAX_SAMPLES = 100;
        const V = class extends n.wn {
            constructor(t) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n"),
                this.time = 0,
                this.uniforms.amplitude = new Float32Array(2),
                this.uniforms.waveLength = new Float32Array(2),
                this.uniforms.alpha = new Float32Array(2),
                this.uniforms.dimensions = new Float32Array(2),
                Object.assign(this, V.defaults, t)
            }
            apply(t, e, r, n) {
                var i, s;
                this.uniforms.dimensions[0] = null == (i = e.filterFrame) ? void 0 : i.width,
                this.uniforms.dimensions[1] = null == (s = e.filterFrame) ? void 0 : s.height,
                this.uniforms.time = this.time,
                t.applyFilter(this, e, r, n)
            }
            set mirror(t) {
                this.uniforms.mirror = t
            }
            get mirror() {
                return this.uniforms.mirror
            }
            set boundary(t) {
                this.uniforms.boundary = t
            }
            get boundary() {
                return this.uniforms.boundary
            }
            set amplitude(t) {
                this.uniforms.amplitude[0] = t[0],
                this.uniforms.amplitude[1] = t[1]
            }
            get amplitude() {
                return this.uniforms.amplitude
            }
            set waveLength(t) {
                this.uniforms.waveLength[0] = t[0],
                this.uniforms.waveLength[1] = t[1]
            }
            get waveLength() {
                return this.uniforms.waveLength
            }
            set alpha(t) {
                this.uniforms.alpha[0] = t[0],
                this.uniforms.alpha[1] = t[1]
            }
            get alpha() {
                return this.uniforms.alpha
            }
        }
        ;
        V.defaults = {
            mirror: !0,
            boundary: .5,
            amplitude: [0, 20],
            waveLength: [30, 100],
            alpha: [1, 1],
            time: 0
        };
        const W = class extends n.wn {
            constructor(t=[0, 0], e, r=0) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n"),
                this.center = t,
                Object.assign(this, W.defaults, e),
                this.time = r
            }
            apply(t, e, r, n) {
                this.uniforms.time = this.time,
                t.applyFilter(this, e, r, n)
            }
            get center() {
                return this.uniforms.center
            }
            set center(t) {
                this.uniforms.center = t
            }
            get amplitude() {
                return this.uniforms.amplitude
            }
            set amplitude(t) {
                this.uniforms.amplitude = t
            }
            get wavelength() {
                return this.uniforms.wavelength
            }
            set wavelength(t) {
                this.uniforms.wavelength = t
            }
            get brightness() {
                return this.uniforms.brightness
            }
            set brightness(t) {
                this.uniforms.brightness = t
            }
            get speed() {
                return this.uniforms.speed
            }
            set speed(t) {
                this.uniforms.speed = t
            }
            get radius() {
                return this.uniforms.radius
            }
            set radius(t) {
                this.uniforms.radius = t
            }
        }
        ;
        W.defaults = {
            amplitude: 30,
            wavelength: 160,
            brightness: 1,
            speed: 500,
            radius: -1
        };
        class Y extends n.wn {
            constructor(t) {
                var e, r;
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n"),
                this.uniforms.blur = t.blur,
                this.uniforms.gradientBlur = t.gradientBlur,
                this.uniforms.start = null != (e = t.start) ? e : new n.E9(0,window.innerHeight / 2),
                this.uniforms.end = null != (r = t.end) ? r : new n.E9(600,window.innerHeight / 2),
                this.uniforms.delta = new n.E9(30,30),
                this.uniforms.texSize = new n.E9(window.innerWidth,window.innerHeight),
                this.updateDelta()
            }
            updateDelta() {
                this.uniforms.delta.x = 0,
                this.uniforms.delta.y = 0
            }
            get blur() {
                return this.uniforms.blur
            }
            set blur(t) {
                this.uniforms.blur = t
            }
            get gradientBlur() {
                return this.uniforms.gradientBlur
            }
            set gradientBlur(t) {
                this.uniforms.gradientBlur = t
            }
            get start() {
                return this.uniforms.start
            }
            set start(t) {
                this.uniforms.start = t,
                this.updateDelta()
            }
            get end() {
                return this.uniforms.end
            }
            set end(t) {
                this.uniforms.end = t,
                this.updateDelta()
            }
        }
        class q extends Y {
            updateDelta() {
                const t = this.uniforms.end.x - this.uniforms.start.x
                  , e = this.uniforms.end.y - this.uniforms.start.y
                  , r = Math.sqrt(t * t + e * e);
                this.uniforms.delta.x = t / r,
                this.uniforms.delta.y = e / r
            }
        }
        class K extends Y {
            updateDelta() {
                const t = this.uniforms.end.x - this.uniforms.start.x
                  , e = this.uniforms.end.y - this.uniforms.start.y
                  , r = Math.sqrt(t * t + e * e);
                this.uniforms.delta.x = -e / r,
                this.uniforms.delta.y = t / r
            }
        }
        const Z = class extends n.wn {
            constructor(t, e, r, i) {
                super(),
                "number" == typeof t && (n.P6.deprecation("5.3.0", "TiltShiftFilter constructor arguments is deprecated, use options."),
                t = {
                    blur: t,
                    gradientBlur: e,
                    start: r,
                    end: i
                }),
                t = Object.assign({}, Z.defaults, t),
                this.tiltShiftXFilter = new q(t),
                this.tiltShiftYFilter = new K(t)
            }
            apply(t, e, r, n) {
                const i = t.getFilterTexture();
                this.tiltShiftXFilter.apply(t, e, i, 1),
                this.tiltShiftYFilter.apply(t, i, r, n),
                t.returnFilterTexture(i)
            }
            get blur() {
                return this.tiltShiftXFilter.blur
            }
            set blur(t) {
                this.tiltShiftXFilter.blur = this.tiltShiftYFilter.blur = t
            }
            get gradientBlur() {
                return this.tiltShiftXFilter.gradientBlur
            }
            set gradientBlur(t) {
                this.tiltShiftXFilter.gradientBlur = this.tiltShiftYFilter.gradientBlur = t
            }
            get start() {
                return this.tiltShiftXFilter.start
            }
            set start(t) {
                this.tiltShiftXFilter.start = this.tiltShiftYFilter.start = t
            }
            get end() {
                return this.tiltShiftXFilter.end
            }
            set end(t) {
                this.tiltShiftXFilter.end = this.tiltShiftYFilter.end = t
            }
        }
        ;
        Z.defaults = {
            blur: 100,
            gradientBlur: 600,
            start: void 0,
            end: void 0
        };
        const J = class extends n.wn {
            constructor(t) {
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n"),
                Object.assign(this, J.defaults, t)
            }
            get offset() {
                return this.uniforms.offset
            }
            set offset(t) {
                this.uniforms.offset = t
            }
            get radius() {
                return this.uniforms.radius
            }
            set radius(t) {
                this.uniforms.radius = t
            }
            get angle() {
                return this.uniforms.angle
            }
            set angle(t) {
                this.uniforms.angle = t
            }
        }
        ;
        J.defaults = {
            radius: 200,
            angle: 4,
            padding: 20,
            offset: new n.E9
        };
        var Q = Object.getOwnPropertySymbols
          , tt = Object.prototype.hasOwnProperty
          , et = Object.prototype.propertyIsEnumerable;
        const rt = class extends n.wn {
            constructor(t) {
                const e = Object.assign(rt.defaults, t)
                  , {maxKernelSize: r} = e
                  , n = ( (t, e) => {
                    var r = {};
                    for (var n in t)
                        tt.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
                    if (null != t && Q)
                        for (var n of Q(t))
                            e.indexOf(n) < 0 && et.call(t, n) && (r[n] = t[n]);
                    return r
                }
                )(e, ["maxKernelSize"]);
                super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = ${maxKernelSize};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n".replace("${maxKernelSize}", r.toFixed(1))),
                Object.assign(this, n)
            }
            get center() {
                return this.uniforms.uCenter
            }
            set center(t) {
                this.uniforms.uCenter = t
            }
            get strength() {
                return this.uniforms.uStrength
            }
            set strength(t) {
                this.uniforms.uStrength = t
            }
            get innerRadius() {
                return this.uniforms.uInnerRadius
            }
            set innerRadius(t) {
                this.uniforms.uInnerRadius = t
            }
            get radius() {
                return this.uniforms.uRadius
            }
            set radius(t) {
                (t < 0 || t === 1 / 0) && (t = -1),
                this.uniforms.uRadius = t
            }
        }
        ;
        rt.defaults = {
            strength: .1,
            center: [0, 0],
            innerRadius: 0,
            radius: -1,
            maxKernelSize: 32
        }
    },
    55760: function(t, e, r) {
        "use strict";
        r.d(e, {
            MxU: function() {
                return D
            },
            deM: function() {
                return ut
            },
            T01: function() {
                return c.T
            },
            Ilk: function() {
                return n.Il
            },
            mJh: function() {
                return d
            },
            W20: function() {
                return i.W2
            },
            wn$: function() {
                return n.wn
            },
            TCu: function() {
                return ce
            },
            E9j: function() {
                return n.E9
            },
            AeJ: function() {
                return n.Ae
            },
            TIb: function() {
                return n.TI
            },
            jyi: function() {
                return a
            },
            xvT: function() {
                return De
            },
            pn8: function() {
                return Ce
            },
            tqC: function() {
                return n.tq
            }
        });
        var n = r(33813)
          , i = r(58820);
        const s = new n.E9
          , o = new Uint16Array([0, 1, 2, 0, 2, 3]);
        class a extends i.W2 {
            constructor(t) {
                super(),
                this._anchor = new n.AB(this._onAnchorUpdate,this,t ? t.defaultAnchor.x : 0,t ? t.defaultAnchor.y : 0),
                this._texture = null,
                this._width = 0,
                this._height = 0,
                this._tintColor = new n.Il(16777215),
                this._tintRGB = null,
                this.tint = 16777215,
                this.blendMode = n.T$.NORMAL,
                this._cachedTint = 16777215,
                this.uvs = null,
                this.texture = t || n.xE.EMPTY,
                this.vertexData = new Float32Array(8),
                this.vertexTrimmedData = null,
                this._transformID = -1,
                this._textureID = -1,
                this._transformTrimmedID = -1,
                this._textureTrimmedID = -1,
                this.indices = o,
                this.pluginName = "batch",
                this.isSprite = !0,
                this._roundPixels = n.Xd.ROUND_PIXELS
            }
            _onTextureUpdate() {
                this._textureID = -1,
                this._textureTrimmedID = -1,
                this._cachedTint = 16777215,
                this._width && (this.scale.x = n.P6.sign(this.scale.x) * this._width / this._texture.orig.width),
                this._height && (this.scale.y = n.P6.sign(this.scale.y) * this._height / this._texture.orig.height)
            }
            _onAnchorUpdate() {
                this._transformID = -1,
                this._transformTrimmedID = -1
            }
            calculateVertices() {
                const t = this._texture;
                if (this._transformID === this.transform._worldID && this._textureID === t._updateID)
                    return;
                this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32),
                this._transformID = this.transform._worldID,
                this._textureID = t._updateID;
                const e = this.transform.worldTransform
                  , r = e.a
                  , i = e.b
                  , s = e.c
                  , o = e.d
                  , a = e.tx
                  , h = e.ty
                  , l = this.vertexData
                  , u = t.trim
                  , c = t.orig
                  , d = this._anchor;
                let f = 0
                  , p = 0
                  , m = 0
                  , g = 0;
                if (u ? (p = u.x - d._x * c.width,
                f = p + u.width,
                g = u.y - d._y * c.height,
                m = g + u.height) : (p = -d._x * c.width,
                f = p + c.width,
                g = -d._y * c.height,
                m = g + c.height),
                l[0] = r * p + s * g + a,
                l[1] = o * g + i * p + h,
                l[2] = r * f + s * g + a,
                l[3] = o * g + i * f + h,
                l[4] = r * f + s * m + a,
                l[5] = o * m + i * f + h,
                l[6] = r * p + s * m + a,
                l[7] = o * m + i * p + h,
                this._roundPixels) {
                    const t = n.Xd.RESOLUTION;
                    for (let e = 0; e < l.length; ++e)
                        l[e] = Math.round(l[e] * t) / t
                }
            }
            calculateTrimmedVertices() {
                if (this.vertexTrimmedData) {
                    if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
                        return
                } else
                    this.vertexTrimmedData = new Float32Array(8);
                this._transformTrimmedID = this.transform._worldID,
                this._textureTrimmedID = this._texture._updateID;
                const t = this._texture
                  , e = this.vertexTrimmedData
                  , r = t.orig
                  , n = this._anchor
                  , i = this.transform.worldTransform
                  , s = i.a
                  , o = i.b
                  , a = i.c
                  , h = i.d
                  , l = i.tx
                  , u = i.ty
                  , c = -n._x * r.width
                  , d = c + r.width
                  , f = -n._y * r.height
                  , p = f + r.height;
                e[0] = s * c + a * f + l,
                e[1] = h * f + o * c + u,
                e[2] = s * d + a * f + l,
                e[3] = h * f + o * d + u,
                e[4] = s * d + a * p + l,
                e[5] = h * p + o * d + u,
                e[6] = s * c + a * p + l,
                e[7] = h * p + o * c + u
            }
            _render(t) {
                this.calculateVertices(),
                t.batch.setObjectRenderer(t.plugins[this.pluginName]),
                t.plugins[this.pluginName].render(this)
            }
            _calculateBounds() {
                const t = this._texture.trim
                  , e = this._texture.orig;
                !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(),
                this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(),
                this._bounds.addQuad(this.vertexTrimmedData))
            }
            getLocalBounds(t) {
                return 0 === this.children.length ? (this._localBounds || (this._localBounds = new i.YZ),
                this._localBounds.minX = this._texture.orig.width * -this._anchor._x,
                this._localBounds.minY = this._texture.orig.height * -this._anchor._y,
                this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x),
                this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y),
                t || (this._localBoundsRect || (this._localBoundsRect = new n.Ae),
                t = this._localBoundsRect),
                this._localBounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
            }
            containsPoint(t) {
                this.worldTransform.applyInverse(t, s);
                const e = this._texture.orig.width
                  , r = this._texture.orig.height
                  , n = -e * this.anchor.x;
                let i = 0;
                return s.x >= n && s.x < n + e && (i = -r * this.anchor.y,
                s.y >= i && s.y < i + r)
            }
            destroy(t) {
                if (super.destroy(t),
                this._texture.off("update", this._onTextureUpdate, this),
                this._anchor = null,
                "boolean" == typeof t ? t : t?.texture) {
                    const e = "boolean" == typeof t ? t : t?.baseTexture;
                    this._texture.destroy(!!e)
                }
                this._texture = null
            }
            static from(t, e) {
                const r = t instanceof n.xE ? t : n.xE.from(t, e);
                return new a(r)
            }
            set roundPixels(t) {
                this._roundPixels !== t && (this._transformID = -1),
                this._roundPixels = t
            }
            get roundPixels() {
                return this._roundPixels
            }
            get width() {
                return Math.abs(this.scale.x) * this._texture.orig.width
            }
            set width(t) {
                const e = n.P6.sign(this.scale.x) || 1;
                this.scale.x = e * t / this._texture.orig.width,
                this._width = t
            }
            get height() {
                return Math.abs(this.scale.y) * this._texture.orig.height
            }
            set height(t) {
                const e = n.P6.sign(this.scale.y) || 1;
                this.scale.y = e * t / this._texture.orig.height,
                this._height = t
            }
            get anchor() {
                return this._anchor
            }
            set anchor(t) {
                this._anchor.copyFrom(t)
            }
            get tint() {
                return this._tintColor.value
            }
            set tint(t) {
                this._tintColor.setValue(t),
                this._tintRGB = this._tintColor.toLittleEndianNumber()
            }
            get tintValue() {
                return this._tintColor.toNumber()
            }
            get texture() {
                return this._texture
            }
            set texture(t) {
                this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this),
                this._texture = t || n.xE.EMPTY,
                this._cachedTint = 16777215,
                this._textureID = -1,
                this._textureTrimmedID = -1,
                t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
            }
        }
        const h = new n.y3;
        i.s$.prototype._cacheAsBitmap = !1,
        i.s$.prototype._cacheData = null,
        i.s$.prototype._cacheAsBitmapResolution = null,
        i.s$.prototype._cacheAsBitmapMultisample = null;
        class l {
            constructor() {
                this.textureCacheId = null,
                this.originalRender = null,
                this.originalRenderCanvas = null,
                this.originalCalculateBounds = null,
                this.originalGetLocalBounds = null,
                this.originalUpdateTransform = null,
                this.originalDestroy = null,
                this.originalMask = null,
                this.originalFilterArea = null,
                this.originalContainsPoint = null,
                this.sprite = null
            }
        }
        Object.defineProperties(i.s$.prototype, {
            cacheAsBitmapResolution: {
                get() {
                    return this._cacheAsBitmapResolution
                },
                set(t) {
                    t !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t,
                    this.cacheAsBitmap && (this.cacheAsBitmap = !1,
                    this.cacheAsBitmap = !0))
                }
            },
            cacheAsBitmapMultisample: {
                get() {
                    return this._cacheAsBitmapMultisample
                },
                set(t) {
                    t !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t,
                    this.cacheAsBitmap && (this.cacheAsBitmap = !1,
                    this.cacheAsBitmap = !0))
                }
            },
            cacheAsBitmap: {
                get() {
                    return this._cacheAsBitmap
                },
                set(t) {
                    if (this._cacheAsBitmap === t)
                        return;
                    let e;
                    this._cacheAsBitmap = t,
                    t ? (this._cacheData || (this._cacheData = new l),
                    e = this._cacheData,
                    e.originalRender = this.render,
                    e.originalRenderCanvas = this.renderCanvas,
                    e.originalUpdateTransform = this.updateTransform,
                    e.originalCalculateBounds = this.calculateBounds,
                    e.originalGetLocalBounds = this.getLocalBounds,
                    e.originalDestroy = this.destroy,
                    e.originalContainsPoint = this.containsPoint,
                    e.originalMask = this._mask,
                    e.originalFilterArea = this.filterArea,
                    this.render = this._renderCached,
                    this.renderCanvas = this._renderCachedCanvas,
                    this.destroy = this._cacheAsBitmapDestroy) : (e = this._cacheData,
                    e.sprite && this._destroyCachedDisplayObject(),
                    this.render = e.originalRender,
                    this.renderCanvas = e.originalRenderCanvas,
                    this.calculateBounds = e.originalCalculateBounds,
                    this.getLocalBounds = e.originalGetLocalBounds,
                    this.destroy = e.originalDestroy,
                    this.updateTransform = e.originalUpdateTransform,
                    this.containsPoint = e.originalContainsPoint,
                    this._mask = e.originalMask,
                    this.filterArea = e.originalFilterArea)
                }
            }
        }),
        i.s$.prototype._renderCached = function(t) {
            !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t),
            this._cacheData.sprite.transform._worldID = this.transform._worldID,
            this._cacheData.sprite.worldAlpha = this.worldAlpha,
            this._cacheData.sprite._render(t))
        }
        ,
        i.s$.prototype._initCachedDisplayObject = function(t) {
            if (this._cacheData?.sprite)
                return;
            const e = this.alpha;
            this.alpha = 1,
            t.batch.flush();
            const r = this.getLocalBounds(null, !0).clone();
            if (this.filters?.length) {
                const t = this.filters[0].padding;
                r.pad(t)
            }
            r.ceil(n.Xd.RESOLUTION);
            const i = t.renderTexture.current
              , s = t.renderTexture.sourceFrame.clone()
              , o = t.renderTexture.destinationFrame.clone()
              , l = t.projection.transform
              , u = n.TI.create({
                width: r.width,
                height: r.height,
                resolution: this.cacheAsBitmapResolution || t.resolution,
                multisample: this.cacheAsBitmapMultisample ?? t.multisample
            })
              , c = `cacheAsBitmap_${n.P6.uid()}`;
            this._cacheData.textureCacheId = c,
            n.VL.addToCache(u.baseTexture, c),
            n.xE.addToCache(u, c);
            const d = this.transform.localTransform.copyTo(h).invert().translate(-r.x, -r.y);
            this.render = this._cacheData.originalRender,
            t.render(this, {
                renderTexture: u,
                clear: !0,
                transform: d,
                skipUpdateTransform: !1
            }),
            t.framebuffer.blit(),
            t.projection.transform = l,
            t.renderTexture.bind(i, s, o),
            this.render = this._renderCached,
            this.updateTransform = this.displayObjectUpdateTransform,
            this.calculateBounds = this._calculateCachedBounds,
            this.getLocalBounds = this._getCachedLocalBounds,
            this._mask = null,
            this.filterArea = null,
            this.alpha = e;
            const f = new a(u);
            f.transform.worldTransform = this.transform.worldTransform,
            f.anchor.x = -r.x / r.width,
            f.anchor.y = -r.y / r.height,
            f.alpha = e,
            f._bounds = this._bounds,
            this._cacheData.sprite = f,
            this.transform._parentID = -1,
            this.parent ? this.updateTransform() : (this.enableTempParent(),
            this.updateTransform(),
            this.disableTempParent(null)),
            this.containsPoint = f.containsPoint.bind(f)
        }
        ,
        i.s$.prototype._renderCachedCanvas = function(t) {
            !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t),
            this._cacheData.sprite.worldAlpha = this.worldAlpha,
            this._cacheData.sprite._renderCanvas(t))
        }
        ,
        i.s$.prototype._initCachedDisplayObjectCanvas = function(t) {
            if (this._cacheData?.sprite)
                return;
            const e = this.getLocalBounds(null, !0)
              , r = this.alpha;
            this.alpha = 1;
            const i = t.canvasContext.activeContext
              , s = t._projTransform;
            e.ceil(n.Xd.RESOLUTION);
            const o = n.TI.create({
                width: e.width,
                height: e.height
            })
              , l = `cacheAsBitmap_${n.P6.uid()}`;
            this._cacheData.textureCacheId = l,
            n.VL.addToCache(o.baseTexture, l),
            n.xE.addToCache(o, l);
            const u = h;
            this.transform.localTransform.copyTo(u),
            u.invert(),
            u.tx -= e.x,
            u.ty -= e.y,
            this.renderCanvas = this._cacheData.originalRenderCanvas,
            t.render(this, {
                renderTexture: o,
                clear: !0,
                transform: u,
                skipUpdateTransform: !1
            }),
            t.canvasContext.activeContext = i,
            t._projTransform = s,
            this.renderCanvas = this._renderCachedCanvas,
            this.updateTransform = this.displayObjectUpdateTransform,
            this.calculateBounds = this._calculateCachedBounds,
            this.getLocalBounds = this._getCachedLocalBounds,
            this._mask = null,
            this.filterArea = null,
            this.alpha = r;
            const c = new a(o);
            c.transform.worldTransform = this.transform.worldTransform,
            c.anchor.x = -e.x / e.width,
            c.anchor.y = -e.y / e.height,
            c.alpha = r,
            c._bounds = this._bounds,
            this._cacheData.sprite = c,
            this.transform._parentID = -1,
            this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent,
            this.updateTransform(),
            this.parent = null),
            this.containsPoint = c.containsPoint.bind(c)
        }
        ,
        i.s$.prototype._calculateCachedBounds = function() {
            this._bounds.clear(),
            this._cacheData.sprite.transform._worldID = this.transform._worldID,
            this._cacheData.sprite._calculateBounds(),
            this._bounds.updateID = this._boundsID
        }
        ,
        i.s$.prototype._getCachedLocalBounds = function() {
            return this._cacheData.sprite.getLocalBounds(null)
        }
        ,
        i.s$.prototype._destroyCachedDisplayObject = function() {
            this._cacheData.sprite._texture.destroy(!0),
            this._cacheData.sprite = null,
            n.VL.removeFromCache(this._cacheData.textureCacheId),
            n.xE.removeFromCache(this._cacheData.textureCacheId),
            this._cacheData.textureCacheId = null
        }
        ,
        i.s$.prototype._cacheAsBitmapDestroy = function(t) {
            this.cacheAsBitmap = !1,
            this.destroy(t)
        }
        ,
        i.s$.prototype.name = null,
        i.W2.prototype.getChildByName = function(t, e) {
            for (let e = 0, r = this.children.length; e < r; e++)
                if (this.children[e].name === t)
                    return this.children[e];
            if (e)
                for (let e = 0, r = this.children.length; e < r; e++) {
                    const r = this.children[e];
                    if (!r.getChildByName)
                        continue;
                    const n = r.getChildByName(t, !0);
                    if (n)
                        return n
                }
            return null
        }
        ,
        i.s$.prototype.getGlobalPosition = function(t=new n.E9, e=!1) {
            return this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x,
            t.y = this.position.y),
            t
        }
        ;
        var u = r(92099)
          , c = r(56844);
        class d extends n.wn {
            constructor() {
                const t = {
                    m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
                    uAlpha: 1
                };
                super(n.Y9, "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", t),
                this.alpha = 1
            }
            _loadMatrix(t, e=!1) {
                let r = t;
                e && (this._multiply(r, this.uniforms.m, t),
                r = this._colorMatrix(r)),
                this.uniforms.m = r
            }
            _multiply(t, e, r) {
                return t[0] = e[0] * r[0] + e[1] * r[5] + e[2] * r[10] + e[3] * r[15],
                t[1] = e[0] * r[1] + e[1] * r[6] + e[2] * r[11] + e[3] * r[16],
                t[2] = e[0] * r[2] + e[1] * r[7] + e[2] * r[12] + e[3] * r[17],
                t[3] = e[0] * r[3] + e[1] * r[8] + e[2] * r[13] + e[3] * r[18],
                t[4] = e[0] * r[4] + e[1] * r[9] + e[2] * r[14] + e[3] * r[19] + e[4],
                t[5] = e[5] * r[0] + e[6] * r[5] + e[7] * r[10] + e[8] * r[15],
                t[6] = e[5] * r[1] + e[6] * r[6] + e[7] * r[11] + e[8] * r[16],
                t[7] = e[5] * r[2] + e[6] * r[7] + e[7] * r[12] + e[8] * r[17],
                t[8] = e[5] * r[3] + e[6] * r[8] + e[7] * r[13] + e[8] * r[18],
                t[9] = e[5] * r[4] + e[6] * r[9] + e[7] * r[14] + e[8] * r[19] + e[9],
                t[10] = e[10] * r[0] + e[11] * r[5] + e[12] * r[10] + e[13] * r[15],
                t[11] = e[10] * r[1] + e[11] * r[6] + e[12] * r[11] + e[13] * r[16],
                t[12] = e[10] * r[2] + e[11] * r[7] + e[12] * r[12] + e[13] * r[17],
                t[13] = e[10] * r[3] + e[11] * r[8] + e[12] * r[13] + e[13] * r[18],
                t[14] = e[10] * r[4] + e[11] * r[9] + e[12] * r[14] + e[13] * r[19] + e[14],
                t[15] = e[15] * r[0] + e[16] * r[5] + e[17] * r[10] + e[18] * r[15],
                t[16] = e[15] * r[1] + e[16] * r[6] + e[17] * r[11] + e[18] * r[16],
                t[17] = e[15] * r[2] + e[16] * r[7] + e[17] * r[12] + e[18] * r[17],
                t[18] = e[15] * r[3] + e[16] * r[8] + e[17] * r[13] + e[18] * r[18],
                t[19] = e[15] * r[4] + e[16] * r[9] + e[17] * r[14] + e[18] * r[19] + e[19],
                t
            }
            _colorMatrix(t) {
                const e = new Float32Array(t);
                return e[4] /= 255,
                e[9] /= 255,
                e[14] /= 255,
                e[19] /= 255,
                e
            }
            brightness(t, e) {
                const r = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
                this._loadMatrix(r, e)
            }
            tint(t, e) {
                const [r,i,s] = n.Il.shared.setValue(t).toArray()
                  , o = [r, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, s, 0, 0, 0, 0, 0, 1, 0];
                this._loadMatrix(o, e)
            }
            greyscale(t, e) {
                const r = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
                this._loadMatrix(r, e)
            }
            blackAndWhite(t) {
                this._loadMatrix([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], t)
            }
            hue(t, e) {
                t = (t || 0) / 180 * Math.PI;
                const r = Math.cos(t)
                  , n = Math.sin(t)
                  , i = 1 / 3
                  , s = (0,
                Math.sqrt)(i)
                  , o = [r + (1 - r) * i, i * (1 - r) - s * n, i * (1 - r) + s * n, 0, 0, i * (1 - r) + s * n, r + i * (1 - r), i * (1 - r) - s * n, 0, 0, i * (1 - r) - s * n, i * (1 - r) + s * n, r + i * (1 - r), 0, 0, 0, 0, 0, 1, 0];
                this._loadMatrix(o, e)
            }
            contrast(t, e) {
                const r = (t || 0) + 1
                  , n = -.5 * (r - 1)
                  , i = [r, 0, 0, 0, n, 0, r, 0, 0, n, 0, 0, r, 0, n, 0, 0, 0, 1, 0];
                this._loadMatrix(i, e)
            }
            saturate(t=0, e) {
                const r = 2 * t / 3 + 1
                  , n = -.5 * (r - 1)
                  , i = [r, n, n, 0, 0, n, r, n, 0, 0, n, n, r, 0, 0, 0, 0, 0, 1, 0];
                this._loadMatrix(i, e)
            }
            desaturate() {
                this.saturate(-1)
            }
            negative(t) {
                this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t)
            }
            sepia(t) {
                this._loadMatrix([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], t)
            }
            technicolor(t) {
                this._loadMatrix([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t)
            }
            polaroid(t) {
                this._loadMatrix([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t)
            }
            toBGR(t) {
                this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t)
            }
            kodachrome(t) {
                this._loadMatrix([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t)
            }
            browni(t) {
                this._loadMatrix([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t)
            }
            vintage(t) {
                this._loadMatrix([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t)
            }
            colorTone(t, e, r, i, s) {
                t = t || .2,
                e = e || .15,
                r = r || 16770432,
                i = i || 3375104;
                const o = n.Il.shared
                  , [a,h,l] = o.setValue(r).toArray()
                  , [u,c,d] = o.setValue(i).toArray()
                  , f = [.3, .59, .11, 0, 0, a, h, l, t, 0, u, c, d, e, 0, a - u, h - c, l - d, 0, 0];
                this._loadMatrix(f, s)
            }
            night(t, e) {
                const r = [-2 * (t = t || .1), -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0];
                this._loadMatrix(r, e)
            }
            predator(t, e) {
                const r = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
                this._loadMatrix(r, e)
            }
            lsd(t) {
                this._loadMatrix([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], t)
            }
            reset() {
                this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1)
            }
            get matrix() {
                return this.uniforms.m
            }
            set matrix(t) {
                this.uniforms.m = t
            }
            get alpha() {
                return this.uniforms.uAlpha
            }
            set alpha(t) {
                this.uniforms.uAlpha = t
            }
        }
        d.prototype.grayscale = d.prototype.greyscale;
        class f extends n.wn {
            constructor(t, e) {
                const r = new n.y3;
                t.renderable = !1,
                super("attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", {
                    mapSampler: t._texture,
                    filterMatrix: r,
                    scale: {
                        x: 1,
                        y: 1
                    },
                    rotation: new Float32Array([1, 0, 0, 1])
                }),
                this.maskSprite = t,
                this.maskMatrix = r,
                null == e && (e = 20),
                this.scale = new n.E9(e,e)
            }
            apply(t, e, r, n) {
                this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite),
                this.uniforms.scale.x = this.scale.x,
                this.uniforms.scale.y = this.scale.y;
                const i = this.maskSprite.worldTransform
                  , s = Math.sqrt(i.a * i.a + i.b * i.b)
                  , o = Math.sqrt(i.c * i.c + i.d * i.d);
                0 !== s && 0 !== o && (this.uniforms.rotation[0] = i.a / s,
                this.uniforms.rotation[1] = i.b / s,
                this.uniforms.rotation[2] = i.c / o,
                this.uniforms.rotation[3] = i.d / o),
                t.applyFilter(this, e, r, n)
            }
            get map() {
                return this.uniforms.mapSampler
            }
            set map(t) {
                this.uniforms.mapSampler = t
            }
        }
        class p extends n.wn {
            constructor() {
                super("\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n')
            }
        }
        class m extends n.wn {
            constructor(t=.5, e=Math.random()) {
                super(n.Y9, "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", {
                    uNoise: 0,
                    uSeed: 0
                }),
                this.noise = t,
                this.seed = e
            }
            get noise() {
                return this.uniforms.uNoise
            }
            set noise(t) {
                this.uniforms.uNoise = t
            }
            get seed() {
                return this.uniforms.uSeed
            }
            set seed(t) {
                this.uniforms.uSeed = t
            }
        }
        const g = {
            AlphaFilter: u.U,
            BlurFilter: c.T,
            BlurFilterPass: c.Y,
            ColorMatrixFilter: d,
            DisplacementFilter: f,
            FXAAFilter: p,
            NoiseFilter: m
        };
        Object.entries(g).forEach(( ([t,e]) => {
            Object.defineProperty(g, t, {
                get() {
                    return n.P6.deprecation("7.1.0", `filters.${t} has moved to ${t}`),
                    e
                }
            })
        }
        ));
        const v = new class {
            constructor() {
                this.interactionFrequency = 10,
                this._deltaTime = 0,
                this._didMove = !1,
                this.tickerAdded = !1,
                this._pauseUpdate = !0
            }
            init(t) {
                this.removeTickerListener(),
                this.events = t,
                this.interactionFrequency = 10,
                this._deltaTime = 0,
                this._didMove = !1,
                this.tickerAdded = !1,
                this._pauseUpdate = !0
            }
            get pauseUpdate() {
                return this._pauseUpdate
            }
            set pauseUpdate(t) {
                this._pauseUpdate = t
            }
            addTickerListener() {
                !this.tickerAdded && this.domElement && (n.vB.system.add(this.tickerUpdate, this, n.uF.INTERACTION),
                this.tickerAdded = !0)
            }
            removeTickerListener() {
                this.tickerAdded && (n.vB.system.remove(this.tickerUpdate, this),
                this.tickerAdded = !1)
            }
            pointerMoved() {
                this._didMove = !0
            }
            update() {
                if (!this.domElement || this._pauseUpdate)
                    return;
                if (this._didMove)
                    return void (this._didMove = !1);
                const t = this.events.rootPointerEvent;
                this.events.supportsTouchEvents && "touch" === t.pointerType || globalThis.document.dispatchEvent(new PointerEvent("pointermove",{
                    clientX: t.clientX,
                    clientY: t.clientY
                }))
            }
            tickerUpdate(t) {
                this._deltaTime += t,
                this._deltaTime < this.interactionFrequency || (this._deltaTime = 0,
                this.update())
            }
        }
        ;
        class y {
            constructor(t) {
                this.bubbles = !0,
                this.cancelBubble = !0,
                this.cancelable = !1,
                this.composed = !1,
                this.defaultPrevented = !1,
                this.eventPhase = y.prototype.NONE,
                this.propagationStopped = !1,
                this.propagationImmediatelyStopped = !1,
                this.layer = new n.E9,
                this.page = new n.E9,
                this.NONE = 0,
                this.CAPTURING_PHASE = 1,
                this.AT_TARGET = 2,
                this.BUBBLING_PHASE = 3,
                this.manager = t
            }
            get layerX() {
                return this.layer.x
            }
            get layerY() {
                return this.layer.y
            }
            get pageX() {
                return this.page.x
            }
            get pageY() {
                return this.page.y
            }
            get data() {
                return this
            }
            composedPath() {
                return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []),
                this.path
            }
            initEvent(t, e, r) {
                throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
            }
            initUIEvent(t, e, r, n, i) {
                throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
            }
            preventDefault() {
                this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
                this.defaultPrevented = !0
            }
            stopImmediatePropagation() {
                this.propagationImmediatelyStopped = !0
            }
            stopPropagation() {
                this.propagationStopped = !0
            }
        }
        class _ extends y {
            constructor() {
                super(...arguments),
                this.client = new n.E9,
                this.movement = new n.E9,
                this.offset = new n.E9,
                this.global = new n.E9,
                this.screen = new n.E9
            }
            get clientX() {
                return this.client.x
            }
            get clientY() {
                return this.client.y
            }
            get x() {
                return this.clientX
            }
            get y() {
                return this.clientY
            }
            get movementX() {
                return this.movement.x
            }
            get movementY() {
                return this.movement.y
            }
            get offsetX() {
                return this.offset.x
            }
            get offsetY() {
                return this.offset.y
            }
            get globalX() {
                return this.global.x
            }
            get globalY() {
                return this.global.y
            }
            get screenX() {
                return this.screen.x
            }
            get screenY() {
                return this.screen.y
            }
            getLocalPosition(t, e, r) {
                return t.worldTransform.applyInverse(r || this.global, e)
            }
            getModifierState(t) {
                return "getModifierState"in this.nativeEvent && this.nativeEvent.getModifierState(t)
            }
            initMouseEvent(t, e, r, n, i, s, o, a, h, l, u, c, d, f, p) {
                throw new Error("Method not implemented.")
            }
        }
        class x extends _ {
            constructor() {
                super(...arguments),
                this.width = 0,
                this.height = 0,
                this.isPrimary = !1
            }
            getCoalescedEvents() {
                return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : []
            }
            getPredictedEvents() {
                throw new Error("getPredictedEvents is not supported!")
            }
        }
        class b extends _ {
            constructor() {
                super(...arguments),
                this.DOM_DELTA_PIXEL = 0,
                this.DOM_DELTA_LINE = 1,
                this.DOM_DELTA_PAGE = 2
            }
        }
        b.DOM_DELTA_PIXEL = 0,
        b.DOM_DELTA_LINE = 1,
        b.DOM_DELTA_PAGE = 2;
        const E = new n.E9
          , T = new n.E9;
        class w {
            constructor(t) {
                this.dispatch = new n.P6.EventEmitter,
                this.moveOnAll = !1,
                this.enableGlobalMoveEvents = !0,
                this.mappingState = {
                    trackingData: {}
                },
                this.eventPool = new Map,
                this._allInteractiveElements = [],
                this._hitElements = [],
                this._isPointerMoveEvent = !1,
                this.rootTarget = t,
                this.hitPruneFn = this.hitPruneFn.bind(this),
                this.hitTestFn = this.hitTestFn.bind(this),
                this.mapPointerDown = this.mapPointerDown.bind(this),
                this.mapPointerMove = this.mapPointerMove.bind(this),
                this.mapPointerOut = this.mapPointerOut.bind(this),
                this.mapPointerOver = this.mapPointerOver.bind(this),
                this.mapPointerUp = this.mapPointerUp.bind(this),
                this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this),
                this.mapWheel = this.mapWheel.bind(this),
                this.mappingTable = {},
                this.addEventMapping("pointerdown", this.mapPointerDown),
                this.addEventMapping("pointermove", this.mapPointerMove),
                this.addEventMapping("pointerout", this.mapPointerOut),
                this.addEventMapping("pointerleave", this.mapPointerOut),
                this.addEventMapping("pointerover", this.mapPointerOver),
                this.addEventMapping("pointerup", this.mapPointerUp),
                this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
                this.addEventMapping("wheel", this.mapWheel)
            }
            addEventMapping(t, e) {
                this.mappingTable[t] || (this.mappingTable[t] = []),
                this.mappingTable[t].push({
                    fn: e,
                    priority: 0
                }),
                this.mappingTable[t].sort(( (t, e) => t.priority - e.priority))
            }
            dispatchEvent(t, e) {
                t.propagationStopped = !1,
                t.propagationImmediatelyStopped = !1,
                this.propagate(t, e),
                this.dispatch.emit(e || t.type, t)
            }
            mapEvent(t) {
                if (!this.rootTarget)
                    return;
                const e = this.mappingTable[t.type];
                if (e)
                    for (let r = 0, n = e.length; r < n; r++)
                        e[r].fn(t);
                else
                    console.warn(`[EventBoundary]: Event mapping not defined for ${t.type}`)
            }
            hitTest(t, e) {
                v.pauseUpdate = !0;
                const r = this[this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"](this.rootTarget, this.rootTarget.eventMode, E.set(t, e), this.hitTestFn, this.hitPruneFn);
                return r && r[0]
            }
            propagate(t, e) {
                if (!t.target)
                    return;
                const r = t.composedPath();
                t.eventPhase = t.CAPTURING_PHASE;
                for (let n = 0, i = r.length - 1; n < i; n++)
                    if (t.currentTarget = r[n],
                    this.notifyTarget(t, e),
                    t.propagationStopped || t.propagationImmediatelyStopped)
                        return;
                if (t.eventPhase = t.AT_TARGET,
                t.currentTarget = t.target,
                this.notifyTarget(t, e),
                !t.propagationStopped && !t.propagationImmediatelyStopped) {
                    t.eventPhase = t.BUBBLING_PHASE;
                    for (let n = r.length - 2; n >= 0; n--)
                        if (t.currentTarget = r[n],
                        this.notifyTarget(t, e),
                        t.propagationStopped || t.propagationImmediatelyStopped)
                            return
                }
            }
            all(t, e, r=this._allInteractiveElements) {
                if (0 === r.length)
                    return;
                t.eventPhase = t.BUBBLING_PHASE;
                const n = Array.isArray(e) ? e : [e];
                for (let e = r.length - 1; e >= 0; e--)
                    n.forEach((n => {
                        t.currentTarget = r[e],
                        this.notifyTarget(t, n)
                    }
                    ))
            }
            propagationPath(t) {
                const e = [t];
                for (let r = 0; r < 2048 && t !== this.rootTarget; r++) {
                    if (!t.parent)
                        throw new Error("Cannot find propagation path to disconnected target");
                    e.push(t.parent),
                    t = t.parent
                }
                return e.reverse(),
                e
            }
            hitTestMoveRecursive(t, e, r, n, i, s=!1) {
                let o = !1;
                if (this._interactivePrune(t))
                    return null;
                if ("dynamic" !== t.eventMode && "dynamic" !== e || (v.pauseUpdate = !1),
                t.interactiveChildren && t.children) {
                    const a = t.children;
                    for (let h = a.length - 1; h >= 0; h--) {
                        const l = a[h]
                          , u = this.hitTestMoveRecursive(l, this._isInteractive(e) ? e : l.eventMode, r, n, i, s || i(t, r));
                        if (u) {
                            if (u.length > 0 && !u[u.length - 1].parent)
                                continue;
                            const e = t.isInteractive();
                            (u.length > 0 || e) && (e && this._allInteractiveElements.push(t),
                            u.push(t)),
                            0 === this._hitElements.length && (this._hitElements = u),
                            o = !0
                        }
                    }
                }
                const a = this._isInteractive(e)
                  , h = t.isInteractive();
                return h && h && this._allInteractiveElements.push(t),
                s || this._hitElements.length > 0 ? null : o ? this._hitElements : a && !i(t, r) && n(t, r) ? h ? [t] : [] : null
            }
            hitTestRecursive(t, e, r, n, i) {
                if (this._interactivePrune(t) || i(t, r))
                    return null;
                if ("dynamic" !== t.eventMode && "dynamic" !== e || (v.pauseUpdate = !1),
                t.interactiveChildren && t.children) {
                    const s = t.children;
                    for (let o = s.length - 1; o >= 0; o--) {
                        const a = s[o]
                          , h = this.hitTestRecursive(a, this._isInteractive(e) ? e : a.eventMode, r, n, i);
                        if (h) {
                            if (h.length > 0 && !h[h.length - 1].parent)
                                continue;
                            const e = t.isInteractive();
                            return (h.length > 0 || e) && h.push(t),
                            h
                        }
                    }
                }
                const s = this._isInteractive(e)
                  , o = t.isInteractive();
                return s && n(t, r) ? o ? [t] : [] : null
            }
            _isInteractive(t) {
                return "static" === t || "dynamic" === t
            }
            _interactivePrune(t) {
                return !(t && !t.isMask && t.visible && t.renderable) || "none" === t.eventMode || "passive" === t.eventMode && !t.interactiveChildren || !!t.isMask
            }
            hitPruneFn(t, e) {
                if (t.hitArea && (t.worldTransform.applyInverse(e, T),
                !t.hitArea.contains(T.x, T.y)))
                    return !0;
                if (t._mask) {
                    const r = t._mask.isMaskData ? t._mask.maskObject : t._mask;
                    if (r && !r.containsPoint?.(e))
                        return !0
                }
                return !1
            }
            hitTestFn(t, e) {
                return "passive" !== t.eventMode && (!!t.hitArea || !!t.containsPoint && t.containsPoint(e))
            }
            notifyTarget(t, e) {
                const r = `on${e = e ?? t.type}`;
                t.currentTarget[r]?.(t);
                const n = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e;
                this.notifyListeners(t, n),
                t.eventPhase === t.AT_TARGET && this.notifyListeners(t, e)
            }
            mapPointerDown(t) {
                if (!(t instanceof x))
                    return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                const e = this.createPointerEvent(t);
                if (this.dispatchEvent(e, "pointerdown"),
                "touch" === e.pointerType)
                    this.dispatchEvent(e, "touchstart");
                else if ("mouse" === e.pointerType || "pen" === e.pointerType) {
                    const t = 2 === e.button;
                    this.dispatchEvent(e, t ? "rightdown" : "mousedown")
                }
                this.trackingData(t.pointerId).pressTargetsByButton[t.button] = e.composedPath(),
                this.freeEvent(e)
            }
            mapPointerMove(t) {
                if (!(t instanceof x))
                    return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                this._allInteractiveElements.length = 0,
                this._hitElements.length = 0,
                this._isPointerMoveEvent = !0;
                const e = this.createPointerEvent(t);
                this._isPointerMoveEvent = !1;
                const r = "mouse" === e.pointerType || "pen" === e.pointerType
                  , n = this.trackingData(t.pointerId)
                  , i = this.findMountedTarget(n.overTargets);
                if (n.overTargets?.length > 0 && i !== e.target) {
                    const n = "mousemove" === t.type ? "mouseout" : "pointerout"
                      , s = this.createPointerEvent(t, n, i);
                    if (this.dispatchEvent(s, "pointerout"),
                    r && this.dispatchEvent(s, "mouseout"),
                    !e.composedPath().includes(i)) {
                        const n = this.createPointerEvent(t, "pointerleave", i);
                        for (n.eventPhase = n.AT_TARGET; n.target && !e.composedPath().includes(n.target); )
                            n.currentTarget = n.target,
                            this.notifyTarget(n),
                            r && this.notifyTarget(n, "mouseleave"),
                            n.target = n.target.parent;
                        this.freeEvent(n)
                    }
                    this.freeEvent(s)
                }
                if (i !== e.target) {
                    const n = "mousemove" === t.type ? "mouseover" : "pointerover"
                      , s = this.clonePointerEvent(e, n);
                    this.dispatchEvent(s, "pointerover"),
                    r && this.dispatchEvent(s, "mouseover");
                    let o = i?.parent;
                    for (; o && o !== this.rootTarget.parent && o !== e.target; )
                        o = o.parent;
                    if (!o || o === this.rootTarget.parent) {
                        const t = this.clonePointerEvent(e, "pointerenter");
                        for (t.eventPhase = t.AT_TARGET; t.target && t.target !== i && t.target !== this.rootTarget.parent; )
                            t.currentTarget = t.target,
                            this.notifyTarget(t),
                            r && this.notifyTarget(t, "mouseenter"),
                            t.target = t.target.parent;
                        this.freeEvent(t)
                    }
                    this.freeEvent(s)
                }
                const s = []
                  , o = this.enableGlobalMoveEvents ?? !0;
                this.moveOnAll ? s.push("pointermove") : this.dispatchEvent(e, "pointermove"),
                o && s.push("globalpointermove"),
                "touch" === e.pointerType && (this.moveOnAll ? s.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"),
                o && s.push("globaltouchmove")),
                r && (this.moveOnAll ? s.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"),
                o && s.push("globalmousemove"),
                this.cursor = e.target?.cursor),
                s.length > 0 && this.all(e, s),
                this._allInteractiveElements.length = 0,
                this._hitElements.length = 0,
                n.overTargets = e.composedPath(),
                this.freeEvent(e)
            }
            mapPointerOver(t) {
                if (!(t instanceof x))
                    return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                const e = this.trackingData(t.pointerId)
                  , r = this.createPointerEvent(t)
                  , n = "mouse" === r.pointerType || "pen" === r.pointerType;
                this.dispatchEvent(r, "pointerover"),
                n && this.dispatchEvent(r, "mouseover"),
                "mouse" === r.pointerType && (this.cursor = r.target?.cursor);
                const i = this.clonePointerEvent(r, "pointerenter");
                for (i.eventPhase = i.AT_TARGET; i.target && i.target !== this.rootTarget.parent; )
                    i.currentTarget = i.target,
                    this.notifyTarget(i),
                    n && this.notifyTarget(i, "mouseenter"),
                    i.target = i.target.parent;
                e.overTargets = r.composedPath(),
                this.freeEvent(r),
                this.freeEvent(i)
            }
            mapPointerOut(t) {
                if (!(t instanceof x))
                    return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                const e = this.trackingData(t.pointerId);
                if (e.overTargets) {
                    const r = "mouse" === t.pointerType || "pen" === t.pointerType
                      , n = this.findMountedTarget(e.overTargets)
                      , i = this.createPointerEvent(t, "pointerout", n);
                    this.dispatchEvent(i),
                    r && this.dispatchEvent(i, "mouseout");
                    const s = this.createPointerEvent(t, "pointerleave", n);
                    for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent; )
                        s.currentTarget = s.target,
                        this.notifyTarget(s),
                        r && this.notifyTarget(s, "mouseleave"),
                        s.target = s.target.parent;
                    e.overTargets = null,
                    this.freeEvent(i),
                    this.freeEvent(s)
                }
                this.cursor = null
            }
            mapPointerUp(t) {
                if (!(t instanceof x))
                    return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                const e = performance.now()
                  , r = this.createPointerEvent(t);
                if (this.dispatchEvent(r, "pointerup"),
                "touch" === r.pointerType)
                    this.dispatchEvent(r, "touchend");
                else if ("mouse" === r.pointerType || "pen" === r.pointerType) {
                    const t = 2 === r.button;
                    this.dispatchEvent(r, t ? "rightup" : "mouseup")
                }
                const n = this.trackingData(t.pointerId)
                  , i = this.findMountedTarget(n.pressTargetsByButton[t.button]);
                let s = i;
                if (i && !r.composedPath().includes(i)) {
                    let e = i;
                    for (; e && !r.composedPath().includes(e); ) {
                        if (r.currentTarget = e,
                        this.notifyTarget(r, "pointerupoutside"),
                        "touch" === r.pointerType)
                            this.notifyTarget(r, "touchendoutside");
                        else if ("mouse" === r.pointerType || "pen" === r.pointerType) {
                            const t = 2 === r.button;
                            this.notifyTarget(r, t ? "rightupoutside" : "mouseupoutside")
                        }
                        e = e.parent
                    }
                    delete n.pressTargetsByButton[t.button],
                    s = e
                }
                if (s) {
                    const i = this.clonePointerEvent(r, "click");
                    i.target = s,
                    i.path = null,
                    n.clicksByButton[t.button] || (n.clicksByButton[t.button] = {
                        clickCount: 0,
                        target: i.target,
                        timeStamp: e
                    });
                    const o = n.clicksByButton[t.button];
                    if (o.target === i.target && e - o.timeStamp < 200 ? ++o.clickCount : o.clickCount = 1,
                    o.target = i.target,
                    o.timeStamp = e,
                    i.detail = o.clickCount,
                    "mouse" === i.pointerType) {
                        const t = 2 === i.button;
                        this.dispatchEvent(i, t ? "rightclick" : "click")
                    } else
                        "touch" === i.pointerType && this.dispatchEvent(i, "tap");
                    this.dispatchEvent(i, "pointertap"),
                    this.freeEvent(i)
                }
                this.freeEvent(r)
            }
            mapPointerUpOutside(t) {
                if (!(t instanceof x))
                    return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                const e = this.trackingData(t.pointerId)
                  , r = this.findMountedTarget(e.pressTargetsByButton[t.button])
                  , n = this.createPointerEvent(t);
                if (r) {
                    let i = r;
                    for (; i; )
                        n.currentTarget = i,
                        this.notifyTarget(n, "pointerupoutside"),
                        "touch" === n.pointerType ? this.notifyTarget(n, "touchendoutside") : "mouse" !== n.pointerType && "pen" !== n.pointerType || this.notifyTarget(n, 2 === n.button ? "rightupoutside" : "mouseupoutside"),
                        i = i.parent;
                    delete e.pressTargetsByButton[t.button]
                }
                this.freeEvent(n)
            }
            mapWheel(t) {
                if (!(t instanceof b))
                    return void console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
                const e = this.createWheelEvent(t);
                this.dispatchEvent(e),
                this.freeEvent(e)
            }
            findMountedTarget(t) {
                if (!t)
                    return null;
                let e = t[0];
                for (let r = 1; r < t.length && t[r].parent === e; r++)
                    e = t[r];
                return e
            }
            createPointerEvent(t, e, r) {
                const n = this.allocateEvent(x);
                return this.copyPointerData(t, n),
                this.copyMouseData(t, n),
                this.copyData(t, n),
                n.nativeEvent = t.nativeEvent,
                n.originalEvent = t,
                n.target = r ?? this.hitTest(n.global.x, n.global.y) ?? this._hitElements[0],
                "string" == typeof e && (n.type = e),
                n
            }
            createWheelEvent(t) {
                const e = this.allocateEvent(b);
                return this.copyWheelData(t, e),
                this.copyMouseData(t, e),
                this.copyData(t, e),
                e.nativeEvent = t.nativeEvent,
                e.originalEvent = t,
                e.target = this.hitTest(e.global.x, e.global.y),
                e
            }
            clonePointerEvent(t, e) {
                const r = this.allocateEvent(x);
                return r.nativeEvent = t.nativeEvent,
                r.originalEvent = t.originalEvent,
                this.copyPointerData(t, r),
                this.copyMouseData(t, r),
                this.copyData(t, r),
                r.target = t.target,
                r.path = t.composedPath().slice(),
                r.type = e ?? r.type,
                r
            }
            copyWheelData(t, e) {
                e.deltaMode = t.deltaMode,
                e.deltaX = t.deltaX,
                e.deltaY = t.deltaY,
                e.deltaZ = t.deltaZ
            }
            copyPointerData(t, e) {
                t instanceof x && e instanceof x && (e.pointerId = t.pointerId,
                e.width = t.width,
                e.height = t.height,
                e.isPrimary = t.isPrimary,
                e.pointerType = t.pointerType,
                e.pressure = t.pressure,
                e.tangentialPressure = t.tangentialPressure,
                e.tiltX = t.tiltX,
                e.tiltY = t.tiltY,
                e.twist = t.twist)
            }
            copyMouseData(t, e) {
                t instanceof _ && e instanceof _ && (e.altKey = t.altKey,
                e.button = t.button,
                e.buttons = t.buttons,
                e.client.copyFrom(t.client),
                e.ctrlKey = t.ctrlKey,
                e.metaKey = t.metaKey,
                e.movement.copyFrom(t.movement),
                e.screen.copyFrom(t.screen),
                e.shiftKey = t.shiftKey,
                e.global.copyFrom(t.global))
            }
            copyData(t, e) {
                e.isTrusted = t.isTrusted,
                e.srcElement = t.srcElement,
                e.timeStamp = performance.now(),
                e.type = t.type,
                e.detail = t.detail,
                e.view = t.view,
                e.which = t.which,
                e.layer.copyFrom(t.layer),
                e.page.copyFrom(t.page)
            }
            trackingData(t) {
                return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
                    pressTargetsByButton: {},
                    clicksByButton: {},
                    overTarget: null
                }),
                this.mappingState.trackingData[t]
            }
            allocateEvent(t) {
                this.eventPool.has(t) || this.eventPool.set(t, []);
                const e = this.eventPool.get(t).pop() || new t(this);
                return e.eventPhase = e.NONE,
                e.currentTarget = null,
                e.path = null,
                e.target = null,
                e
            }
            freeEvent(t) {
                if (t.manager !== this)
                    throw new Error("It is illegal to free an event not managed by this EventBoundary!");
                const e = t.constructor;
                this.eventPool.has(e) || this.eventPool.set(e, []),
                this.eventPool.get(e).push(t)
            }
            notifyListeners(t, e) {
                const r = t.currentTarget._events[e];
                if (r && t.currentTarget.isInteractive())
                    if ("fn"in r)
                        r.once && t.currentTarget.removeListener(e, r.fn, void 0, !0),
                        r.fn.call(r.context, t);
                    else
                        for (let n = 0, i = r.length; n < i && !t.propagationImmediatelyStopped; n++)
                            r[n].once && t.currentTarget.removeListener(e, r[n].fn, void 0, !0),
                            r[n].fn.call(r[n].context, t)
            }
        }
        const S = {
            touchstart: "pointerdown",
            touchend: "pointerup",
            touchendoutside: "pointerupoutside",
            touchmove: "pointermove",
            touchcancel: "pointercancel"
        }
          , A = class {
            constructor(t) {
                this.supportsTouchEvents = "ontouchstart"in globalThis,
                this.supportsPointerEvents = !!globalThis.PointerEvent,
                this.domElement = null,
                this.resolution = 1,
                this.renderer = t,
                this.rootBoundary = new w(null),
                v.init(this),
                this.autoPreventDefault = !0,
                this.eventsAdded = !1,
                this.rootPointerEvent = new x(null),
                this.rootWheelEvent = new b(null),
                this.cursorStyles = {
                    default: "inherit",
                    pointer: "pointer"
                },
                this.features = new Proxy({
                    ...A.defaultEventFeatures
                },{
                    set: (t, e, r) => ("globalMove" === e && (this.rootBoundary.enableGlobalMoveEvents = r),
                    t[e] = r,
                    !0)
                }),
                this.onPointerDown = this.onPointerDown.bind(this),
                this.onPointerMove = this.onPointerMove.bind(this),
                this.onPointerUp = this.onPointerUp.bind(this),
                this.onPointerOverOut = this.onPointerOverOut.bind(this),
                this.onWheel = this.onWheel.bind(this)
            }
            static get defaultEventMode() {
                return this._defaultEventMode
            }
            init(t) {
                const {view: e, resolution: r} = this.renderer;
                this.setTargetElement(e),
                this.resolution = r,
                A._defaultEventMode = t.eventMode ?? "auto",
                Object.assign(this.features, t.eventFeatures ?? {}),
                this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
            }
            resolutionChange(t) {
                this.resolution = t
            }
            destroy() {
                this.setTargetElement(null),
                this.renderer = null
            }
            setCursor(t) {
                t = t || "default";
                let e = !0;
                if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = !1),
                this.currentCursor === t)
                    return;
                this.currentCursor = t;
                const r = this.cursorStyles[t];
                if (r)
                    switch (typeof r) {
                    case "string":
                        e && (this.domElement.style.cursor = r);
                        break;
                    case "function":
                        r(t);
                        break;
                    case "object":
                        e && Object.assign(this.domElement.style, r)
                    }
                else
                    e && "string" == typeof t && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t)
            }
            get pointer() {
                return this.rootPointerEvent
            }
            onPointerDown(t) {
                if (!this.features.click)
                    return;
                if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
                this.supportsTouchEvents && "touch" === t.pointerType)
                    return;
                const e = this.normalizeToPointerData(t);
                this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable"in t)) && t.preventDefault();
                for (let t = 0, r = e.length; t < r; t++) {
                    const r = e[t]
                      , n = this.bootstrapEvent(this.rootPointerEvent, r);
                    this.rootBoundary.mapEvent(n)
                }
                this.setCursor(this.rootBoundary.cursor)
            }
            onPointerMove(t) {
                if (!this.features.move)
                    return;
                if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
                this.supportsTouchEvents && "touch" === t.pointerType)
                    return;
                v.pointerMoved();
                const e = this.normalizeToPointerData(t);
                for (let t = 0, r = e.length; t < r; t++) {
                    const r = this.bootstrapEvent(this.rootPointerEvent, e[t]);
                    this.rootBoundary.mapEvent(r)
                }
                this.setCursor(this.rootBoundary.cursor)
            }
            onPointerUp(t) {
                if (!this.features.click)
                    return;
                if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
                this.supportsTouchEvents && "touch" === t.pointerType)
                    return;
                let e = t.target;
                t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]);
                const r = e !== this.domElement ? "outside" : ""
                  , n = this.normalizeToPointerData(t);
                for (let t = 0, e = n.length; t < e; t++) {
                    const e = this.bootstrapEvent(this.rootPointerEvent, n[t]);
                    e.type += r,
                    this.rootBoundary.mapEvent(e)
                }
                this.setCursor(this.rootBoundary.cursor)
            }
            onPointerOverOut(t) {
                if (!this.features.click)
                    return;
                if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
                this.supportsTouchEvents && "touch" === t.pointerType)
                    return;
                const e = this.normalizeToPointerData(t);
                for (let t = 0, r = e.length; t < r; t++) {
                    const r = this.bootstrapEvent(this.rootPointerEvent, e[t]);
                    this.rootBoundary.mapEvent(r)
                }
                this.setCursor(this.rootBoundary.cursor)
            }
            onWheel(t) {
                if (!this.features.wheel)
                    return;
                const e = this.normalizeWheelEvent(t);
                this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
                this.rootBoundary.mapEvent(e)
            }
            setTargetElement(t) {
                this.removeEvents(),
                this.domElement = t,
                v.domElement = t,
                this.addEvents()
            }
            addEvents() {
                if (this.eventsAdded || !this.domElement)
                    return;
                v.addTickerListener();
                const t = this.domElement.style;
                t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none",
                t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")),
                this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0),
                this.domElement.addEventListener("pointerdown", this.onPointerDown, !0),
                this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0),
                this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0),
                globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0),
                this.domElement.addEventListener("mousedown", this.onPointerDown, !0),
                this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0),
                this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0),
                globalThis.addEventListener("mouseup", this.onPointerUp, !0)),
                this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0),
                this.domElement.addEventListener("touchend", this.onPointerUp, !0),
                this.domElement.addEventListener("touchmove", this.onPointerMove, !0)),
                this.domElement.addEventListener("wheel", this.onWheel, {
                    passive: !0,
                    capture: !0
                }),
                this.eventsAdded = !0
            }
            removeEvents() {
                if (!this.eventsAdded || !this.domElement)
                    return;
                v.removeTickerListener();
                const t = this.domElement.style;
                globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "",
                t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""),
                this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0),
                this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0),
                this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0),
                this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0),
                globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0),
                this.domElement.removeEventListener("mousedown", this.onPointerDown, !0),
                this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0),
                this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0),
                globalThis.removeEventListener("mouseup", this.onPointerUp, !0)),
                this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0),
                this.domElement.removeEventListener("touchend", this.onPointerUp, !0),
                this.domElement.removeEventListener("touchmove", this.onPointerMove, !0)),
                this.domElement.removeEventListener("wheel", this.onWheel, !0),
                this.domElement = null,
                this.eventsAdded = !1
            }
            mapPositionToPoint(t, e, r) {
                let n;
                n = this.domElement.parentElement ? this.domElement.getBoundingClientRect() : {
                    x: 0,
                    y: 0,
                    width: this.domElement.width,
                    height: this.domElement.height,
                    left: 0,
                    top: 0
                };
                const i = 1 / this.resolution;
                t.x = (e - n.left) * (this.domElement.width / n.width) * i,
                t.y = (r - n.top) * (this.domElement.height / n.height) * i
            }
            normalizeToPointerData(t) {
                const e = [];
                if (this.supportsTouchEvents && t instanceof TouchEvent)
                    for (let r = 0, n = t.changedTouches.length; r < n; r++) {
                        const n = t.changedTouches[r];
                        void 0 === n.button && (n.button = 0),
                        void 0 === n.buttons && (n.buttons = 1),
                        void 0 === n.isPrimary && (n.isPrimary = 1 === t.touches.length && "touchstart" === t.type),
                        void 0 === n.width && (n.width = n.radiusX || 1),
                        void 0 === n.height && (n.height = n.radiusY || 1),
                        void 0 === n.tiltX && (n.tiltX = 0),
                        void 0 === n.tiltY && (n.tiltY = 0),
                        void 0 === n.pointerType && (n.pointerType = "touch"),
                        void 0 === n.pointerId && (n.pointerId = n.identifier || 0),
                        void 0 === n.pressure && (n.pressure = n.force || .5),
                        void 0 === n.twist && (n.twist = 0),
                        void 0 === n.tangentialPressure && (n.tangentialPressure = 0),
                        void 0 === n.layerX && (n.layerX = n.offsetX = n.clientX),
                        void 0 === n.layerY && (n.layerY = n.offsetY = n.clientY),
                        n.isNormalized = !0,
                        n.type = t.type,
                        e.push(n)
                    }
                else if (!globalThis.MouseEvent || t instanceof MouseEvent && !(this.supportsPointerEvents && t instanceof globalThis.PointerEvent)) {
                    const r = t;
                    void 0 === r.isPrimary && (r.isPrimary = !0),
                    void 0 === r.width && (r.width = 1),
                    void 0 === r.height && (r.height = 1),
                    void 0 === r.tiltX && (r.tiltX = 0),
                    void 0 === r.tiltY && (r.tiltY = 0),
                    void 0 === r.pointerType && (r.pointerType = "mouse"),
                    void 0 === r.pointerId && (r.pointerId = 1),
                    void 0 === r.pressure && (r.pressure = .5),
                    void 0 === r.twist && (r.twist = 0),
                    void 0 === r.tangentialPressure && (r.tangentialPressure = 0),
                    r.isNormalized = !0,
                    e.push(r)
                } else
                    e.push(t);
                return e
            }
            normalizeWheelEvent(t) {
                const e = this.rootWheelEvent;
                return this.transferMouseData(e, t),
                e.deltaX = t.deltaX,
                e.deltaY = t.deltaY,
                e.deltaZ = t.deltaZ,
                e.deltaMode = t.deltaMode,
                this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
                e.global.copyFrom(e.screen),
                e.offset.copyFrom(e.screen),
                e.nativeEvent = t,
                e.type = t.type,
                e
            }
            bootstrapEvent(t, e) {
                return t.originalEvent = null,
                t.nativeEvent = e,
                t.pointerId = e.pointerId,
                t.width = e.width,
                t.height = e.height,
                t.isPrimary = e.isPrimary,
                t.pointerType = e.pointerType,
                t.pressure = e.pressure,
                t.tangentialPressure = e.tangentialPressure,
                t.tiltX = e.tiltX,
                t.tiltY = e.tiltY,
                t.twist = e.twist,
                this.transferMouseData(t, e),
                this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
                t.global.copyFrom(t.screen),
                t.offset.copyFrom(t.screen),
                t.isTrusted = e.isTrusted,
                "pointerleave" === t.type && (t.type = "pointerout"),
                t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")),
                t.type.startsWith("touch") && (t.type = S[t.type] || t.type),
                t
            }
            transferMouseData(t, e) {
                t.isTrusted = e.isTrusted,
                t.srcElement = e.srcElement,
                t.timeStamp = performance.now(),
                t.type = e.type,
                t.altKey = e.altKey,
                t.button = e.button,
                t.buttons = e.buttons,
                t.client.x = e.clientX,
                t.client.y = e.clientY,
                t.ctrlKey = e.ctrlKey,
                t.metaKey = e.metaKey,
                t.movement.x = e.movementX,
                t.movement.y = e.movementY,
                t.page.x = e.pageX,
                t.page.y = e.pageY,
                t.relatedTarget = null,
                t.shiftKey = e.shiftKey
            }
        }
        ;
        let C = A;
        function R(t) {
            return "dynamic" === t || "static" === t
        }
        C.extension = {
            name: "events",
            type: [n.nw.RendererSystem, n.nw.CanvasRendererSystem]
        },
        C.defaultEventFeatures = {
            move: !0,
            globalMove: !0,
            click: !0,
            wheel: !0
        },
        n.Rw.add(C);
        const P = {
            onclick: null,
            onmousedown: null,
            onmouseenter: null,
            onmouseleave: null,
            onmousemove: null,
            onglobalmousemove: null,
            onmouseout: null,
            onmouseover: null,
            onmouseup: null,
            onmouseupoutside: null,
            onpointercancel: null,
            onpointerdown: null,
            onpointerenter: null,
            onpointerleave: null,
            onpointermove: null,
            onglobalpointermove: null,
            onpointerout: null,
            onpointerover: null,
            onpointertap: null,
            onpointerup: null,
            onpointerupoutside: null,
            onrightclick: null,
            onrightdown: null,
            onrightup: null,
            onrightupoutside: null,
            ontap: null,
            ontouchcancel: null,
            ontouchend: null,
            ontouchendoutside: null,
            ontouchmove: null,
            onglobaltouchmove: null,
            ontouchstart: null,
            onwheel: null,
            _internalInteractive: void 0,
            get interactive() {
                return this._internalInteractive ?? R(C.defaultEventMode)
            },
            set interactive(t) {
                n.P6.deprecation("7.2.0", "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."),
                this._internalInteractive = t,
                this.eventMode = t ? "static" : "auto"
            },
            _internalEventMode: void 0,
            get eventMode() {
                return this._internalEventMode ?? C.defaultEventMode
            },
            set eventMode(t) {
                this._internalInteractive = R(t),
                this._internalEventMode = t
            },
            isInteractive() {
                return "static" === this.eventMode || "dynamic" === this.eventMode
            },
            interactiveChildren: !0,
            hitArea: null,
            addEventListener(t, e, r) {
                const n = "function" == typeof e ? void 0 : e;
                t = "boolean" == typeof r && r || "object" == typeof r && r.capture ? `${t}capture` : t,
                e = "function" == typeof e ? e : e.handleEvent,
                this.on(t, e, n)
            },
            removeEventListener(t, e, r) {
                const n = "function" == typeof e ? void 0 : e;
                t = "boolean" == typeof r && r || "object" == typeof r && r.capture ? `${t}capture` : t,
                e = "function" == typeof e ? e : e.handleEvent,
                this.off(t, e, n)
            },
            dispatchEvent(t) {
                if (!(t instanceof y))
                    throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
                return t.defaultPrevented = !1,
                t.path = null,
                t.target = this,
                t.manager.dispatchEvent(t),
                !t.defaultPrevented
            }
        };
        i.s$.mixin(P),
        i.s$.mixin({
            accessible: !1,
            accessibleTitle: null,
            accessibleHint: null,
            tabIndex: 0,
            _accessibleActive: !1,
            _accessibleDiv: null,
            accessibleType: "button",
            accessiblePointerEvents: "auto",
            accessibleChildren: !0,
            renderId: -1
        });
        class I {
            constructor(t) {
                this.debug = !1,
                this._isActive = !1,
                this._isMobileAccessibility = !1,
                this.pool = [],
                this.renderId = 0,
                this.children = [],
                this.androidUpdateCount = 0,
                this.androidUpdateFrequency = 500,
                this._hookDiv = null,
                (n.P6.isMobile.tablet || n.P6.isMobile.phone) && this.createTouchHook();
                const e = document.createElement("div");
                e.style.width = "100px",
                e.style.height = "100px",
                e.style.position = "absolute",
                e.style.top = "0px",
                e.style.left = "0px",
                e.style.zIndex = 2..toString(),
                this.div = e,
                this.renderer = t,
                this._onKeyDown = this._onKeyDown.bind(this),
                this._onMouseMove = this._onMouseMove.bind(this),
                globalThis.addEventListener("keydown", this._onKeyDown, !1)
            }
            get isActive() {
                return this._isActive
            }
            get isMobileAccessibility() {
                return this._isMobileAccessibility
            }
            createTouchHook() {
                const t = document.createElement("button");
                t.style.width = "1px",
                t.style.height = "1px",
                t.style.position = "absolute",
                t.style.top = "-1000px",
                t.style.left = "-1000px",
                t.style.zIndex = 2..toString(),
                t.style.backgroundColor = "#FF0000",
                t.title = "select to enable accessibility for this content",
                t.addEventListener("focus", ( () => {
                    this._isMobileAccessibility = !0,
                    this.activate(),
                    this.destroyTouchHook()
                }
                )),
                document.body.appendChild(t),
                this._hookDiv = t
            }
            destroyTouchHook() {
                this._hookDiv && (document.body.removeChild(this._hookDiv),
                this._hookDiv = null)
            }
            activate() {
                this._isActive || (this._isActive = !0,
                globalThis.document.addEventListener("mousemove", this._onMouseMove, !0),
                globalThis.removeEventListener("keydown", this._onKeyDown, !1),
                this.renderer.on("postrender", this.update, this),
                this.renderer.view.parentNode?.appendChild(this.div))
            }
            deactivate() {
                this._isActive && !this._isMobileAccessibility && (this._isActive = !1,
                globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
                globalThis.addEventListener("keydown", this._onKeyDown, !1),
                this.renderer.off("postrender", this.update),
                this.div.parentNode?.removeChild(this.div))
            }
            updateAccessibleObjects(t) {
                if (!t.visible || !t.accessibleChildren)
                    return;
                t.accessible && t.isInteractive() && (t._accessibleActive || this.addChild(t),
                t.renderId = this.renderId);
                const e = t.children;
                if (e)
                    for (let t = 0; t < e.length; t++)
                        this.updateAccessibleObjects(e[t])
            }
            update() {
                const t = performance.now();
                if (n.P6.isMobile.android.device && t < this.androidUpdateCount)
                    return;
                if (this.androidUpdateCount = t + this.androidUpdateFrequency,
                !this.renderer.renderingToScreen)
                    return;
                this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
                const {x: e, y: r, width: i, height: s} = this.renderer.view.getBoundingClientRect()
                  , {width: o, height: a, resolution: h} = this.renderer
                  , l = i / o * h
                  , u = s / a * h;
                let c = this.div;
                c.style.left = `${e}px`,
                c.style.top = `${r}px`,
                c.style.width = `${o}px`,
                c.style.height = `${a}px`;
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    if (e.renderId !== this.renderId)
                        e._accessibleActive = !1,
                        n.P6.removeItems(this.children, t, 1),
                        this.div.removeChild(e._accessibleDiv),
                        this.pool.push(e._accessibleDiv),
                        e._accessibleDiv = null,
                        t--;
                    else {
                        c = e._accessibleDiv;
                        let t = e.hitArea;
                        const r = e.worldTransform;
                        e.hitArea ? (c.style.left = (r.tx + t.x * r.a) * l + "px",
                        c.style.top = (r.ty + t.y * r.d) * u + "px",
                        c.style.width = t.width * r.a * l + "px",
                        c.style.height = t.height * r.d * u + "px") : (t = e.getBounds(),
                        this.capHitArea(t),
                        c.style.left = t.x * l + "px",
                        c.style.top = t.y * u + "px",
                        c.style.width = t.width * l + "px",
                        c.style.height = t.height * u + "px",
                        c.title !== e.accessibleTitle && null !== e.accessibleTitle && (c.title = e.accessibleTitle),
                        c.getAttribute("aria-label") !== e.accessibleHint && null !== e.accessibleHint && c.setAttribute("aria-label", e.accessibleHint)),
                        e.accessibleTitle === c.title && e.tabIndex === c.tabIndex || (c.title = e.accessibleTitle,
                        c.tabIndex = e.tabIndex,
                        this.debug && this.updateDebugHTML(c))
                    }
                }
                this.renderId++
            }
            updateDebugHTML(t) {
                t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
            }
            capHitArea(t) {
                t.x < 0 && (t.width += t.x,
                t.x = 0),
                t.y < 0 && (t.height += t.y,
                t.y = 0);
                const {width: e, height: r} = this.renderer;
                t.x + t.width > e && (t.width = e - t.x),
                t.y + t.height > r && (t.height = r - t.y)
            }
            addChild(t) {
                let e = this.pool.pop();
                e || (e = document.createElement("button"),
                e.style.width = "100px",
                e.style.height = "100px",
                e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent",
                e.style.position = "absolute",
                e.style.zIndex = 2..toString(),
                e.style.borderStyle = "none",
                navigator.userAgent.toLowerCase().includes("chrome") ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"),
                navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"),
                e.addEventListener("click", this._onClick.bind(this)),
                e.addEventListener("focus", this._onFocus.bind(this)),
                e.addEventListener("focusout", this._onFocusOut.bind(this))),
                e.style.pointerEvents = t.accessiblePointerEvents,
                e.type = t.accessibleType,
                t.accessibleTitle && null !== t.accessibleTitle ? e.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (e.title = `displayObject ${t.tabIndex}`),
                t.accessibleHint && null !== t.accessibleHint && e.setAttribute("aria-label", t.accessibleHint),
                this.debug && this.updateDebugHTML(e),
                t._accessibleActive = !0,
                t._accessibleDiv = e,
                e.displayObject = t,
                this.children.push(t),
                this.div.appendChild(t._accessibleDiv),
                t._accessibleDiv.tabIndex = t.tabIndex
            }
            _dispatchEvent(t, e) {
                const {displayObject: r} = t.target
                  , n = this.renderer.events.rootBoundary
                  , i = Object.assign(new y(n), {
                    target: r
                });
                n.rootTarget = this.renderer.lastObjectRendered,
                e.forEach((t => n.dispatchEvent(i, t)))
            }
            _onClick(t) {
                this._dispatchEvent(t, ["click", "pointertap", "tap"])
            }
            _onFocus(t) {
                t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"),
                this._dispatchEvent(t, ["mouseover"])
            }
            _onFocusOut(t) {
                t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"),
                this._dispatchEvent(t, ["mouseout"])
            }
            _onKeyDown(t) {
                9 === t.keyCode && this.activate()
            }
            _onMouseMove(t) {
                0 === t.movementX && 0 === t.movementY || this.deactivate()
            }
            destroy() {
                this.destroyTouchHook(),
                this.div = null,
                globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
                globalThis.removeEventListener("keydown", this._onKeyDown),
                this.pool = null,
                this.children = null,
                this.renderer = null
            }
        }
        I.extension = {
            name: "accessibility",
            type: [n.nw.RendererPlugin, n.nw.CanvasRendererPlugin]
        },
        n.Rw.add(I);
        const M = class {
            constructor(t) {
                this.stage = new i.W2,
                t = Object.assign({
                    forceCanvas: !1
                }, t),
                this.renderer = (0,
                n.e6)(t),
                M._plugins.forEach((e => {
                    e.init.call(this, t)
                }
                ))
            }
            render() {
                this.renderer.render(this.stage)
            }
            get view() {
                return this.renderer.view
            }
            get screen() {
                return this.renderer.screen
            }
            destroy(t, e) {
                const r = M._plugins.slice(0);
                r.reverse(),
                r.forEach((t => {
                    t.destroy.call(this)
                }
                )),
                this.stage.destroy(e),
                this.stage = null,
                this.renderer.destroy(t),
                this.renderer = null
            }
        }
        ;
        let D = M;
        D._plugins = [],
        n.Rw.handleByList(n.nw.Application, D._plugins);
        class O {
            static init(t) {
                Object.defineProperty(this, "resizeTo", {
                    set(t) {
                        globalThis.removeEventListener("resize", this.queueResize),
                        this._resizeTo = t,
                        t && (globalThis.addEventListener("resize", this.queueResize),
                        this.resize())
                    },
                    get() {
                        return this._resizeTo
                    }
                }),
                this.queueResize = () => {
                    this._resizeTo && (this.cancelResize(),
                    this._resizeId = requestAnimationFrame(( () => this.resize())))
                }
                ,
                this.cancelResize = () => {
                    this._resizeId && (cancelAnimationFrame(this._resizeId),
                    this._resizeId = null)
                }
                ,
                this.resize = () => {
                    if (!this._resizeTo)
                        return;
                    let t, e;
                    if (this.cancelResize(),
                    this._resizeTo === globalThis.window)
                        t = globalThis.innerWidth,
                        e = globalThis.innerHeight;
                    else {
                        const {clientWidth: r, clientHeight: n} = this._resizeTo;
                        t = r,
                        e = n
                    }
                    this.renderer.resize(t, e),
                    this.render()
                }
                ,
                this._resizeId = null,
                this._resizeTo = null,
                this.resizeTo = t.resizeTo || null
            }
            static destroy() {
                globalThis.removeEventListener("resize", this.queueResize),
                this.cancelResize(),
                this.cancelResize = null,
                this.queueResize = null,
                this.resizeTo = null,
                this.resize = null
            }
        }
        O.extension = n.nw.Application,
        n.Rw.add(O);
        const B = {
            loader: n.nw.LoadParser,
            resolver: n.nw.ResolveParser,
            cache: n.nw.CacheParser,
            detection: n.nw.DetectionParser
        };
        n.Rw.handle(n.nw.Asset, (t => {
            const e = t.ref;
            Object.entries(B).filter(( ([t]) => !!e[t])).forEach(( ([t,r]) => n.Rw.add(Object.assign(e[t], {
                extension: e[t].extension ?? r
            }))))
        }
        ), (t => {
            const e = t.ref;
            Object.keys(B).filter((t => !!e[t])).forEach((t => n.Rw.remove(e[t])))
        }
        ));
        class k {
            constructor(t, e=!1) {
                this._loader = t,
                this._assetList = [],
                this._isLoading = !1,
                this._maxConcurrent = 1,
                this.verbose = e
            }
            add(t) {
                t.forEach((t => {
                    this._assetList.push(t)
                }
                )),
                this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList),
                this._isActive && !this._isLoading && this._next()
            }
            async _next() {
                if (this._assetList.length && this._isActive) {
                    this._isLoading = !0;
                    const t = []
                      , e = Math.min(this._assetList.length, this._maxConcurrent);
                    for (let r = 0; r < e; r++)
                        t.push(this._assetList.pop());
                    await this._loader.load(t),
                    this._isLoading = !1,
                    this._next()
                }
            }
            get active() {
                return this._isActive
            }
            set active(t) {
                this._isActive !== t && (this._isActive = t,
                t && !this._isLoading && this._next())
            }
        }
        function L(t, e) {
            const r = t.split("?")[0]
              , i = n.P6.path.extname(r).toLowerCase();
            return Array.isArray(e) ? e.includes(i) : i === e
        }
        const N = (t, e) => (Array.isArray(t) || (t = [t]),
        e ? t.map((t => "string" == typeof t ? e(t) : t)) : t)
          , F = new class {
            constructor() {
                this._parsers = [],
                this._cache = new Map,
                this._cacheMap = new Map
            }
            reset() {
                this._cacheMap.clear(),
                this._cache.clear()
            }
            has(t) {
                return this._cache.has(t)
            }
            get(t) {
                const e = this._cache.get(t);
                return e || console.warn(`[Assets] Asset id ${t} was not found in the Cache`),
                e
            }
            set(t, e) {
                const r = N(t);
                let i;
                for (let t = 0; t < this.parsers.length; t++) {
                    const n = this.parsers[t];
                    if (n.test(e)) {
                        i = n.getCacheableAssets(r, e);
                        break
                    }
                }
                i || (i = {},
                r.forEach((t => {
                    i[t] = e
                }
                )));
                const s = Object.keys(i)
                  , o = {
                    cacheKeys: s,
                    keys: r
                };
                if (r.forEach((t => {
                    this._cacheMap.set(t, o)
                }
                )),
                s.forEach((t => {
                    this._cache.has(t) && this._cache.get(t) !== e && console.warn("[Cache] already has key:", t),
                    this._cache.set(t, i[t])
                }
                )),
                e instanceof n.xE) {
                    const t = e;
                    r.forEach((e => {
                        t.baseTexture !== n.xE.EMPTY.baseTexture && n.VL.addToCache(t.baseTexture, e),
                        n.xE.addToCache(t, e)
                    }
                    ))
                }
            }
            remove(t) {
                if (this._cacheMap.get(t),
                !this._cacheMap.has(t))
                    return void console.warn(`[Assets] Asset id ${t} was not found in the Cache`);
                const e = this._cacheMap.get(t);
                e.cacheKeys.forEach((t => {
                    this._cache.delete(t)
                }
                )),
                e.keys.forEach((t => {
                    this._cacheMap.delete(t)
                }
                ))
            }
            get parsers() {
                return this._parsers
            }
        }
          , U = t => !Array.isArray(t);
        class G {
            constructor() {
                this._parsers = [],
                this._parsersValidated = !1,
                this.parsers = new Proxy(this._parsers,{
                    set: (t, e, r) => (this._parsersValidated = !1,
                    t[e] = r,
                    !0)
                }),
                this.promiseCache = {}
            }
            reset() {
                this._parsersValidated = !1,
                this.promiseCache = {}
            }
            _getLoadPromiseAndParser(t, e) {
                const r = {
                    promise: null,
                    parser: null
                };
                return r.promise = (async () => {
                    let n = null
                      , i = null;
                    if (e.loadParser && (i = this._parserHash[e.loadParser],
                    i || console.warn(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)),
                    !i) {
                        for (let r = 0; r < this.parsers.length; r++) {
                            const n = this.parsers[r];
                            if (n.load && n.test?.(t, e, this)) {
                                i = n;
                                break
                            }
                        }
                        if (!i)
                            return console.warn(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),
                            null
                    }
                    n = await i.load(t, e, this),
                    r.parser = i;
                    for (let t = 0; t < this.parsers.length; t++) {
                        const i = this.parsers[t];
                        i.parse && i.parse && await (i.testParse?.(n, e, this)) && (n = await i.parse(n, e, this) || n,
                        r.parser = i)
                    }
                    return n
                }
                )(),
                r
            }
            async load(t, e) {
                this._parsersValidated || this._validateParsers();
                let r = 0;
                const i = {}
                  , s = U(t)
                  , o = N(t, (t => ({
                    src: t
                })))
                  , a = o.length
                  , h = o.map((async t => {
                    const s = n.P6.path.toAbsolute(t.src);
                    if (!i[t.src])
                        try {
                            this.promiseCache[s] || (this.promiseCache[s] = this._getLoadPromiseAndParser(s, t)),
                            i[t.src] = await this.promiseCache[s].promise,
                            e && e(++r / a)
                        } catch (e) {
                            throw delete this.promiseCache[s],
                            delete i[t.src],
                            new Error(`[Loader.load] Failed to load ${s}.\n${e}`)
                        }
                }
                ));
                return await Promise.all(h),
                s ? i[o[0].src] : i
            }
            async unload(t) {
                const e = N(t, (t => ({
                    src: t
                }))).map((async t => {
                    const e = n.P6.path.toAbsolute(t.src)
                      , r = this.promiseCache[e];
                    if (r) {
                        const n = await r.promise;
                        r.parser?.unload?.(n, t, this),
                        delete this.promiseCache[e]
                    }
                }
                ));
                await Promise.all(e)
            }
            _validateParsers() {
                this._parsersValidated = !0,
                this._parserHash = this._parsers.filter((t => t.name)).reduce(( (t, e) => (t[e.name] && console.warn(`[Assets] loadParser name conflict "${e.name}"`),
                {
                    ...t,
                    [e.name]: e
                })), {})
            }
        }
        var j = (t => (t[t.Low = 0] = "Low",
        t[t.Normal = 1] = "Normal",
        t[t.High = 2] = "High",
        t))(j || {});
        function z(t, e) {
            if (Array.isArray(e)) {
                for (const r of e)
                    if (t.startsWith(`data:${r}`))
                        return !0;
                return !1
            }
            return t.startsWith(`data:${e}`)
        }
        const H = {
            extension: {
                type: n.nw.LoadParser,
                priority: j.Low
            },
            name: "loadJson",
            test(t) {
                return z(t, "application/json") || L(t, ".json")
            },
            async load(t) {
                const e = await n.Xd.ADAPTER.fetch(t);
                return await e.json()
            }
        };
        n.Rw.add(H);
        const $ = {
            name: "loadTxt",
            extension: {
                type: n.nw.LoadParser,
                priority: j.Low
            },
            test(t) {
                return z(t, "text/plain") || L(t, ".txt")
            },
            async load(t) {
                const e = await n.Xd.ADAPTER.fetch(t);
                return await e.text()
            }
        };
        n.Rw.add($);
        const X = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
          , V = [".ttf", ".otf", ".woff", ".woff2"]
          , W = ["font/ttf", "font/otf", "font/woff", "font/woff2"]
          , Y = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i
          , q = {
            extension: {
                type: n.nw.LoadParser,
                priority: j.Low
            },
            name: "loadWebFont",
            test(t) {
                return z(t, W) || L(t, V)
            },
            async load(t, e) {
                const r = n.Xd.ADAPTER.getFontFaceSet();
                if (r) {
                    const i = []
                      , s = e.data?.family ?? function(t) {
                        const e = n.P6.path.extname(t)
                          , r = n.P6.path.basename(t, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((t => t.charAt(0).toUpperCase() + t.slice(1)));
                        let i = r.length > 0;
                        for (const t of r)
                            if (!t.match(Y)) {
                                i = !1;
                                break
                            }
                        let s = r.join(" ");
                        return i || (s = `"${s.replace(/[\\"]/g, "\\$&")}"`),
                        s
                    }(t)
                      , o = e.data?.weights?.filter((t => X.includes(t))) ?? ["normal"]
                      , a = e.data ?? {};
                    for (let e = 0; e < o.length; e++) {
                        const n = o[e]
                          , h = new FontFace(s,`url(${encodeURI(t)})`,{
                            ...a,
                            weight: n
                        });
                        await h.load(),
                        r.add(h),
                        i.push(h)
                    }
                    return 1 === i.length ? i[0] : i
                }
                return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),
                null
            },
            unload(t) {
                (Array.isArray(t) ? t : [t]).forEach((t => n.Xd.ADAPTER.getFontFaceSet().delete(t)))
            }
        };
        n.Rw.add(q);
        let K, Z = 0;
        const J = "\n    async function checkImageBitmap()\n    {\n        try\n        {\n            if (typeof createImageBitmap !== 'function') return false;\n\n            const response = await fetch('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=');\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n\n            return imageBitmap.width === 1 && imageBitmap.height === 1;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    }\n    checkImageBitmap().then((result) => { self.postMessage(result); });\n    "
          , Q = "\n    async function loadImageBitmap(url)\n    {\n        const response = await fetch(url);\n\n        if (!response.ok)\n        {\n            throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: `\n                + `${response.status} ${response.statusText}`);\n        }\n\n        const imageBlob =  await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n\n        return imageBitmap;\n    }\n    self.onmessage = async (event) =>\n    {\n        try\n        {\n            const imageBitmap = await loadImageBitmap(event.data.data[0]);\n\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }\n        catch(e)\n        {\n            self.postMessage({\n                error: e,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        }\n    };";
        let tt;
        const et = new class {
            constructor() {
                this._initialized = !1,
                this._createdWorkers = 0,
                this.workerPool = [],
                this.queue = [],
                this.resolveHash = {}
            }
            isImageBitmapSupported() {
                return void 0 !== this._isImageBitmapSupported || (this._isImageBitmapSupported = new Promise((t => {
                    const e = URL.createObjectURL(new Blob([J],{
                        type: "application/javascript"
                    }))
                      , r = new Worker(e);
                    r.addEventListener("message", (n => {
                        r.terminate(),
                        URL.revokeObjectURL(e),
                        t(n.data)
                    }
                    ))
                }
                ))),
                this._isImageBitmapSupported
            }
            loadImageBitmap(t) {
                return this._run("loadImageBitmap", [t])
            }
            async _initWorkers() {
                this._initialized || (this._initialized = !0)
            }
            getWorker() {
                void 0 === K && (K = navigator.hardwareConcurrency || 4);
                let t = this.workerPool.pop();
                return !t && this._createdWorkers < K && (tt || (tt = URL.createObjectURL(new Blob([Q],{
                    type: "application/javascript"
                }))),
                this._createdWorkers++,
                t = new Worker(tt),
                t.addEventListener("message", (t => {
                    this.complete(t.data),
                    this.returnWorker(t.target),
                    this.next()
                }
                ))),
                t
            }
            returnWorker(t) {
                this.workerPool.push(t)
            }
            complete(t) {
                void 0 !== t.error ? this.resolveHash[t.uuid].reject(t.error) : this.resolveHash[t.uuid].resolve(t.data),
                this.resolveHash[t.uuid] = null
            }
            async _run(t, e) {
                await this._initWorkers();
                const r = new Promise(( (r, n) => {
                    this.queue.push({
                        id: t,
                        arguments: e,
                        resolve: r,
                        reject: n
                    })
                }
                ));
                return this.next(),
                r
            }
            next() {
                if (!this.queue.length)
                    return;
                const t = this.getWorker();
                if (!t)
                    return;
                const e = this.queue.pop()
                  , r = e.id;
                this.resolveHash[Z] = {
                    resolve: e.resolve,
                    reject: e.reject
                },
                t.postMessage({
                    data: e.arguments,
                    uuid: Z++,
                    id: r
                })
            }
        }
        ;
        function rt(t, e, r) {
            const i = new n.xE(t);
            return i.baseTexture.on("dispose", ( () => {
                delete e.promiseCache[r]
            }
            )),
            i
        }
        const nt = [".jpeg", ".jpg", ".png", ".webp", ".avif"]
          , it = ["image/jpeg", "image/png", "image/webp", "image/avif"]
          , st = {
            name: "loadTextures",
            extension: {
                type: n.nw.LoadParser,
                priority: j.High
            },
            config: {
                preferWorkers: !0,
                preferCreateImageBitmap: !0,
                crossOrigin: "anonymous"
            },
            test(t) {
                return z(t, it) || L(t, nt)
            },
            async load(t, e, r) {
                let i = null;
                i = globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await et.isImageBitmapSupported() ? await et.loadImageBitmap(t) : await async function(t) {
                    const e = await n.Xd.ADAPTER.fetch(t);
                    if (!e.ok)
                        throw new Error(`[loadImageBitmap] Failed to fetch ${t}: ${e.status} ${e.statusText}`);
                    const r = await e.blob();
                    return await createImageBitmap(r)
                }(t) : await new Promise((e => {
                    i = new Image,
                    i.crossOrigin = this.config.crossOrigin,
                    i.src = t,
                    i.complete ? e(i) : i.onload = () => {
                        e(i)
                    }
                }
                ));
                const s = new n.VL(i,{
                    resolution: n.P6.getResolutionOfUrl(t),
                    ...e.data
                });
                return s.resource.src = t,
                rt(s, r, t)
            },
            unload(t) {
                t.destroy(!0)
            }
        };
        n.Rw.add(st);
        const ot = {
            extension: {
                type: n.nw.LoadParser,
                priority: j.High
            },
            name: "loadSVG",
            test(t) {
                return z(t, "image/svg+xml") || L(t, ".svg")
            },
            async testParse(t) {
                return n.pX.test(t)
            },
            async parse(t, e, r) {
                const i = new n.pX(t,e?.data?.resourceOptions);
                await i.load();
                const s = new n.VL(i,{
                    resolution: n.P6.getResolutionOfUrl(t),
                    ...e?.data
                });
                return s.resource.src = t,
                rt(s, r, t)
            },
            async load(t, e) {
                return (await n.Xd.ADAPTER.fetch(t)).text()
            },
            unload: st.unload
        };
        function at(t, e, r, n, i) {
            const s = e[r];
            for (let o = 0; o < s.length; o++) {
                const a = s[o];
                r < e.length - 1 ? at(t.replace(n[r], a), e, r + 1, n, i) : i.push(t.replace(n[r], a))
            }
        }
        function ht(t) {
            const e = t.match(/\{(.*?)\}/g)
              , r = [];
            if (e) {
                const n = [];
                e.forEach((t => {
                    const e = t.substring(1, t.length - 1).split(",");
                    n.push(e)
                }
                )),
                at(t, n, 0, e, r)
            } else
                r.push(t);
            return r
        }
        n.Rw.add(ot);
        class lt {
            constructor() {
                this._defaultBundleIdentifierOptions = {
                    connector: "-",
                    createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
                    extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "")
                },
                this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector,
                this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId,
                this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,
                this._assetMap = {},
                this._preferredOrder = [],
                this._parsers = [],
                this._resolverHash = {},
                this._bundles = {}
            }
            setBundleIdentifier(t) {
                if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector,
                this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId,
                this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle,
                "bar" !== this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")))
                    throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
            }
            prefer(...t) {
                t.forEach((t => {
                    this._preferredOrder.push(t),
                    t.priority || (t.priority = Object.keys(t.params))
                }
                )),
                this._resolverHash = {}
            }
            set basePath(t) {
                this._basePath = t
            }
            get basePath() {
                return this._basePath
            }
            set rootPath(t) {
                this._rootPath = t
            }
            get rootPath() {
                return this._rootPath
            }
            get parsers() {
                return this._parsers
            }
            reset() {
                this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
                this._assetMap = {},
                this._preferredOrder = [],
                this._resolverHash = {},
                this._rootPath = null,
                this._basePath = null,
                this._manifest = null,
                this._bundles = {},
                this._defaultSearchParams = null
            }
            setDefaultSearchParams(t) {
                if ("string" == typeof t)
                    this._defaultSearchParams = t;
                else {
                    const e = t;
                    this._defaultSearchParams = Object.keys(e).map((t => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`)).join("&")
                }
            }
            addManifest(t) {
                this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"),
                this._manifest = t,
                t.bundles.forEach((t => {
                    this.addBundle(t.name, t.assets)
                }
                ))
            }
            addBundle(t, e) {
                const r = [];
                Array.isArray(e) ? e.forEach((e => {
                    if ("string" == typeof e.name) {
                        const n = this._createBundleAssetId(t, e.name);
                        r.push(n),
                        this.add([e.name, n], e.srcs, e.data)
                    } else {
                        const n = e.name.map((e => this._createBundleAssetId(t, e)));
                        n.forEach((t => {
                            r.push(t)
                        }
                        )),
                        this.add([...e.name, ...n], e.srcs)
                    }
                }
                )) : Object.keys(e).forEach((n => {
                    r.push(this._createBundleAssetId(t, n)),
                    this.add([n, this._createBundleAssetId(t, n)], e[n])
                }
                )),
                this._bundles[t] = r
            }
            add(t, e, r) {
                const i = N(t);
                i.forEach((t => {
                    this.hasKey(t) && console.warn(`[Resolver] already has key: ${t} overwriting`)
                }
                )),
                Array.isArray(e) || (e = "string" == typeof e ? ht(e) : [e]);
                const s = e.map((t => {
                    let e = t;
                    if ("string" == typeof t) {
                        let r = !1;
                        for (let n = 0; n < this._parsers.length; n++) {
                            const i = this._parsers[n];
                            if (i.test(t)) {
                                e = i.parse(t),
                                r = !0;
                                break
                            }
                        }
                        r || (e = {
                            src: t
                        })
                    }
                    return e.format || (e.format = e.src.split(".").pop()),
                    e.alias || (e.alias = i),
                    (this._basePath || this._rootPath) && (e.src = n.P6.path.toAbsolute(e.src, this._basePath, this._rootPath)),
                    e.src = this._appendDefaultSearchParams(e.src),
                    e.data = e.data ?? r,
                    e
                }
                ));
                i.forEach((t => {
                    this._assetMap[t] = s
                }
                ))
            }
            resolveBundle(t) {
                const e = U(t);
                t = N(t);
                const r = {};
                return t.forEach((t => {
                    const e = this._bundles[t];
                    if (e) {
                        const n = this.resolve(e)
                          , i = {};
                        for (const e in n) {
                            const r = n[e];
                            i[this._extractAssetIdFromBundle(t, e)] = r
                        }
                        r[t] = i
                    }
                }
                )),
                e ? r[t[0]] : r
            }
            resolveUrl(t) {
                const e = this.resolve(t);
                if ("string" != typeof t) {
                    const t = {};
                    for (const r in e)
                        t[r] = e[r].src;
                    return t
                }
                return e.src
            }
            resolve(t) {
                const e = U(t);
                t = N(t);
                const r = {};
                return t.forEach((t => {
                    if (!this._resolverHash[t])
                        if (this._assetMap[t]) {
                            let e = this._assetMap[t];
                            const r = this._getPreferredOrder(e)
                              , n = e[0];
                            r?.priority.forEach((t => {
                                r.params[t].forEach((r => {
                                    const n = e.filter((e => !!e[t] && e[t] === r));
                                    n.length && (e = n)
                                }
                                ))
                            }
                            )),
                            this._resolverHash[t] = e[0] ?? n
                        } else {
                            let e = t;
                            (this._basePath || this._rootPath) && (e = n.P6.path.toAbsolute(e, this._basePath, this._rootPath)),
                            e = this._appendDefaultSearchParams(e),
                            this._resolverHash[t] = {
                                src: e
                            }
                        }
                    r[t] = this._resolverHash[t]
                }
                )),
                e ? r[t[0]] : r
            }
            hasKey(t) {
                return !!this._assetMap[t]
            }
            hasBundle(t) {
                return !!this._bundles[t]
            }
            _getPreferredOrder(t) {
                for (let e = 0; e < t.length; e++) {
                    const e = t[0]
                      , r = this._preferredOrder.find((t => t.params.format.includes(e.format)));
                    if (r)
                        return r
                }
                return this._preferredOrder[0]
            }
            _appendDefaultSearchParams(t) {
                return this._defaultSearchParams ? `${t}${/\?/.test(t) ? "&" : "?"}${this._defaultSearchParams}` : t
            }
        }
        const ut = new class {
            constructor() {
                this._detections = [],
                this._initialized = !1,
                this.resolver = new lt,
                this.loader = new G,
                this.cache = F,
                this._backgroundLoader = new k(this.loader),
                this._backgroundLoader.active = !0,
                this.reset()
            }
            async init(t={}) {
                if (this._initialized)
                    return void console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
                if (this._initialized = !0,
                t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams),
                t.basePath && (this.resolver.basePath = t.basePath),
                t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier),
                t.manifest) {
                    let e = t.manifest;
                    "string" == typeof e && (e = await this.load(e)),
                    this.resolver.addManifest(e)
                }
                const e = t.texturePreference?.resolution ?? 1
                  , r = "number" == typeof e ? [e] : e;
                let n = [];
                if (t.texturePreference?.format) {
                    const e = t.texturePreference?.format;
                    n = "string" == typeof e ? [e] : e;
                    for (const t of this._detections)
                        await t.test() || (n = await t.remove(n))
                } else
                    for (const t of this._detections)
                        await t.test() && (n = await t.add(n));
                this.resolver.prefer({
                    params: {
                        format: n,
                        resolution: r
                    }
                }),
                t.preferences && this.setPreferences(t.preferences)
            }
            add(t, e, r) {
                this.resolver.add(t, e, r)
            }
            async load(t, e) {
                this._initialized || await this.init();
                const r = U(t)
                  , n = N(t).map((t => "string" != typeof t ? (this.resolver.add(t.src, t),
                t.src) : (this.resolver.hasKey(t) || this.resolver.add(t, t),
                t)))
                  , i = this.resolver.resolve(n)
                  , s = await this._mapLoadToResolve(i, e);
                return r ? s[n[0]] : s
            }
            addBundle(t, e) {
                this.resolver.addBundle(t, e)
            }
            async loadBundle(t, e) {
                this._initialized || await this.init();
                let r = !1;
                "string" == typeof t && (r = !0,
                t = [t]);
                const n = this.resolver.resolveBundle(t)
                  , i = {}
                  , s = Object.keys(n);
                let o = 0
                  , a = 0;
                const h = () => {
                    e?.(++o / a)
                }
                  , l = s.map((t => {
                    const e = n[t];
                    return a += Object.keys(e).length,
                    this._mapLoadToResolve(e, h).then((e => {
                        i[t] = e
                    }
                    ))
                }
                ));
                return await Promise.all(l),
                r ? i[t[0]] : i
            }
            async backgroundLoad(t) {
                this._initialized || await this.init(),
                "string" == typeof t && (t = [t]);
                const e = this.resolver.resolve(t);
                this._backgroundLoader.add(Object.values(e))
            }
            async backgroundLoadBundle(t) {
                this._initialized || await this.init(),
                "string" == typeof t && (t = [t]);
                const e = this.resolver.resolveBundle(t);
                Object.values(e).forEach((t => {
                    this._backgroundLoader.add(Object.values(t))
                }
                ))
            }
            reset() {
                this.resolver.reset(),
                this.loader.reset(),
                this.cache.reset(),
                this._initialized = !1
            }
            get(t) {
                if ("string" == typeof t)
                    return F.get(t);
                const e = {};
                for (let r = 0; r < t.length; r++)
                    e[r] = F.get(t[r]);
                return e
            }
            async _mapLoadToResolve(t, e) {
                const r = Object.values(t)
                  , n = Object.keys(t);
                this._backgroundLoader.active = !1;
                const i = await this.loader.load(r, e);
                this._backgroundLoader.active = !0;
                const s = {};
                return r.forEach(( (t, e) => {
                    const r = i[t.src]
                      , o = [t.src];
                    t.alias && o.push(...t.alias),
                    s[n[e]] = r,
                    F.set(o, r)
                }
                )),
                s
            }
            async unload(t) {
                this._initialized || await this.init();
                const e = N(t).map((t => "string" != typeof t ? t.src : t))
                  , r = this.resolver.resolve(e);
                await this._unloadFromResolved(r)
            }
            async unloadBundle(t) {
                this._initialized || await this.init(),
                t = N(t);
                const e = this.resolver.resolveBundle(t)
                  , r = Object.keys(e).map((t => this._unloadFromResolved(e[t])));
                await Promise.all(r)
            }
            async _unloadFromResolved(t) {
                const e = Object.values(t);
                e.forEach((t => {
                    F.remove(t.src)
                }
                )),
                await this.loader.unload(e)
            }
            get detections() {
                return this._detections
            }
            get preferWorkers() {
                return st.config.preferWorkers
            }
            set preferWorkers(t) {
                n.P6.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."),
                this.setPreferences({
                    preferWorkers: t
                })
            }
            setPreferences(t) {
                this.loader.parsers.forEach((e => {
                    e.config && Object.keys(e.config).filter((e => e in t)).forEach((r => {
                        e.config[r] = t[r]
                    }
                    ))
                }
                ))
            }
        }
        ;
        n.Rw.handleByList(n.nw.LoadParser, ut.loader.parsers).handleByList(n.nw.ResolveParser, ut.resolver.parsers).handleByList(n.nw.CacheParser, ut.cache.parsers).handleByList(n.nw.DetectionParser, ut.detections);
        const ct = {
            extension: n.nw.CacheParser,
            test: t => Array.isArray(t) && t.every((t => t instanceof n.xE)),
            getCacheableAssets: (t, e) => {
                const r = {};
                return t.forEach((t => {
                    e.forEach(( (e, n) => {
                        r[t + (0 === n ? "" : n + 1)] = e
                    }
                    ))
                }
                )),
                r
            }
        };
        n.Rw.add(ct);
        const dt = {
            extension: {
                type: n.nw.DetectionParser,
                priority: 1
            },
            test: async () => {
                if (!globalThis.createImageBitmap)
                    return !1;
                const t = await n.Xd.ADAPTER.fetch("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=").then((t => t.blob()));
                return createImageBitmap(t).then(( () => !0), ( () => !1))
            }
            ,
            add: async t => [...t, "avif"],
            remove: async t => t.filter((t => "avif" !== t))
        };
        n.Rw.add(dt);
        const ft = {
            extension: {
                type: n.nw.DetectionParser,
                priority: 0
            },
            test: async () => {
                if (!globalThis.createImageBitmap)
                    return !1;
                const t = await n.Xd.ADAPTER.fetch("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=").then((t => t.blob()));
                return createImageBitmap(t).then(( () => !0), ( () => !1))
            }
            ,
            add: async t => [...t, "webp"],
            remove: async t => t.filter((t => "webp" !== t))
        };
        n.Rw.add(ft);
        const pt = ["png", "jpg", "jpeg"]
          , mt = {
            extension: {
                type: n.nw.DetectionParser,
                priority: -1
            },
            test: () => Promise.resolve(!0),
            add: async t => [...t, ...pt],
            remove: async t => t.filter((t => !pt.includes(t)))
        };
        n.Rw.add(mt);
        const gt = {
            extension: n.nw.ResolveParser,
            test: st.test,
            parse: t => ({
                resolution: parseFloat(n.Xd.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
                format: t.split(".").pop(),
                src: t
            })
        };
        n.Rw.add(gt);
        const vt = (t, e) => {
            const r = e.split("?")[1];
            return r && (t += `?${r}`),
            t
        }
        ;
        var yt = (t => (t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT",
        t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT",
        t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT",
        t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT",
        t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",
        t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",
        t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",
        t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT",
        t[t.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC",
        t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC",
        t[t.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC",
        t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC",
        t[t.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2",
        t[t.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC",
        t[t.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2",
        t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
        t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
        t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
        t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
        t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
        t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG",
        t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",
        t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL",
        t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL",
        t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",
        t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL",
        t[t.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR",
        t))(yt || {});
        const _t = {
            33776: .5,
            33777: .5,
            33778: 1,
            33779: 1,
            35916: .5,
            35917: .5,
            35918: 1,
            35919: 1,
            37488: .5,
            37489: .5,
            37490: 1,
            37491: 1,
            37492: .5,
            37496: 1,
            37493: .5,
            37497: 1,
            37494: .5,
            37495: .5,
            35840: .5,
            35842: .5,
            35841: .25,
            35843: .25,
            36196: .5,
            35986: .5,
            35986: 1,
            34798: 1,
            37808: 1
        };
        let xt, bt;
        function Et() {
            bt = {
                s3tc: xt.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: xt.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: xt.getExtension("WEBGL_compressed_texture_etc"),
                etc1: xt.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc: xt.getExtension("WEBGL_compressed_texture_pvrtc") || xt.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: xt.getExtension("WEBGL_compressed_texture_atc"),
                astc: xt.getExtension("WEBGL_compressed_texture_astc")
            }
        }
        const Tt = {
            extension: {
                type: n.nw.DetectionParser,
                priority: 2
            },
            test: async () => {
                const t = n.Xd.ADAPTER.createCanvas().getContext("webgl");
                return t ? (xt = t,
                !0) : (console.warn("WebGL not available for compressed textures."),
                !1)
            }
            ,
            add: async t => {
                bt || Et();
                const e = [];
                for (const t in bt)
                    bt[t] && e.push(t);
                return [...e, ...t]
            }
            ,
            remove: async t => (bt || Et(),
            t.filter((t => !(t in bt))))
        };
        n.Rw.add(Tt);
        class wt extends n.qm {
            constructor(t, e={
                width: 1,
                height: 1,
                autoLoad: !0
            }) {
                let r, i;
                "string" == typeof t ? (r = t,
                i = new Uint8Array) : (r = null,
                i = t),
                super(i, e),
                this.origin = r,
                this.buffer = i ? new n.Rv(i) : null,
                this._load = null,
                this.loaded = !1,
                null !== this.origin && !1 !== e.autoLoad && this.load(),
                null === this.origin && this.buffer && (this._load = Promise.resolve(this),
                this.loaded = !0,
                this.onBlobLoaded(this.buffer.rawBinaryData))
            }
            onBlobLoaded(t) {}
            load() {
                return this._load || (this._load = fetch(this.origin).then((t => t.blob())).then((t => t.arrayBuffer())).then((t => (this.data = new Uint32Array(t),
                this.buffer = new n.Rv(t),
                this.loaded = !0,
                this.onBlobLoaded(t),
                this.update(),
                this)))),
                this._load
            }
        }
        class St extends wt {
            constructor(t, e) {
                super(t, e),
                this.format = e.format,
                this.levels = e.levels || 1,
                this._width = e.width,
                this._height = e.height,
                this._extension = St._formatToExtension(this.format),
                (e.levelBuffers || this.buffer) && (this._levelBuffers = e.levelBuffers || St._createLevelBuffers(t instanceof Uint8Array ? t : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
            }
            upload(t, e, r) {
                const n = t.gl;
                if (!t.context.extensions[this._extension])
                    throw new Error(`${this._extension} textures are not supported on the current machine`);
                if (!this._levelBuffers)
                    return !1;
                for (let t = 0, e = this.levels; t < e; t++) {
                    const {levelID: e, levelWidth: r, levelHeight: i, levelBuffer: s} = this._levelBuffers[t];
                    n.compressedTexImage2D(n.TEXTURE_2D, e, this.format, r, i, 0, s)
                }
                return !0
            }
            onBlobLoaded() {
                this._levelBuffers = St._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
            }
            static _formatToExtension(t) {
                if (t >= 33776 && t <= 33779)
                    return "s3tc";
                if (t >= 37488 && t <= 37497)
                    return "etc";
                if (t >= 35840 && t <= 35843)
                    return "pvrtc";
                if (t >= 36196)
                    return "etc1";
                if (t >= 35986 && t <= 34798)
                    return "atc";
                throw new Error("Invalid (compressed) texture format given!")
            }
            static _createLevelBuffers(t, e, r, n, i, s, o) {
                const a = new Array(r);
                let h = t.byteOffset
                  , l = s
                  , u = o
                  , c = l + n - 1 & ~(n - 1)
                  , d = u + i - 1 & ~(i - 1)
                  , f = c * d * _t[e];
                for (let s = 0; s < r; s++)
                    a[s] = {
                        levelID: s,
                        levelWidth: r > 1 ? l : c,
                        levelHeight: r > 1 ? u : d,
                        levelBuffer: new Uint8Array(t.buffer,h,f)
                    },
                    h += f,
                    l = l >> 1 || 1,
                    u = u >> 1 || 1,
                    c = l + n - 1 & ~(n - 1),
                    d = u + i - 1 & ~(i - 1),
                    f = c * d * _t[e];
                return a
            }
        }
        const At = {
            827611204: yt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            861165636: yt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            894720068: yt.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
          , Ct = {
            70: yt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            71: yt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            73: yt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            74: yt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            76: yt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
            77: yt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
            72: yt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
            75: yt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
            78: yt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        }
          , Rt = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]
          , Pt = {
            [n.vK.UNSIGNED_BYTE]: 1,
            [n.vK.UNSIGNED_SHORT]: 2,
            [n.vK.INT]: 4,
            [n.vK.UNSIGNED_INT]: 4,
            [n.vK.FLOAT]: 4,
            [n.vK.HALF_FLOAT]: 8
        }
          , It = {
            [n.I2.RGBA]: 4,
            [n.I2.RGB]: 3,
            [n.I2.RG]: 2,
            [n.I2.RED]: 1,
            [n.I2.LUMINANCE]: 1,
            [n.I2.LUMINANCE_ALPHA]: 2,
            [n.I2.ALPHA]: 1
        }
          , Mt = {
            [n.vK.UNSIGNED_SHORT_4_4_4_4]: 2,
            [n.vK.UNSIGNED_SHORT_5_5_5_1]: 2,
            [n.vK.UNSIGNED_SHORT_5_6_5]: 2
        };
        function Dt(t) {
            switch (t) {
            case n.I2.RGBA:
                return n.I2.RGBA_INTEGER;
            case n.I2.RGB:
                return n.I2.RGB_INTEGER;
            case n.I2.RG:
                return n.I2.RG_INTEGER;
            case n.I2.RED:
                return n.I2.RED_INTEGER;
            default:
                return t
            }
        }
        const Ot = {
            extension: {
                type: n.nw.LoadParser,
                priority: j.High
            },
            name: "loadDDS",
            test(t) {
                return L(t, ".dds")
            },
            async load(t, e, r) {
                const i = await n.Xd.ADAPTER.fetch(t)
                  , s = function(t) {
                    const e = new Uint32Array(t);
                    if (542327876 !== e[0])
                        throw new Error("Invalid DDS file magic word");
                    const r = new Uint32Array(t,0,124 / Uint32Array.BYTES_PER_ELEMENT)
                      , n = r[3]
                      , i = r[4]
                      , s = r[7]
                      , o = new Uint32Array(t,19 * Uint32Array.BYTES_PER_ELEMENT,32 / Uint32Array.BYTES_PER_ELEMENT)
                      , a = o[1];
                    if (4 & a) {
                        const r = o[2];
                        if (808540228 !== r) {
                            const e = At[r]
                              , o = new Uint8Array(t,128);
                            return [new St(o,{
                                format: e,
                                width: i,
                                height: n,
                                levels: s
                            })]
                        }
                        const a = 128
                          , h = new Uint32Array(e.buffer,a,20 / Uint32Array.BYTES_PER_ELEMENT)
                          , l = h[0]
                          , u = h[1]
                          , c = h[2]
                          , d = h[3]
                          , f = Ct[l];
                        if (void 0 === f)
                            throw new Error(`DDSParser cannot parse texture data with DXGI format ${l}`);
                        if (4 === c)
                            throw new Error("DDSParser does not support cubemap textures");
                        if (6 === u)
                            throw new Error("DDSParser does not supported 3D texture data");
                        const p = new Array
                          , m = 148;
                        if (1 === d)
                            p.push(new Uint8Array(t,m));
                        else {
                            const e = _t[f];
                            let r = 0
                              , o = i
                              , a = n;
                            for (let t = 0; t < s; t++)
                                r += Math.max(1, o + 3 & -4) * Math.max(1, a + 3 & -4) * e,
                                o >>>= 1,
                                a >>>= 1;
                            let h = m;
                            for (let e = 0; e < d; e++)
                                p.push(new Uint8Array(t,h,r)),
                                h += r
                        }
                        return p.map((t => new St(t,{
                            format: f,
                            width: i,
                            height: n,
                            levels: s
                        })))
                    }
                    if (64 & a)
                        throw new Error("DDSParser does not support uncompressed texture data.");
                    if (512 & a)
                        throw new Error("DDSParser does not supported YUV uncompressed texture data.");
                    if (131072 & a)
                        throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
                    if (2 & a)
                        throw new Error("DDSParser does not support single-channel (alpha) texture data!");
                    throw new Error("DDSParser failed to load a texture file due to an unknown reason!")
                }(await i.arrayBuffer()).map((i => rt(new n.VL(i,{
                    mipmap: n.KI.OFF,
                    alphaMode: n.iw.NO_PREMULTIPLIED_ALPHA,
                    resolution: n.P6.getResolutionOfUrl(t),
                    ...e.data
                }), r, t)));
                return 1 === s.length ? s[0] : s
            },
            unload(t) {
                Array.isArray(t) ? t.forEach((t => t.destroy(!0))) : t.destroy(!0)
            }
        };
        n.Rw.add(Ot);
        const Bt = {
            extension: {
                type: n.nw.LoadParser,
                priority: j.High
            },
            name: "loadKTX",
            test(t) {
                return L(t, ".ktx")
            },
            async load(t, e, r) {
                const i = await n.Xd.ADAPTER.fetch(t)
                  , s = await i.arrayBuffer()
                  , {compressed: o, uncompressed: a, kvData: h} = function(t, e, r=!1) {
                    const i = new DataView(e);
                    if (!function(t, e) {
                        for (let r = 0; r < Rt.length; r++)
                            if (e.getUint8(r) !== Rt[r])
                                return console.error(`${t} is not a valid *.ktx file!`),
                                !1;
                        return !0
                    }(t, i))
                        return null;
                    const s = 67305985 === i.getUint32(12, !0)
                      , o = i.getUint32(16, s)
                      , a = i.getUint32(24, s)
                      , h = i.getUint32(28, s)
                      , l = i.getUint32(36, s)
                      , u = i.getUint32(40, s) || 1
                      , c = i.getUint32(44, s) || 1
                      , d = i.getUint32(48, s) || 1
                      , f = i.getUint32(52, s)
                      , p = i.getUint32(56, s)
                      , m = i.getUint32(60, s);
                    if (0 === u || 1 !== c)
                        throw new Error("Only 2D textures are supported");
                    if (1 !== f)
                        throw new Error("CubeTextures are not supported by KTXLoader yet!");
                    if (1 !== d)
                        throw new Error("WebGL does not support array textures");
                    const g = l + 3 & -4
                      , v = u + 3 & -4
                      , y = new Array(d);
                    let _, x = l * u;
                    if (0 === o && (x = g * v),
                    _ = 0 !== o ? Pt[o] ? Pt[o] * It[a] : Mt[o] : _t[h],
                    void 0 === _)
                        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
                    const b = r ? function(t, e, r) {
                        const n = new Map;
                        let i = 0;
                        for (; i < e; ) {
                            const s = t.getUint32(64 + i, r)
                              , o = 64 + i + 4
                              , a = 3 - (s + 3) % 4;
                            if (0 === s || s > e - i) {
                                console.error("KTXLoader: keyAndValueByteSize out of bounds");
                                break
                            }
                            let h = 0;
                            for (; h < s && 0 !== t.getUint8(o + h); h++)
                                ;
                            if (-1 === h) {
                                console.error("KTXLoader: Failed to find null byte terminating kvData key");
                                break
                            }
                            const l = (new TextDecoder).decode(new Uint8Array(t.buffer,o,h))
                              , u = new DataView(t.buffer,o + h + 1,s - h - 1);
                            n.set(l, u),
                            i += 4 + s + a
                        }
                        return n
                    }(i, m, s) : null;
                    let E = x * _
                      , T = l
                      , w = u
                      , S = g
                      , A = v
                      , C = 64 + m;
                    for (let t = 0; t < p; t++) {
                        const r = i.getUint32(C, s);
                        let n = C + 4;
                        for (let r = 0; r < d; r++) {
                            let i = y[r];
                            i || (i = y[r] = new Array(p)),
                            i[t] = {
                                levelID: t,
                                levelWidth: p > 1 || 0 !== o ? T : S,
                                levelHeight: p > 1 || 0 !== o ? w : A,
                                levelBuffer: new Uint8Array(e,n,E)
                            },
                            n += E
                        }
                        C += r + 4,
                        C = C % 4 != 0 ? C + 4 - C % 4 : C,
                        T = T >> 1 || 1,
                        w = w >> 1 || 1,
                        S = T + 4 - 1 & -4,
                        A = w + 4 - 1 & -4,
                        E = S * A * _
                    }
                    return 0 !== o ? {
                        uncompressed: y.map((t => {
                            let e = t[0].levelBuffer
                              , r = !1;
                            return o === n.vK.FLOAT ? e = new Float32Array(t[0].levelBuffer.buffer,t[0].levelBuffer.byteOffset,t[0].levelBuffer.byteLength / 4) : o === n.vK.UNSIGNED_INT ? (r = !0,
                            e = new Uint32Array(t[0].levelBuffer.buffer,t[0].levelBuffer.byteOffset,t[0].levelBuffer.byteLength / 4)) : o === n.vK.INT && (r = !0,
                            e = new Int32Array(t[0].levelBuffer.buffer,t[0].levelBuffer.byteOffset,t[0].levelBuffer.byteLength / 4)),
                            {
                                resource: new n.qm(e,{
                                    width: t[0].levelWidth,
                                    height: t[0].levelHeight
                                }),
                                type: o,
                                format: r ? Dt(a) : a
                            }
                        }
                        )),
                        kvData: b
                    } : {
                        compressed: y.map((t => new St(null,{
                            format: h,
                            width: l,
                            height: u,
                            levels: p,
                            levelBuffers: t
                        }))),
                        kvData: b
                    }
                }(t, s)
                  , l = o ?? a
                  , u = {
                    mipmap: n.KI.OFF,
                    alphaMode: n.iw.NO_PREMULTIPLIED_ALPHA,
                    resolution: n.P6.getResolutionOfUrl(t),
                    ...e.data
                }
                  , c = l.map((e => {
                    l === a && Object.assign(u, {
                        type: e.type,
                        format: e.format
                    });
                    const i = new n.VL(e,u);
                    return i.ktxKeyValueData = h,
                    rt(i, r, t)
                }
                ));
                return 1 === c.length ? c[0] : c
            },
            unload(t) {
                Array.isArray(t) ? t.forEach((t => t.destroy(!0))) : t.destroy(!0)
            }
        };
        n.Rw.add(Bt);
        const kt = {
            extension: n.nw.ResolveParser,
            test: t => {
                const e = t.split("?")[0].split(".").pop();
                return ["basis", "ktx", "dds"].includes(e)
            }
            ,
            parse: t => {
                if ("ktx" === t.split("?")[0].split(".").pop()) {
                    const e = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
                    if (e.some((e => t.endsWith(e))))
                        return {
                            resolution: parseFloat(n.Xd.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
                            format: e.find((e => t.endsWith(e))),
                            src: t
                        }
                }
                return {
                    resolution: parseFloat(n.Xd.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
                    format: t.split(".").pop(),
                    src: t
                }
            }
        };
        n.Rw.add(kt);
        const Lt = new n.Ae
          , Nt = class {
            constructor(t) {
                this.renderer = t
            }
            async image(t, e, r) {
                const n = new Image;
                return n.src = await this.base64(t, e, r),
                n
            }
            async base64(t, e, r) {
                const n = this.canvas(t);
                if (void 0 !== n.toBlob)
                    return new Promise(( (t, i) => {
                        n.toBlob((e => {
                            if (!e)
                                return void i(new Error("ICanvas.toBlob failed!"));
                            const r = new FileReader;
                            r.onload = () => t(r.result),
                            r.onerror = i,
                            r.readAsDataURL(e)
                        }
                        ), e, r)
                    }
                    ));
                if (void 0 !== n.toDataURL)
                    return n.toDataURL(e, r);
                if (void 0 !== n.convertToBlob) {
                    const t = await n.convertToBlob({
                        type: e,
                        quality: r
                    });
                    return new Promise(( (e, r) => {
                        const n = new FileReader;
                        n.onload = () => e(n.result),
                        n.onerror = r,
                        n.readAsDataURL(t)
                    }
                    ))
                }
                throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
            }
            canvas(t, e) {
                const {pixels: r, width: i, height: s, flipY: o} = this._rawPixels(t, e);
                o && Nt._flipY(r, i, s),
                Nt._unpremultiplyAlpha(r);
                const a = new n.P6.CanvasRenderTarget(i,s,1)
                  , h = new ImageData(new Uint8ClampedArray(r.buffer),i,s);
                return a.context.putImageData(h, 0, 0),
                a.canvas
            }
            pixels(t, e) {
                const {pixels: r, width: n, height: i, flipY: s} = this._rawPixels(t, e);
                return s && Nt._flipY(r, n, i),
                Nt._unpremultiplyAlpha(r),
                r
            }
            _rawPixels(t, e) {
                const r = this.renderer;
                if (!r)
                    throw new Error("The Extract has already been destroyed");
                let i, s, o = !1, a = !1;
                if (t && (t instanceof n.TI ? s = t : (s = r.generateTexture(t, {
                    resolution: r.resolution,
                    multisample: r.multisample
                }),
                a = !0)),
                s) {
                    if (i = s.baseTexture.resolution,
                    e = e ?? s.frame,
                    o = !1,
                    !a) {
                        r.renderTexture.bind(s);
                        const t = s.framebuffer.glFramebuffers[r.CONTEXT_UID];
                        t.blitFramebuffer && r.framebuffer.bind(t.blitFramebuffer)
                    }
                } else
                    i = r.resolution,
                    e || ((e = Lt).width = r.width / i,
                    e.height = r.height / i),
                    o = !0,
                    r.renderTexture.bind();
                const h = Math.round(e.width * i)
                  , l = Math.round(e.height * i)
                  , u = new Uint8Array(4 * h * l)
                  , c = r.gl;
                return c.readPixels(Math.round(e.x * i), Math.round(e.y * i), h, l, c.RGBA, c.UNSIGNED_BYTE, u),
                a && s?.destroy(!0),
                {
                    pixels: u,
                    width: h,
                    height: l,
                    flipY: o
                }
            }
            destroy() {
                this.renderer = null
            }
            static _flipY(t, e, r) {
                const n = e << 2
                  , i = r >> 1
                  , s = new Uint8Array(n);
                for (let e = 0; e < i; e++) {
                    const i = e * n
                      , o = (r - e - 1) * n;
                    s.set(t.subarray(i, i + n)),
                    t.copyWithin(i, o, o + n),
                    t.set(s, o)
                }
            }
            static _unpremultiplyAlpha(t) {
                t instanceof Uint8ClampedArray && (t = new Uint8Array(t.buffer));
                const e = t.length;
                for (let r = 0; r < e; r += 4) {
                    const e = t[r + 3];
                    if (0 !== e) {
                        const n = 255.001 / e;
                        t[r] = t[r] * n + .5,
                        t[r + 1] = t[r + 1] * n + .5,
                        t[r + 2] = t[r + 2] * n + .5
                    }
                }
            }
        }
        ;
        let Ft = Nt;
        Ft.extension = {
            name: "extract",
            type: n.nw.RendererSystem
        },
        n.Rw.add(Ft);
        const Ut = {
            build(t) {
                const e = t.points;
                let r, i, s, o, a, h;
                if (t.type === n.HS.CIRC) {
                    const e = t.shape;
                    r = e.x,
                    i = e.y,
                    a = h = e.radius,
                    s = o = 0
                } else if (t.type === n.HS.ELIP) {
                    const e = t.shape;
                    r = e.x,
                    i = e.y,
                    a = e.width,
                    h = e.height,
                    s = o = 0
                } else {
                    const e = t.shape
                      , n = e.width / 2
                      , l = e.height / 2;
                    r = e.x + n,
                    i = e.y + l,
                    a = h = Math.max(0, Math.min(e.radius, Math.min(n, l))),
                    s = n - a,
                    o = l - h
                }
                if (!(a >= 0 && h >= 0 && s >= 0 && o >= 0))
                    return void (e.length = 0);
                const l = Math.ceil(2.3 * Math.sqrt(a + h))
                  , u = 8 * l + (s ? 4 : 0) + (o ? 4 : 0);
                if (e.length = u,
                0 === u)
                    return;
                if (0 === l)
                    return e.length = 8,
                    e[0] = e[6] = r + s,
                    e[1] = e[3] = i + o,
                    e[2] = e[4] = r - s,
                    void (e[5] = e[7] = i - o);
                let c = 0
                  , d = 4 * l + (s ? 2 : 0) + 2
                  , f = d
                  , p = u;
                {
                    const t = s + a
                      , n = o
                      , h = r + t
                      , l = r - t
                      , u = i + n;
                    if (e[c++] = h,
                    e[c++] = u,
                    e[--d] = u,
                    e[--d] = l,
                    o) {
                        const t = i - n;
                        e[f++] = l,
                        e[f++] = t,
                        e[--p] = t,
                        e[--p] = h
                    }
                }
                for (let t = 1; t < l; t++) {
                    const n = Math.PI / 2 * (t / l)
                      , u = s + Math.cos(n) * a
                      , m = o + Math.sin(n) * h
                      , g = r + u
                      , v = r - u
                      , y = i + m
                      , _ = i - m;
                    e[c++] = g,
                    e[c++] = y,
                    e[--d] = y,
                    e[--d] = v,
                    e[f++] = v,
                    e[f++] = _,
                    e[--p] = _,
                    e[--p] = g
                }
                {
                    const t = o + h
                      , n = r + s
                      , a = r - s
                      , l = i + t
                      , u = i - t;
                    e[c++] = n,
                    e[c++] = l,
                    e[--p] = u,
                    e[--p] = n,
                    s && (e[c++] = a,
                    e[c++] = l,
                    e[--p] = u,
                    e[--p] = a)
                }
            },
            triangulate(t, e) {
                const r = t.points
                  , i = e.points
                  , s = e.indices;
                if (0 === r.length)
                    return;
                let o = i.length / 2;
                const a = o;
                let h, l;
                if (t.type !== n.HS.RREC) {
                    const e = t.shape;
                    h = e.x,
                    l = e.y
                } else {
                    const e = t.shape;
                    h = e.x + e.width / 2,
                    l = e.y + e.height / 2
                }
                const u = t.matrix;
                i.push(t.matrix ? u.a * h + u.c * l + u.tx : h, t.matrix ? u.b * h + u.d * l + u.ty : l),
                o++,
                i.push(r[0], r[1]);
                for (let t = 2; t < r.length; t += 2)
                    i.push(r[t], r[t + 1]),
                    s.push(o++, a, o);
                s.push(a + 1, a, o)
            }
        };
        function Gt(t, e=!1) {
            const r = t.length;
            if (r < 6)
                return;
            let n = 0;
            for (let e = 0, i = t[r - 2], s = t[r - 1]; e < r; e += 2) {
                const r = t[e]
                  , o = t[e + 1];
                n += (r - i) * (o + s),
                i = r,
                s = o
            }
            if (!e && n > 0 || e && n <= 0) {
                const e = r / 2;
                for (let n = e + e % 2; n < r; n += 2) {
                    const e = r - n - 2
                      , i = r - n - 1
                      , s = n
                      , o = n + 1;
                    [t[e],t[s]] = [t[s], t[e]],
                    [t[i],t[o]] = [t[o], t[i]]
                }
            }
        }
        const jt = {
            build(t) {
                t.points = t.shape.points.slice()
            },
            triangulate(t, e) {
                let r = t.points;
                const i = t.holes
                  , s = e.points
                  , o = e.indices;
                if (r.length >= 6) {
                    Gt(r, !1);
                    const t = [];
                    for (let e = 0; e < i.length; e++) {
                        const n = i[e];
                        Gt(n.points, !0),
                        t.push(r.length / 2),
                        r = r.concat(n.points)
                    }
                    const e = n.P6.earcut(r, t, 2);
                    if (!e)
                        return;
                    const a = s.length / 2;
                    for (let t = 0; t < e.length; t += 3)
                        o.push(e[t] + a),
                        o.push(e[t + 1] + a),
                        o.push(e[t + 2] + a);
                    for (let t = 0; t < r.length; t++)
                        s.push(r[t])
                }
            }
        }
          , zt = {
            build(t) {
                const e = t.shape
                  , r = e.x
                  , n = e.y
                  , i = e.width
                  , s = e.height
                  , o = t.points;
                o.length = 0,
                i >= 0 && s >= 0 && o.push(r, n, r + i, n, r + i, n + s, r, n + s)
            },
            triangulate(t, e) {
                const r = t.points
                  , n = e.points;
                if (0 === r.length)
                    return;
                const i = n.length / 2;
                n.push(r[0], r[1], r[2], r[3], r[6], r[7], r[4], r[5]),
                e.indices.push(i, i + 1, i + 2, i + 1, i + 2, i + 3)
            }
        }
          , Ht = {
            build(t) {
                Ut.build(t)
            },
            triangulate(t, e) {
                Ut.triangulate(t, e)
            }
        };
        var $t = (t => (t.MITER = "miter",
        t.BEVEL = "bevel",
        t.ROUND = "round",
        t))($t || {})
          , Xt = (t => (t.BUTT = "butt",
        t.ROUND = "round",
        t.SQUARE = "square",
        t))(Xt || {});
        const Vt = {
            adaptive: !0,
            maxLength: 10,
            minSegments: 8,
            maxSegments: 2048,
            epsilon: 1e-4,
            _segmentsCount(t, e=20) {
                if (!this.adaptive || !t || isNaN(t))
                    return e;
                let r = Math.ceil(t / this.maxLength);
                return r < this.minSegments ? r = this.minSegments : r > this.maxSegments && (r = this.maxSegments),
                r
            }
        };
        class Wt {
            static curveTo(t, e, r, n, i, s) {
                const o = s[s.length - 2]
                  , a = s[s.length - 1] - e
                  , h = o - t
                  , l = n - e
                  , u = r - t
                  , c = Math.abs(a * u - h * l);
                if (c < 1e-8 || 0 === i)
                    return s[s.length - 2] === t && s[s.length - 1] === e || s.push(t, e),
                    null;
                const d = a * a + h * h
                  , f = l * l + u * u
                  , p = a * l + h * u
                  , m = i * Math.sqrt(d) / c
                  , g = i * Math.sqrt(f) / c
                  , v = m * p / d
                  , y = g * p / f
                  , _ = m * u + g * h
                  , x = m * l + g * a
                  , b = h * (g + v)
                  , E = a * (g + v)
                  , T = u * (m + y)
                  , w = l * (m + y);
                return {
                    cx: _ + t,
                    cy: x + e,
                    radius: i,
                    startAngle: Math.atan2(E - x, b - _),
                    endAngle: Math.atan2(w - x, T - _),
                    anticlockwise: h * l > u * a
                }
            }
            static arc(t, e, r, i, s, o, a, h, l) {
                const u = a - o
                  , c = Vt._segmentsCount(Math.abs(u) * s, 40 * Math.ceil(Math.abs(u) / n._b))
                  , d = u / (2 * c)
                  , f = 2 * d
                  , p = Math.cos(d)
                  , m = Math.sin(d)
                  , g = c - 1
                  , v = g % 1 / g;
                for (let t = 0; t <= g; ++t) {
                    const e = d + o + f * (t + v * t)
                      , n = Math.cos(e)
                      , a = -Math.sin(e);
                    l.push((p * n + m * a) * s + r, (p * -a + m * n) * s + i)
                }
            }
        }
        class Yt {
            static curveLength(t, e, r, n, i, s, o, a) {
                let h = 0
                  , l = 0
                  , u = 0
                  , c = 0
                  , d = 0
                  , f = 0
                  , p = 0
                  , m = 0
                  , g = 0
                  , v = 0
                  , y = 0
                  , _ = t
                  , x = e;
                for (let b = 1; b <= 10; ++b)
                    l = b / 10,
                    u = l * l,
                    c = u * l,
                    d = 1 - l,
                    f = d * d,
                    p = f * d,
                    m = p * t + 3 * f * l * r + 3 * d * u * i + c * o,
                    g = p * e + 3 * f * l * n + 3 * d * u * s + c * a,
                    v = _ - m,
                    y = x - g,
                    _ = m,
                    x = g,
                    h += Math.sqrt(v * v + y * y);
                return h
            }
            static curveTo(t, e, r, n, i, s, o) {
                const a = o[o.length - 2]
                  , h = o[o.length - 1];
                o.length -= 2;
                const l = Vt._segmentsCount(Yt.curveLength(a, h, t, e, r, n, i, s));
                let u = 0
                  , c = 0
                  , d = 0
                  , f = 0
                  , p = 0;
                o.push(a, h);
                for (let m = 1, g = 0; m <= l; ++m)
                    g = m / l,
                    u = 1 - g,
                    c = u * u,
                    d = c * u,
                    f = g * g,
                    p = f * g,
                    o.push(d * a + 3 * c * g * t + 3 * u * f * r + p * i, d * h + 3 * c * g * e + 3 * u * f * n + p * s)
            }
        }
        function qt(t, e, r, n, i, s, o, a) {
            let h, l;
            o ? (h = n,
            l = -r) : (h = -n,
            l = r);
            const u = t - r * i + h
              , c = e - n * i + l
              , d = t + r * s + h
              , f = e + n * s + l;
            return a.push(u, c, d, f),
            2
        }
        function Kt(t, e, r, n, i, s, o, a) {
            const h = r - t
              , l = n - e;
            let u = Math.atan2(h, l)
              , c = Math.atan2(i - t, s - e);
            a && u < c ? u += 2 * Math.PI : !a && u > c && (c += 2 * Math.PI);
            let d = u;
            const f = c - u
              , p = Math.abs(f)
              , m = Math.sqrt(h * h + l * l)
              , g = 1 + (15 * p * Math.sqrt(m) / Math.PI >> 0)
              , v = f / g;
            if (d += v,
            a) {
                o.push(t, e, r, n);
                for (let r = 1, n = d; r < g; r++,
                n += v)
                    o.push(t, e, t + Math.sin(n) * m, e + Math.cos(n) * m);
                o.push(t, e, i, s)
            } else {
                o.push(r, n, t, e);
                for (let r = 1, n = d; r < g; r++,
                n += v)
                    o.push(t + Math.sin(n) * m, e + Math.cos(n) * m, t, e);
                o.push(i, s, t, e)
            }
            return 2 * g
        }
        function Zt(t, e) {
            t.lineStyle.native ? function(t, e) {
                let r = 0;
                const i = t.shape
                  , s = t.points || i.points
                  , o = i.type !== n.HS.POLY || i.closeStroke;
                if (0 === s.length)
                    return;
                const a = e.points
                  , h = e.indices
                  , l = s.length / 2
                  , u = a.length / 2;
                let c = u;
                for (a.push(s[0], s[1]),
                r = 1; r < l; r++)
                    a.push(s[2 * r], s[2 * r + 1]),
                    h.push(c, c + 1),
                    c++;
                o && h.push(c, u)
            }(t, e) : function(t, e) {
                const r = t.shape;
                let i = t.points || r.points.slice();
                const s = e.closePointEps;
                if (0 === i.length)
                    return;
                const o = t.lineStyle
                  , a = new n.E9(i[0],i[1])
                  , h = new n.E9(i[i.length - 2],i[i.length - 1])
                  , l = r.type !== n.HS.POLY || r.closeStroke
                  , u = Math.abs(a.x - h.x) < s && Math.abs(a.y - h.y) < s;
                if (l) {
                    i = i.slice(),
                    u && (i.pop(),
                    i.pop(),
                    h.set(i[i.length - 2], i[i.length - 1]));
                    const t = .5 * (a.x + h.x)
                      , e = .5 * (h.y + a.y);
                    i.unshift(t, e),
                    i.push(t, e)
                }
                const c = e.points
                  , d = i.length / 2;
                let f = i.length;
                const p = c.length / 2
                  , m = o.width / 2
                  , g = m * m
                  , v = o.miterLimit * o.miterLimit;
                let y = i[0]
                  , _ = i[1]
                  , x = i[2]
                  , b = i[3]
                  , E = 0
                  , T = 0
                  , w = -(_ - b)
                  , S = y - x
                  , A = 0
                  , C = 0
                  , R = Math.sqrt(w * w + S * S);
                w /= R,
                S /= R,
                w *= m,
                S *= m;
                const P = o.alignment
                  , I = 2 * (1 - P)
                  , M = 2 * P;
                l || (o.cap === Xt.ROUND ? f += Kt(y - w * (I - M) * .5, _ - S * (I - M) * .5, y - w * I, _ - S * I, y + w * M, _ + S * M, c, !0) + 2 : o.cap === Xt.SQUARE && (f += qt(y, _, w, S, I, M, !0, c))),
                c.push(y - w * I, _ - S * I, y + w * M, _ + S * M);
                for (let t = 1; t < d - 1; ++t) {
                    y = i[2 * (t - 1)],
                    _ = i[2 * (t - 1) + 1],
                    x = i[2 * t],
                    b = i[2 * t + 1],
                    E = i[2 * (t + 1)],
                    T = i[2 * (t + 1) + 1],
                    w = -(_ - b),
                    S = y - x,
                    R = Math.sqrt(w * w + S * S),
                    w /= R,
                    S /= R,
                    w *= m,
                    S *= m,
                    A = -(b - T),
                    C = x - E,
                    R = Math.sqrt(A * A + C * C),
                    A /= R,
                    C /= R,
                    A *= m,
                    C *= m;
                    const e = x - y
                      , r = _ - b
                      , n = x - E
                      , s = T - b
                      , a = e * n + r * s
                      , h = r * n - s * e
                      , l = h < 0;
                    if (Math.abs(h) < .001 * Math.abs(a)) {
                        c.push(x - w * I, b - S * I, x + w * M, b + S * M),
                        a >= 0 && (o.join === $t.ROUND ? f += Kt(x, b, x - w * I, b - S * I, x - A * I, b - C * I, c, !1) + 4 : f += 2,
                        c.push(x - A * M, b - C * M, x + A * I, b + C * I));
                        continue
                    }
                    const u = (-w + y) * (-S + b) - (-w + x) * (-S + _)
                      , d = (-A + E) * (-C + b) - (-A + x) * (-C + T)
                      , p = (e * d - n * u) / h
                      , P = (s * u - r * d) / h
                      , D = (p - x) * (p - x) + (P - b) * (P - b)
                      , O = x + (p - x) * I
                      , B = b + (P - b) * I
                      , k = x - (p - x) * M
                      , L = b - (P - b) * M
                      , N = l ? I : M
                      , F = D <= Math.min(e * e + r * r, n * n + s * s) + N * N * g;
                    let U = o.join;
                    if (U === $t.MITER && D / g > v && (U = $t.BEVEL),
                    F)
                        switch (U) {
                        case $t.MITER:
                            c.push(O, B, k, L);
                            break;
                        case $t.BEVEL:
                            l ? c.push(O, B, x + w * M, b + S * M, O, B, x + A * M, b + C * M) : c.push(x - w * I, b - S * I, k, L, x - A * I, b - C * I, k, L),
                            f += 2;
                            break;
                        case $t.ROUND:
                            l ? (c.push(O, B, x + w * M, b + S * M),
                            f += Kt(x, b, x + w * M, b + S * M, x + A * M, b + C * M, c, !0) + 4,
                            c.push(O, B, x + A * M, b + C * M)) : (c.push(x - w * I, b - S * I, k, L),
                            f += Kt(x, b, x - w * I, b - S * I, x - A * I, b - C * I, c, !1) + 4,
                            c.push(x - A * I, b - C * I, k, L))
                        }
                    else {
                        switch (c.push(x - w * I, b - S * I, x + w * M, b + S * M),
                        U) {
                        case $t.MITER:
                            l ? c.push(k, L, k, L) : c.push(O, B, O, B),
                            f += 2;
                            break;
                        case $t.ROUND:
                            f += l ? Kt(x, b, x + w * M, b + S * M, x + A * M, b + C * M, c, !0) + 2 : Kt(x, b, x - w * I, b - S * I, x - A * I, b - C * I, c, !1) + 2
                        }
                        c.push(x - A * I, b - C * I, x + A * M, b + C * M),
                        f += 2
                    }
                }
                y = i[2 * (d - 2)],
                _ = i[2 * (d - 2) + 1],
                x = i[2 * (d - 1)],
                b = i[2 * (d - 1) + 1],
                w = -(_ - b),
                S = y - x,
                R = Math.sqrt(w * w + S * S),
                w /= R,
                S /= R,
                w *= m,
                S *= m,
                c.push(x - w * I, b - S * I, x + w * M, b + S * M),
                l || (o.cap === Xt.ROUND ? f += Kt(x - w * (I - M) * .5, b - S * (I - M) * .5, x - w * I, b - S * I, x + w * M, b + S * M, c, !1) + 2 : o.cap === Xt.SQUARE && (f += qt(x, b, w, S, I, M, !1, c)));
                const D = e.indices
                  , O = Vt.epsilon * Vt.epsilon;
                for (let t = p; t < f + p - 2; ++t)
                    y = c[2 * t],
                    _ = c[2 * t + 1],
                    x = c[2 * (t + 1)],
                    b = c[2 * (t + 1) + 1],
                    E = c[2 * (t + 2)],
                    T = c[2 * (t + 2) + 1],
                    Math.abs(y * (b - T) + x * (T - _) + E * (_ - b)) < O || D.push(t, t + 1, t + 2)
            }(t, e)
        }
        class Jt {
            static curveLength(t, e, r, n, i, s) {
                const o = t - 2 * r + i
                  , a = e - 2 * n + s
                  , h = 2 * r - 2 * t
                  , l = 2 * n - 2 * e
                  , u = 4 * (o * o + a * a)
                  , c = 4 * (o * h + a * l)
                  , d = h * h + l * l
                  , f = 2 * Math.sqrt(u + c + d)
                  , p = Math.sqrt(u)
                  , m = 2 * u * p
                  , g = 2 * Math.sqrt(d)
                  , v = c / p;
                return (m * f + p * c * (f - g) + (4 * d * u - c * c) * Math.log((2 * p + v + f) / (v + g))) / (4 * m)
            }
            static curveTo(t, e, r, n, i) {
                const s = i[i.length - 2]
                  , o = i[i.length - 1]
                  , a = Vt._segmentsCount(Jt.curveLength(s, o, t, e, r, n));
                let h = 0
                  , l = 0;
                for (let u = 1; u <= a; ++u) {
                    const c = u / a;
                    h = s + (t - s) * c,
                    l = o + (e - o) * c,
                    i.push(h + (t + (r - t) * c - h) * c, l + (e + (n - e) * c - l) * c)
                }
            }
        }
        const Qt = {
            [n.HS.POLY]: jt,
            [n.HS.CIRC]: Ut,
            [n.HS.ELIP]: Ut,
            [n.HS.RECT]: zt,
            [n.HS.RREC]: Ht
        }
          , te = []
          , ee = [];
        class re {
            constructor(t, e=null, r=null, n=null) {
                this.points = [],
                this.holes = [],
                this.shape = t,
                this.lineStyle = r,
                this.fillStyle = e,
                this.matrix = n,
                this.type = t.type
            }
            clone() {
                return new re(this.shape,this.fillStyle,this.lineStyle,this.matrix)
            }
            destroy() {
                this.shape = null,
                this.holes.length = 0,
                this.holes = null,
                this.points.length = 0,
                this.points = null,
                this.lineStyle = null,
                this.fillStyle = null
            }
        }
        class ne {
            constructor() {
                this.reset()
            }
            begin(t, e, r) {
                this.reset(),
                this.style = t,
                this.start = e,
                this.attribStart = r
            }
            end(t, e) {
                this.attribSize = e - this.attribStart,
                this.size = t - this.start
            }
            reset() {
                this.style = null,
                this.size = 0,
                this.start = 0,
                this.attribStart = 0,
                this.attribSize = 0
            }
        }
        const ie = new n.E9
          , se = class extends n.JZ {
            constructor() {
                super(),
                this.closePointEps = 1e-4,
                this.boundsPadding = 0,
                this.uvsFloat32 = null,
                this.indicesUint16 = null,
                this.batchable = !1,
                this.points = [],
                this.colors = [],
                this.uvs = [],
                this.indices = [],
                this.textureIds = [],
                this.graphicsData = [],
                this.drawCalls = [],
                this.batchDirty = -1,
                this.batches = [],
                this.dirty = 0,
                this.cacheDirty = -1,
                this.clearDirty = 0,
                this.shapeIndex = 0,
                this._bounds = new i.YZ,
                this.boundsDirty = -1
            }
            get bounds() {
                return this.updateBatches(),
                this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty,
                this.calculateBounds()),
                this._bounds
            }
            invalidate() {
                this.boundsDirty = -1,
                this.dirty++,
                this.batchDirty++,
                this.shapeIndex = 0,
                this.points.length = 0,
                this.colors.length = 0,
                this.uvs.length = 0,
                this.indices.length = 0,
                this.textureIds.length = 0;
                for (let t = 0; t < this.drawCalls.length; t++)
                    this.drawCalls[t].texArray.clear(),
                    ee.push(this.drawCalls[t]);
                this.drawCalls.length = 0;
                for (let t = 0; t < this.batches.length; t++) {
                    const e = this.batches[t];
                    e.reset(),
                    te.push(e)
                }
                this.batches.length = 0
            }
            clear() {
                return this.graphicsData.length > 0 && (this.invalidate(),
                this.clearDirty++,
                this.graphicsData.length = 0),
                this
            }
            drawShape(t, e=null, r=null, n=null) {
                const i = new re(t,e,r,n);
                return this.graphicsData.push(i),
                this.dirty++,
                this
            }
            drawHole(t, e=null) {
                if (!this.graphicsData.length)
                    return null;
                const r = new re(t,null,null,e)
                  , n = this.graphicsData[this.graphicsData.length - 1];
                return r.lineStyle = n.lineStyle,
                n.holes.push(r),
                this.dirty++,
                this
            }
            destroy() {
                super.destroy();
                for (let t = 0; t < this.graphicsData.length; ++t)
                    this.graphicsData[t].destroy();
                this.points.length = 0,
                this.points = null,
                this.colors.length = 0,
                this.colors = null,
                this.uvs.length = 0,
                this.uvs = null,
                this.indices.length = 0,
                this.indices = null,
                this.indexBuffer.destroy(),
                this.indexBuffer = null,
                this.graphicsData.length = 0,
                this.graphicsData = null,
                this.drawCalls.length = 0,
                this.drawCalls = null,
                this.batches.length = 0,
                this.batches = null,
                this._bounds = null
            }
            containsPoint(t) {
                const e = this.graphicsData;
                for (let r = 0; r < e.length; ++r) {
                    const n = e[r];
                    if (n.fillStyle.visible && n.shape && (n.matrix ? n.matrix.applyInverse(t, ie) : ie.copyFrom(t),
                    n.shape.contains(ie.x, ie.y))) {
                        let t = !1;
                        if (n.holes)
                            for (let e = 0; e < n.holes.length; e++)
                                if (n.holes[e].shape.contains(ie.x, ie.y)) {
                                    t = !0;
                                    break
                                }
                        if (!t)
                            return !0
                    }
                }
                return !1
            }
            updateBatches() {
                if (!this.graphicsData.length)
                    return void (this.batchable = !0);
                if (!this.validateBatching())
                    return;
                this.cacheDirty = this.dirty;
                const t = this.uvs
                  , e = this.graphicsData;
                let r = null
                  , i = null;
                this.batches.length > 0 && (r = this.batches[this.batches.length - 1],
                i = r.style);
                for (let s = this.shapeIndex; s < e.length; s++) {
                    this.shapeIndex++;
                    const o = e[s]
                      , a = o.fillStyle
                      , h = o.lineStyle;
                    Qt[o.type].build(o),
                    o.matrix && this.transformPoints(o.points, o.matrix),
                    (a.visible || h.visible) && this.processHoles(o.holes);
                    for (let e = 0; e < 2; e++) {
                        const s = 0 === e ? a : h;
                        if (!s.visible)
                            continue;
                        const l = s.texture.baseTexture
                          , u = this.indices.length
                          , c = this.points.length / 2;
                        l.wrapMode = n.Nt.REPEAT,
                        0 === e ? this.processFill(o) : this.processLine(o);
                        const d = this.points.length / 2 - c;
                        0 !== d && (r && !this._compareStyles(i, s) && (r.end(u, c),
                        r = null),
                        r || (r = te.pop() || new ne,
                        r.begin(s, u, c),
                        this.batches.push(r),
                        i = s),
                        this.addUvs(this.points, t, s.texture, c, d, s.matrix))
                    }
                }
                const s = this.indices.length
                  , o = this.points.length / 2;
                if (r && r.end(s, o),
                0 === this.batches.length)
                    return void (this.batchable = !0);
                const a = o > 65535;
                this.indicesUint16 && this.indices.length === this.indicesUint16.length && a === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = a ? new Uint32Array(this.indices) : new Uint16Array(this.indices),
                this.batchable = this.isBatchable(),
                this.batchable ? this.packBatches() : this.buildDrawCalls()
            }
            _compareStyles(t, e) {
                return !(!t || !e) && t.texture.baseTexture === e.texture.baseTexture && t.color + t.alpha === e.color + e.alpha && !!t.native == !!e.native
            }
            validateBatching() {
                if (this.dirty === this.cacheDirty || !this.graphicsData.length)
                    return !1;
                for (let t = 0, e = this.graphicsData.length; t < e; t++) {
                    const e = this.graphicsData[t]
                      , r = e.fillStyle
                      , n = e.lineStyle;
                    if (r && !r.texture.baseTexture.valid)
                        return !1;
                    if (n && !n.texture.baseTexture.valid)
                        return !1
                }
                return !0
            }
            packBatches() {
                this.batchDirty++,
                this.uvsFloat32 = new Float32Array(this.uvs);
                const t = this.batches;
                for (let e = 0, r = t.length; e < r; e++) {
                    const r = t[e];
                    for (let t = 0; t < r.size; t++) {
                        const e = r.start + t;
                        this.indicesUint16[e] = this.indicesUint16[e] - r.attribStart
                    }
                }
            }
            isBatchable() {
                if (this.points.length > 131070)
                    return !1;
                const t = this.batches;
                for (let e = 0; e < t.length; e++)
                    if (t[e].style.native)
                        return !1;
                return this.points.length < 2 * se.BATCHABLE_SIZE
            }
            buildDrawCalls() {
                let t = ++n.VL._globalBatch;
                for (let t = 0; t < this.drawCalls.length; t++)
                    this.drawCalls[t].texArray.clear(),
                    ee.push(this.drawCalls[t]);
                this.drawCalls.length = 0;
                const e = this.colors
                  , r = this.textureIds;
                let i = ee.pop();
                i || (i = new n.a$,
                i.texArray = new n.Ie),
                i.texArray.count = 0,
                i.start = 0,
                i.size = 0,
                i.type = n.lg.TRIANGLES;
                let s = 0
                  , o = null
                  , a = 0
                  , h = !1
                  , l = n.lg.TRIANGLES
                  , u = 0;
                this.drawCalls.push(i);
                for (let c = 0; c < this.batches.length; c++) {
                    const d = this.batches[c]
                      , f = 8
                      , p = d.style
                      , m = p.texture.baseTexture;
                    h !== !!p.native && (h = !!p.native,
                    l = h ? n.lg.LINES : n.lg.TRIANGLES,
                    o = null,
                    s = f,
                    t++),
                    o !== m && (o = m,
                    m._batchEnabled !== t && (s === f && (t++,
                    s = 0,
                    i.size > 0 && (i = ee.pop(),
                    i || (i = new n.a$,
                    i.texArray = new n.Ie),
                    this.drawCalls.push(i)),
                    i.start = u,
                    i.size = 0,
                    i.texArray.count = 0,
                    i.type = l),
                    m.touched = 1,
                    m._batchEnabled = t,
                    m._batchLocation = s,
                    m.wrapMode = n.Nt.REPEAT,
                    i.texArray.elements[i.texArray.count++] = m,
                    s++)),
                    i.size += d.size,
                    u += d.size,
                    a = m._batchLocation,
                    this.addColors(e, p.color, p.alpha, d.attribSize, d.attribStart),
                    this.addTextureIds(r, a, d.attribSize, d.attribStart)
                }
                n.VL._globalBatch = t,
                this.packAttributes()
            }
            packAttributes() {
                const t = this.points
                  , e = this.uvs
                  , r = this.colors
                  , n = this.textureIds
                  , i = new ArrayBuffer(3 * t.length * 4)
                  , s = new Float32Array(i)
                  , o = new Uint32Array(i);
                let a = 0;
                for (let i = 0; i < t.length / 2; i++)
                    s[a++] = t[2 * i],
                    s[a++] = t[2 * i + 1],
                    s[a++] = e[2 * i],
                    s[a++] = e[2 * i + 1],
                    o[a++] = r[i],
                    s[a++] = n[i];
                this._buffer.update(i),
                this._indexBuffer.update(this.indicesUint16)
            }
            processFill(t) {
                t.holes.length ? jt.triangulate(t, this) : Qt[t.type].triangulate(t, this)
            }
            processLine(t) {
                Zt(t, this);
                for (let e = 0; e < t.holes.length; e++)
                    Zt(t.holes[e], this)
            }
            processHoles(t) {
                for (let e = 0; e < t.length; e++) {
                    const r = t[e];
                    Qt[r.type].build(r),
                    r.matrix && this.transformPoints(r.points, r.matrix)
                }
            }
            calculateBounds() {
                const t = this._bounds;
                t.clear(),
                t.addVertexData(this.points, 0, this.points.length),
                t.pad(this.boundsPadding, this.boundsPadding)
            }
            transformPoints(t, e) {
                for (let r = 0; r < t.length / 2; r++) {
                    const n = t[2 * r]
                      , i = t[2 * r + 1];
                    t[2 * r] = e.a * n + e.c * i + e.tx,
                    t[2 * r + 1] = e.b * n + e.d * i + e.ty
                }
            }
            addColors(t, e, r, i, s=0) {
                const o = n.Il.shared.setValue(e).toLittleEndianNumber()
                  , a = n.Il.shared.setValue(o).toPremultiplied(r);
                t.length = Math.max(t.length, s + i);
                for (let e = 0; e < i; e++)
                    t[s + e] = a
            }
            addTextureIds(t, e, r, n=0) {
                t.length = Math.max(t.length, n + r);
                for (let i = 0; i < r; i++)
                    t[n + i] = e
            }
            addUvs(t, e, r, n, i, s=null) {
                let o = 0;
                const a = e.length
                  , h = r.frame;
                for (; o < i; ) {
                    let r = t[2 * (n + o)]
                      , i = t[2 * (n + o) + 1];
                    if (s) {
                        const t = s.a * r + s.c * i + s.tx;
                        i = s.b * r + s.d * i + s.ty,
                        r = t
                    }
                    o++,
                    e.push(r / h.width, i / h.height)
                }
                const l = r.baseTexture;
                (h.width < l.width || h.height < l.height) && this.adjustUvs(e, r, a, i)
            }
            adjustUvs(t, e, r, n) {
                const i = e.baseTexture
                  , s = 1e-6
                  , o = r + 2 * n
                  , a = e.frame
                  , h = a.width / i.width
                  , l = a.height / i.height;
                let u = a.x / a.width
                  , c = a.y / a.height
                  , d = Math.floor(t[r] + s)
                  , f = Math.floor(t[r + 1] + s);
                for (let e = r + 2; e < o; e += 2)
                    d = Math.min(d, Math.floor(t[e] + s)),
                    f = Math.min(f, Math.floor(t[e + 1] + s));
                u -= d,
                c -= f;
                for (let e = r; e < o; e += 2)
                    t[e] = (t[e] + u) * h,
                    t[e + 1] = (t[e + 1] + c) * l
            }
        }
        ;
        let oe = se;
        oe.BATCHABLE_SIZE = 100;
        class ae {
            constructor() {
                this.color = 16777215,
                this.alpha = 1,
                this.texture = n.xE.WHITE,
                this.matrix = null,
                this.visible = !1,
                this.reset()
            }
            clone() {
                const t = new ae;
                return t.color = this.color,
                t.alpha = this.alpha,
                t.texture = this.texture,
                t.matrix = this.matrix,
                t.visible = this.visible,
                t
            }
            reset() {
                this.color = 16777215,
                this.alpha = 1,
                this.texture = n.xE.WHITE,
                this.matrix = null,
                this.visible = !1
            }
            destroy() {
                this.texture = null,
                this.matrix = null
            }
        }
        class he extends ae {
            constructor() {
                super(...arguments),
                this.width = 0,
                this.alignment = .5,
                this.native = !1,
                this.cap = Xt.BUTT,
                this.join = $t.MITER,
                this.miterLimit = 10
            }
            clone() {
                const t = new he;
                return t.color = this.color,
                t.alpha = this.alpha,
                t.texture = this.texture,
                t.matrix = this.matrix,
                t.visible = this.visible,
                t.width = this.width,
                t.alignment = this.alignment,
                t.native = this.native,
                t.cap = this.cap,
                t.join = this.join,
                t.miterLimit = this.miterLimit,
                t
            }
            reset() {
                super.reset(),
                this.color = 0,
                this.alignment = .5,
                this.width = 0,
                this.native = !1
            }
        }
        const le = {}
          , ue = class extends i.W2 {
            constructor(t=null) {
                super(),
                this.shader = null,
                this.pluginName = "batch",
                this.currentPath = null,
                this.batches = [],
                this.batchTint = -1,
                this.batchDirty = -1,
                this.vertexData = null,
                this._fillStyle = new ae,
                this._lineStyle = new he,
                this._matrix = null,
                this._holeMode = !1,
                this.state = n.ZM.for2d(),
                this._geometry = t || new oe,
                this._geometry.refCount++,
                this._transformID = -1,
                this._tintColor = new n.Il(16777215),
                this.blendMode = n.T$.NORMAL
            }
            get geometry() {
                return this._geometry
            }
            clone() {
                return this.finishPoly(),
                new ue(this._geometry)
            }
            set blendMode(t) {
                this.state.blendMode = t
            }
            get blendMode() {
                return this.state.blendMode
            }
            get tint() {
                return this._tintColor.value
            }
            set tint(t) {
                this._tintColor.setValue(t)
            }
            get fill() {
                return this._fillStyle
            }
            get line() {
                return this._lineStyle
            }
            lineStyle(t=null, e=0, r, n=.5, i=!1) {
                return "number" == typeof t && (t = {
                    width: t,
                    color: e,
                    alpha: r,
                    alignment: n,
                    native: i
                }),
                this.lineTextureStyle(t)
            }
            lineTextureStyle(t) {
                const e = {
                    width: 0,
                    texture: n.xE.WHITE,
                    color: t?.texture ? 16777215 : 0,
                    matrix: null,
                    alignment: .5,
                    native: !1,
                    cap: Xt.BUTT,
                    join: $t.MITER,
                    miterLimit: 10
                };
                t = Object.assign(e, t),
                this.normalizeColor(t),
                this.currentPath && this.startPoly();
                const r = t.width > 0 && t.alpha > 0;
                return r ? (t.matrix && (t.matrix = t.matrix.clone(),
                t.matrix.invert()),
                Object.assign(this._lineStyle, {
                    visible: r
                }, t)) : this._lineStyle.reset(),
                this
            }
            startPoly() {
                if (this.currentPath) {
                    const t = this.currentPath.points
                      , e = this.currentPath.points.length;
                    e > 2 && (this.drawShape(this.currentPath),
                    this.currentPath = new n.mg,
                    this.currentPath.closeStroke = !1,
                    this.currentPath.points.push(t[e - 2], t[e - 1]))
                } else
                    this.currentPath = new n.mg,
                    this.currentPath.closeStroke = !1
            }
            finishPoly() {
                this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath),
                this.currentPath = null) : this.currentPath.points.length = 0)
            }
            moveTo(t, e) {
                return this.startPoly(),
                this.currentPath.points[0] = t,
                this.currentPath.points[1] = e,
                this
            }
            lineTo(t, e) {
                this.currentPath || this.moveTo(0, 0);
                const r = this.currentPath.points
                  , n = r[r.length - 2]
                  , i = r[r.length - 1];
                return n === t && i === e || r.push(t, e),
                this
            }
            _initCurve(t=0, e=0) {
                this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [t, e]) : this.moveTo(t, e)
            }
            quadraticCurveTo(t, e, r, n) {
                this._initCurve();
                const i = this.currentPath.points;
                return 0 === i.length && this.moveTo(0, 0),
                Jt.curveTo(t, e, r, n, i),
                this
            }
            bezierCurveTo(t, e, r, n, i, s) {
                return this._initCurve(),
                Yt.curveTo(t, e, r, n, i, s, this.currentPath.points),
                this
            }
            arcTo(t, e, r, n, i) {
                this._initCurve(t, e);
                const s = this.currentPath.points
                  , o = Wt.curveTo(t, e, r, n, i, s);
                if (o) {
                    const {cx: t, cy: e, radius: r, startAngle: n, endAngle: i, anticlockwise: s} = o;
                    this.arc(t, e, r, n, i, s)
                }
                return this
            }
            arc(t, e, r, i, s, o=!1) {
                if (i === s)
                    return this;
                if (!o && s <= i ? s += n._b : o && i <= s && (i += n._b),
                0 == s - i)
                    return this;
                const a = t + Math.cos(i) * r
                  , h = e + Math.sin(i) * r
                  , l = this._geometry.closePointEps;
                let u = this.currentPath ? this.currentPath.points : null;
                if (u) {
                    const t = Math.abs(u[u.length - 2] - a)
                      , e = Math.abs(u[u.length - 1] - h);
                    t < l && e < l || u.push(a, h)
                } else
                    this.moveTo(a, h),
                    u = this.currentPath.points;
                return Wt.arc(a, h, t, e, r, i, s, o, u),
                this
            }
            beginFill(t=0, e) {
                return this.beginTextureFill({
                    texture: n.xE.WHITE,
                    color: t,
                    alpha: e
                })
            }
            normalizeColor(t) {
                const e = n.Il.shared.setValue(t.color ?? 0);
                t.color = e.toNumber(),
                t.alpha ?? (t.alpha = e.alpha)
            }
            beginTextureFill(t) {
                const e = {
                    texture: n.xE.WHITE,
                    color: 16777215,
                    matrix: null
                };
                t = Object.assign(e, t),
                this.normalizeColor(t),
                this.currentPath && this.startPoly();
                const r = t.alpha > 0;
                return r ? (t.matrix && (t.matrix = t.matrix.clone(),
                t.matrix.invert()),
                Object.assign(this._fillStyle, {
                    visible: r
                }, t)) : this._fillStyle.reset(),
                this
            }
            endFill() {
                return this.finishPoly(),
                this._fillStyle.reset(),
                this
            }
            drawRect(t, e, r, i) {
                return this.drawShape(new n.Ae(t,e,r,i))
            }
            drawRoundedRect(t, e, r, i, s) {
                return this.drawShape(new n.c9(t,e,r,i,s))
            }
            drawCircle(t, e, r) {
                return this.drawShape(new n.Cd(t,e,r))
            }
            drawEllipse(t, e, r, i) {
                return this.drawShape(new n.Pj(t,e,r,i))
            }
            drawPolygon(...t) {
                let e, r = !0;
                const i = t[0];
                i.points ? (r = i.closeStroke,
                e = i.points) : e = Array.isArray(t[0]) ? t[0] : t;
                const s = new n.mg(e);
                return s.closeStroke = r,
                this.drawShape(s),
                this
            }
            drawShape(t) {
                return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix),
                this
            }
            clear() {
                return this._geometry.clear(),
                this._lineStyle.reset(),
                this._fillStyle.reset(),
                this._boundsID++,
                this._matrix = null,
                this._holeMode = !1,
                this.currentPath = null,
                this
            }
            isFastRect() {
                const t = this._geometry.graphicsData;
                return !(1 !== t.length || t[0].shape.type !== n.HS.RECT || t[0].matrix || t[0].holes.length || t[0].lineStyle.visible && t[0].lineStyle.width)
            }
            _render(t) {
                this.finishPoly();
                const e = this._geometry;
                e.updateBatches(),
                e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(),
                this._renderBatched(t)) : (t.batch.flush(),
                this._renderDirect(t))
            }
            _populateBatches() {
                const t = this._geometry
                  , e = this.blendMode
                  , r = t.batches.length;
                this.batchTint = -1,
                this._transformID = -1,
                this.batchDirty = t.batchDirty,
                this.batches.length = r,
                this.vertexData = new Float32Array(t.points);
                for (let i = 0; i < r; i++) {
                    const r = t.batches[i]
                      , s = r.style.color
                      , o = new Float32Array(this.vertexData.buffer,4 * r.attribStart * 2,2 * r.attribSize)
                      , a = new Float32Array(t.uvsFloat32.buffer,4 * r.attribStart * 2,2 * r.attribSize)
                      , h = {
                        vertexData: o,
                        blendMode: e,
                        indices: new Uint16Array(t.indicesUint16.buffer,2 * r.start,r.size),
                        uvs: a,
                        _batchRGB: n.Il.shared.setValue(s).toRgbArray(),
                        _tintRGB: s,
                        _texture: r.style.texture,
                        alpha: r.style.alpha,
                        worldAlpha: 1
                    };
                    this.batches[i] = h
                }
            }
            _renderBatched(t) {
                if (this.batches.length) {
                    t.batch.setObjectRenderer(t.plugins[this.pluginName]),
                    this.calculateVertices(),
                    this.calculateTints();
                    for (let e = 0, r = this.batches.length; e < r; e++) {
                        const r = this.batches[e];
                        r.worldAlpha = this.worldAlpha * r.alpha,
                        t.plugins[this.pluginName].render(r)
                    }
                }
            }
            _renderDirect(t) {
                const e = this._resolveDirectShader(t)
                  , r = this._geometry
                  , i = this.worldAlpha
                  , s = e.uniforms
                  , o = r.drawCalls;
                s.translationMatrix = this.transform.worldTransform,
                n.Il.shared.setValue(this._tintColor).premultiply(i).toArray(s.tint),
                t.shader.bind(e),
                t.geometry.bind(r, e),
                t.state.set(this.state);
                for (let e = 0, n = o.length; e < n; e++)
                    this._renderDrawCallDirect(t, r.drawCalls[e])
            }
            _renderDrawCallDirect(t, e) {
                const {texArray: r, type: n, size: i, start: s} = e
                  , o = r.count;
                for (let e = 0; e < o; e++)
                    t.texture.bind(r.elements[e], e);
                t.geometry.draw(n, i, s)
            }
            _resolveDirectShader(t) {
                let e = this.shader;
                const r = this.pluginName;
                if (!e) {
                    if (!le[r]) {
                        const {maxTextures: e} = t.plugins[r]
                          , i = new Int32Array(e);
                        for (let t = 0; t < e; t++)
                            i[t] = t;
                        const s = {
                            tint: new Float32Array([1, 1, 1, 1]),
                            translationMatrix: new n.y3,
                            default: n.oo.from({
                                uSamplers: i
                            }, !0)
                        }
                          , o = t.plugins[r]._shader.program;
                        le[r] = new n.ex(o,s)
                    }
                    e = le[r]
                }
                return e
            }
            _calculateBounds() {
                this.finishPoly();
                const t = this._geometry;
                if (!t.graphicsData.length)
                    return;
                const {minX: e, minY: r, maxX: n, maxY: i} = t.bounds;
                this._bounds.addFrame(this.transform, e, r, n, i)
            }
            containsPoint(t) {
                return this.worldTransform.applyInverse(t, ue._TEMP_POINT),
                this._geometry.containsPoint(ue._TEMP_POINT)
            }
            calculateTints() {
                if (this.batchTint !== this.tint) {
                    this.batchTint = this._tintColor.toNumber();
                    for (let t = 0; t < this.batches.length; t++) {
                        const e = this.batches[t];
                        e._tintRGB = n.Il.shared.setValue(this._tintColor).multiply(e._batchRGB).toLittleEndianNumber()
                    }
                }
            }
            calculateVertices() {
                const t = this.transform._worldID;
                if (this._transformID === t)
                    return;
                this._transformID = t;
                const e = this.transform.worldTransform
                  , r = e.a
                  , n = e.b
                  , i = e.c
                  , s = e.d
                  , o = e.tx
                  , a = e.ty
                  , h = this._geometry.points
                  , l = this.vertexData;
                let u = 0;
                for (let t = 0; t < h.length; t += 2) {
                    const e = h[t]
                      , c = h[t + 1];
                    l[u++] = r * e + i * c + o,
                    l[u++] = s * c + n * e + a
                }
            }
            closePath() {
                const t = this.currentPath;
                return t && (t.closeStroke = !0,
                this.finishPoly()),
                this
            }
            setMatrix(t) {
                return this._matrix = t,
                this
            }
            beginHole() {
                return this.finishPoly(),
                this._holeMode = !0,
                this
            }
            endHole() {
                return this.finishPoly(),
                this._holeMode = !1,
                this
            }
            destroy(t) {
                this._geometry.refCount--,
                0 === this._geometry.refCount && this._geometry.dispose(),
                this._matrix = null,
                this.currentPath = null,
                this._lineStyle.destroy(),
                this._lineStyle = null,
                this._fillStyle.destroy(),
                this._fillStyle = null,
                this._geometry = null,
                this.shader = null,
                this.vertexData = null,
                this.batches.length = 0,
                this.batches = null,
                super.destroy(t)
            }
        }
        ;
        let ce = ue;
        ce.curves = Vt,
        ce._TEMP_POINT = new n.E9;
        class de {
            constructor(t, e) {
                this.uvBuffer = t,
                this.uvMatrix = e,
                this.data = null,
                this._bufferUpdateId = -1,
                this._textureUpdateId = -1,
                this._updateID = 0
            }
            update(t) {
                if (!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)
                    return;
                this._bufferUpdateId = this.uvBuffer._updateID,
                this._textureUpdateId = this.uvMatrix._updateID;
                const e = this.uvBuffer.data;
                this.data && this.data.length === e.length || (this.data = new Float32Array(e.length)),
                this.uvMatrix.multiplyUvs(e, this.data),
                this._updateID++
            }
        }
        const fe = new n.E9
          , pe = new n.mg
          , me = class extends i.W2 {
            constructor(t, e, r, i=n.lg.TRIANGLES) {
                super(),
                this.geometry = t,
                this.shader = e,
                this.state = r || n.ZM.for2d(),
                this.drawMode = i,
                this.start = 0,
                this.size = 0,
                this.uvs = null,
                this.indices = null,
                this.vertexData = new Float32Array(1),
                this.vertexDirty = -1,
                this._transformID = -1,
                this._roundPixels = n.Xd.ROUND_PIXELS,
                this.batchUvs = null
            }
            get geometry() {
                return this._geometry
            }
            set geometry(t) {
                this._geometry !== t && (this._geometry && (this._geometry.refCount--,
                0 === this._geometry.refCount && this._geometry.dispose()),
                this._geometry = t,
                this._geometry && this._geometry.refCount++,
                this.vertexDirty = -1)
            }
            get uvBuffer() {
                return this.geometry.buffers[1]
            }
            get verticesBuffer() {
                return this.geometry.buffers[0]
            }
            set material(t) {
                this.shader = t
            }
            get material() {
                return this.shader
            }
            set blendMode(t) {
                this.state.blendMode = t
            }
            get blendMode() {
                return this.state.blendMode
            }
            set roundPixels(t) {
                this._roundPixels !== t && (this._transformID = -1),
                this._roundPixels = t
            }
            get roundPixels() {
                return this._roundPixels
            }
            get tint() {
                return "tint"in this.shader ? this.shader.tint : null
            }
            set tint(t) {
                this.shader.tint = t
            }
            get tintValue() {
                return this.shader.tintValue
            }
            get texture() {
                return "texture"in this.shader ? this.shader.texture : null
            }
            set texture(t) {
                this.shader.texture = t
            }
            _render(t) {
                const e = this.geometry.buffers[0].data;
                this.shader.batchable && this.drawMode === n.lg.TRIANGLES && e.length < 2 * me.BATCHABLE_SIZE ? this._renderToBatch(t) : this._renderDefault(t)
            }
            _renderDefault(t) {
                const e = this.shader;
                e.alpha = this.worldAlpha,
                e.update && e.update(),
                t.batch.flush(),
                e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0),
                t.shader.bind(e),
                t.state.set(this.state),
                t.geometry.bind(this.geometry, e),
                t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
            }
            _renderToBatch(t) {
                const e = this.geometry
                  , r = this.shader;
                r.uvMatrix && (r.uvMatrix.update(),
                this.calculateUvs()),
                this.calculateVertices(),
                this.indices = e.indexBuffer.data,
                this._tintRGB = r._tintRGB,
                this._texture = r.texture;
                const n = this.material.pluginName;
                t.batch.setObjectRenderer(t.plugins[n]),
                t.plugins[n].render(this)
            }
            calculateVertices() {
                const t = this.geometry.buffers[0]
                  , e = t.data
                  , r = t._updateID;
                if (r === this.vertexDirty && this._transformID === this.transform._worldID)
                    return;
                this._transformID = this.transform._worldID,
                this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length));
                const i = this.transform.worldTransform
                  , s = i.a
                  , o = i.b
                  , a = i.c
                  , h = i.d
                  , l = i.tx
                  , u = i.ty
                  , c = this.vertexData;
                for (let t = 0; t < c.length / 2; t++) {
                    const r = e[2 * t]
                      , n = e[2 * t + 1];
                    c[2 * t] = s * r + a * n + l,
                    c[2 * t + 1] = o * r + h * n + u
                }
                if (this._roundPixels) {
                    const t = n.Xd.RESOLUTION;
                    for (let e = 0; e < c.length; ++e)
                        c[e] = Math.round(c[e] * t) / t
                }
                this.vertexDirty = r
            }
            calculateUvs() {
                const t = this.geometry.buffers[1]
                  , e = this.shader;
                e.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new de(t,e.uvMatrix)),
                this.batchUvs.update(),
                this.uvs = this.batchUvs.data)
            }
            _calculateBounds() {
                this.calculateVertices(),
                this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
            }
            containsPoint(t) {
                if (!this.getBounds().contains(t.x, t.y))
                    return !1;
                this.worldTransform.applyInverse(t, fe);
                const e = this.geometry.getBuffer("aVertexPosition").data
                  , r = pe.points
                  , n = this.geometry.getIndex().data
                  , i = n.length
                  , s = 4 === this.drawMode ? 3 : 1;
                for (let t = 0; t + 2 < i; t += s) {
                    const i = 2 * n[t]
                      , s = 2 * n[t + 1]
                      , o = 2 * n[t + 2];
                    if (r[0] = e[i],
                    r[1] = e[i + 1],
                    r[2] = e[s],
                    r[3] = e[s + 1],
                    r[4] = e[o],
                    r[5] = e[o + 1],
                    pe.contains(fe.x, fe.y))
                        return !0
                }
                return !1
            }
            destroy(t) {
                super.destroy(t),
                this._cachedTexture && (this._cachedTexture.destroy(),
                this._cachedTexture = null),
                this.geometry = null,
                this.shader = null,
                this.state = null,
                this.uvs = null,
                this.indices = null,
                this.vertexData = null
            }
        }
        ;
        let ge = me;
        ge.BATCHABLE_SIZE = 100;
        class ve extends n.wG {
            constructor(t, e, r) {
                super();
                const i = new n.lW(t)
                  , s = new n.lW(e,!0)
                  , o = new n.lW(r,!0,!0);
                this.addAttribute("aVertexPosition", i, 2, !1, n.vK.FLOAT).addAttribute("aTextureCoord", s, 2, !1, n.vK.FLOAT).addIndex(o),
                this._updateId = -1
            }
            get vertexDirtyId() {
                return this.buffers[0]._updateID
            }
        }
        class ye extends n.ex {
            constructor(t, e) {
                const r = {
                    uSampler: t,
                    alpha: 1,
                    uTextureMatrix: n.y3.IDENTITY,
                    uColor: new Float32Array([1, 1, 1, 1])
                };
                (e = Object.assign({
                    tint: 16777215,
                    alpha: 1,
                    pluginName: "batch"
                }, e)).uniforms && Object.assign(r, e.uniforms),
                super(e.program || n.$r.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"), r),
                this._colorDirty = !1,
                this.uvMatrix = new n.UX(t),
                this.batchable = void 0 === e.program,
                this.pluginName = e.pluginName,
                this._tintColor = new n.Il(e.tint),
                this._tintRGB = this._tintColor.toLittleEndianNumber(),
                this._colorDirty = !0,
                this.alpha = e.alpha
            }
            get texture() {
                return this.uniforms.uSampler
            }
            set texture(t) {
                this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0),
                this.uniforms.uSampler = t,
                this.uvMatrix.texture = t)
            }
            set alpha(t) {
                t !== this._alpha && (this._alpha = t,
                this._colorDirty = !0)
            }
            get alpha() {
                return this._alpha
            }
            set tint(t) {
                t !== this.tint && (this._tintColor.setValue(t),
                this._tintRGB = this._tintColor.toLittleEndianNumber(),
                this._colorDirty = !0)
            }
            get tint() {
                return this._tintColor.value
            }
            get tintValue() {
                return this._tintColor.toNumber()
            }
            update() {
                if (this._colorDirty) {
                    this._colorDirty = !1;
                    const t = this.texture.baseTexture.alphaMode;
                    n.Il.shared.setValue(this._tintColor).premultiply(this._alpha, t).toArray(this.uniforms.uColor)
                }
                this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
            }
        }
        class _e {
            constructor(t, e, r) {
                this.geometry = new n.wG,
                this.indexBuffer = null,
                this.size = r,
                this.dynamicProperties = [],
                this.staticProperties = [];
                for (let r = 0; r < t.length; ++r) {
                    let i = t[r];
                    i = {
                        attributeName: i.attributeName,
                        size: i.size,
                        uploadFunction: i.uploadFunction,
                        type: i.type || n.vK.FLOAT,
                        offset: i.offset
                    },
                    e[r] ? this.dynamicProperties.push(i) : this.staticProperties.push(i)
                }
                this.staticStride = 0,
                this.staticBuffer = null,
                this.staticData = null,
                this.staticDataUint32 = null,
                this.dynamicStride = 0,
                this.dynamicBuffer = null,
                this.dynamicData = null,
                this.dynamicDataUint32 = null,
                this._updateID = 0,
                this.initBuffers()
            }
            initBuffers() {
                const t = this.geometry;
                let e = 0;
                this.indexBuffer = new n.lW(n.P6.createIndicesForQuads(this.size),!0,!0),
                t.addIndex(this.indexBuffer),
                this.dynamicStride = 0;
                for (let t = 0; t < this.dynamicProperties.length; ++t) {
                    const r = this.dynamicProperties[t];
                    r.offset = e,
                    e += r.size,
                    this.dynamicStride += r.size
                }
                const r = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
                this.dynamicData = new Float32Array(r),
                this.dynamicDataUint32 = new Uint32Array(r),
                this.dynamicBuffer = new n.lW(this.dynamicData,!1,!1);
                let i = 0;
                this.staticStride = 0;
                for (let t = 0; t < this.staticProperties.length; ++t) {
                    const e = this.staticProperties[t];
                    e.offset = i,
                    i += e.size,
                    this.staticStride += e.size
                }
                const s = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
                this.staticData = new Float32Array(s),
                this.staticDataUint32 = new Uint32Array(s),
                this.staticBuffer = new n.lW(this.staticData,!0,!1);
                for (let e = 0; e < this.dynamicProperties.length; ++e) {
                    const r = this.dynamicProperties[e];
                    t.addAttribute(r.attributeName, this.dynamicBuffer, 0, r.type === n.vK.UNSIGNED_BYTE, r.type, 4 * this.dynamicStride, 4 * r.offset)
                }
                for (let e = 0; e < this.staticProperties.length; ++e) {
                    const r = this.staticProperties[e];
                    t.addAttribute(r.attributeName, this.staticBuffer, 0, r.type === n.vK.UNSIGNED_BYTE, r.type, 4 * this.staticStride, 4 * r.offset)
                }
            }
            uploadDynamic(t, e, r) {
                for (let i = 0; i < this.dynamicProperties.length; i++) {
                    const s = this.dynamicProperties[i];
                    s.uploadFunction(t, e, r, s.type === n.vK.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, s.offset)
                }
                this.dynamicBuffer._updateID++
            }
            uploadStatic(t, e, r) {
                for (let i = 0; i < this.staticProperties.length; i++) {
                    const s = this.staticProperties[i];
                    s.uploadFunction(t, e, r, s.type === n.vK.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, s.offset)
                }
                this.staticBuffer._updateID++
            }
            destroy() {
                this.indexBuffer = null,
                this.dynamicProperties = null,
                this.dynamicBuffer = null,
                this.dynamicData = null,
                this.dynamicDataUint32 = null,
                this.staticProperties = null,
                this.staticBuffer = null,
                this.staticData = null,
                this.staticDataUint32 = null,
                this.geometry.destroy()
            }
        }
        class xe extends n.bO {
            constructor(t) {
                super(t),
                this.shader = null,
                this.properties = null,
                this.tempMatrix = new n.y3,
                this.properties = [{
                    attributeName: "aVertexPosition",
                    size: 2,
                    uploadFunction: this.uploadVertices,
                    offset: 0
                }, {
                    attributeName: "aPositionCoord",
                    size: 2,
                    uploadFunction: this.uploadPosition,
                    offset: 0
                }, {
                    attributeName: "aRotation",
                    size: 1,
                    uploadFunction: this.uploadRotation,
                    offset: 0
                }, {
                    attributeName: "aTextureCoord",
                    size: 2,
                    uploadFunction: this.uploadUvs,
                    offset: 0
                }, {
                    attributeName: "aColor",
                    size: 1,
                    type: n.vK.UNSIGNED_BYTE,
                    uploadFunction: this.uploadTint,
                    offset: 0
                }],
                this.shader = n.ex.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", {}),
                this.state = n.ZM.for2d()
            }
            render(t) {
                const e = t.children
                  , r = t._maxSize
                  , i = t._batchSize
                  , s = this.renderer;
                let o = e.length;
                if (0 === o)
                    return;
                o > r && !t.autoResize && (o = r);
                let a = t._buffers;
                a || (a = t._buffers = this.generateBuffers(t));
                const h = e[0]._texture.baseTexture
                  , l = h.alphaMode > 0;
                this.state.blendMode = n.P6.correctBlendMode(t.blendMode, l),
                s.state.set(this.state);
                const u = s.gl
                  , c = t.worldTransform.copyTo(this.tempMatrix);
                c.prepend(s.globalUniforms.uniforms.projectionMatrix),
                this.shader.uniforms.translationMatrix = c.toArray(!0),
                this.shader.uniforms.uColor = n.Il.shared.setValue(t.tintRgb).premultiply(t.worldAlpha, l).toArray(this.shader.uniforms.uColor),
                this.shader.uniforms.uSampler = h,
                this.renderer.shader.bind(this.shader);
                let d = !1;
                for (let r = 0, n = 0; r < o; r += i,
                n += 1) {
                    let h = o - r;
                    h > i && (h = i),
                    n >= a.length && a.push(this._generateOneMoreBuffer(t));
                    const l = a[n];
                    l.uploadDynamic(e, r, h);
                    const c = t._bufferUpdateIDs[n] || 0;
                    d = d || l._updateID < c,
                    d && (l._updateID = t._updateID,
                    l.uploadStatic(e, r, h)),
                    s.geometry.bind(l.geometry),
                    u.drawElements(u.TRIANGLES, 6 * h, u.UNSIGNED_SHORT, 0)
                }
            }
            generateBuffers(t) {
                const e = []
                  , r = t._maxSize
                  , n = t._batchSize
                  , i = t._properties;
                for (let t = 0; t < r; t += n)
                    e.push(new _e(this.properties,i,n));
                return e
            }
            _generateOneMoreBuffer(t) {
                const e = t._batchSize
                  , r = t._properties;
                return new _e(this.properties,r,e)
            }
            uploadVertices(t, e, r, n, i, s) {
                let o = 0
                  , a = 0
                  , h = 0
                  , l = 0;
                for (let u = 0; u < r; ++u) {
                    const r = t[e + u]
                      , c = r._texture
                      , d = r.scale.x
                      , f = r.scale.y
                      , p = c.trim
                      , m = c.orig;
                    p ? (a = p.x - r.anchor.x * m.width,
                    o = a + p.width,
                    l = p.y - r.anchor.y * m.height,
                    h = l + p.height) : (o = m.width * (1 - r.anchor.x),
                    a = m.width * -r.anchor.x,
                    h = m.height * (1 - r.anchor.y),
                    l = m.height * -r.anchor.y),
                    n[s] = a * d,
                    n[s + 1] = l * f,
                    n[s + i] = o * d,
                    n[s + i + 1] = l * f,
                    n[s + 2 * i] = o * d,
                    n[s + 2 * i + 1] = h * f,
                    n[s + 3 * i] = a * d,
                    n[s + 3 * i + 1] = h * f,
                    s += 4 * i
                }
            }
            uploadPosition(t, e, r, n, i, s) {
                for (let o = 0; o < r; o++) {
                    const r = t[e + o].position;
                    n[s] = r.x,
                    n[s + 1] = r.y,
                    n[s + i] = r.x,
                    n[s + i + 1] = r.y,
                    n[s + 2 * i] = r.x,
                    n[s + 2 * i + 1] = r.y,
                    n[s + 3 * i] = r.x,
                    n[s + 3 * i + 1] = r.y,
                    s += 4 * i
                }
            }
            uploadRotation(t, e, r, n, i, s) {
                for (let o = 0; o < r; o++) {
                    const r = t[e + o].rotation;
                    n[s] = r,
                    n[s + i] = r,
                    n[s + 2 * i] = r,
                    n[s + 3 * i] = r,
                    s += 4 * i
                }
            }
            uploadUvs(t, e, r, n, i, s) {
                for (let o = 0; o < r; ++o) {
                    const r = t[e + o]._texture._uvs;
                    r ? (n[s] = r.x0,
                    n[s + 1] = r.y0,
                    n[s + i] = r.x1,
                    n[s + i + 1] = r.y1,
                    n[s + 2 * i] = r.x2,
                    n[s + 2 * i + 1] = r.y2,
                    n[s + 3 * i] = r.x3,
                    n[s + 3 * i + 1] = r.y3,
                    s += 4 * i) : (n[s] = 0,
                    n[s + 1] = 0,
                    n[s + i] = 0,
                    n[s + i + 1] = 0,
                    n[s + 2 * i] = 0,
                    n[s + 2 * i + 1] = 0,
                    n[s + 3 * i] = 0,
                    n[s + 3 * i + 1] = 0,
                    s += 4 * i)
                }
            }
            uploadTint(t, e, r, i, s, o) {
                for (let a = 0; a < r; ++a) {
                    const r = t[e + a]
                      , h = n.Il.shared.setValue(r._tintRGB).toPremultiplied(r.alpha, r.texture.baseTexture.alphaMode > 0);
                    i[o] = h,
                    i[o + s] = h,
                    i[o + 2 * s] = h,
                    i[o + 3 * s] = h,
                    o += 4 * s
                }
            }
            destroy() {
                super.destroy(),
                this.shader && (this.shader.destroy(),
                this.shader = null),
                this.tempMatrix = null
            }
        }
        xe.extension = {
            name: "particle",
            type: n.nw.RendererPlugin
        },
        n.Rw.add(xe);
        var be = (t => (t[t.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL",
        t[t.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL",
        t))(be || {});
        const Ee = {
            willReadFrequently: !0
        }
          , Te = class {
            static get experimentalLetterSpacingSupported() {
                let t = Te._experimentalLetterSpacingSupported;
                if (void 0 !== t) {
                    const e = n.Xd.ADAPTER.getCanvasRenderingContext2D().prototype;
                    t = Te._experimentalLetterSpacingSupported = "letterSpacing"in e || "textLetterSpacing"in e
                }
                return t
            }
            constructor(t, e, r, n, i, s, o, a, h) {
                this.text = t,
                this.style = e,
                this.width = r,
                this.height = n,
                this.lines = i,
                this.lineWidths = s,
                this.lineHeight = o,
                this.maxLineWidth = a,
                this.fontProperties = h
            }
            static measureText(t, e, r, n=Te._canvas) {
                r = null == r ? e.wordWrap : r;
                const i = e.toFontString()
                  , s = Te.measureFont(i);
                0 === s.fontSize && (s.fontSize = e.fontSize,
                s.ascent = e.fontSize);
                const o = n.getContext("2d", Ee);
                o.font = i;
                const a = (r ? Te.wordWrap(t, e, n) : t).split(/(?:\r\n|\r|\n)/)
                  , h = new Array(a.length);
                let l = 0;
                for (let t = 0; t < a.length; t++) {
                    const r = Te._measureText(a[t], e.letterSpacing, o);
                    h[t] = r,
                    l = Math.max(l, r)
                }
                let u = l + e.strokeThickness;
                e.dropShadow && (u += e.dropShadowDistance);
                const c = e.lineHeight || s.fontSize + e.strokeThickness;
                let d = Math.max(c, s.fontSize + 2 * e.strokeThickness) + (a.length - 1) * (c + e.leading);
                return e.dropShadow && (d += e.dropShadowDistance),
                new Te(t,e,u,d,a,h,c + e.leading,l,s)
            }
            static _measureText(t, e, r) {
                let n = !1;
                Te.experimentalLetterSpacingSupported && (Te.experimentalLetterSpacing ? (r.letterSpacing = `${e}px`,
                r.textLetterSpacing = `${e}px`,
                n = !0) : (r.letterSpacing = "0px",
                r.textLetterSpacing = "0px"));
                let i = r.measureText(t).width;
                return i > 0 && (n ? i -= e : i += (Te.graphemeSegmenter(t).length - 1) * e),
                i
            }
            static wordWrap(t, e, r=Te._canvas) {
                const n = r.getContext("2d", Ee);
                let i = 0
                  , s = ""
                  , o = "";
                const a = Object.create(null)
                  , {letterSpacing: h, whiteSpace: l} = e
                  , u = Te.collapseSpaces(l)
                  , c = Te.collapseNewlines(l);
                let d = !u;
                const f = e.wordWrapWidth + h
                  , p = Te.tokenize(t);
                for (let t = 0; t < p.length; t++) {
                    let r = p[t];
                    if (Te.isNewline(r)) {
                        if (!c) {
                            o += Te.addLine(s),
                            d = !u,
                            s = "",
                            i = 0;
                            continue
                        }
                        r = " "
                    }
                    if (u) {
                        const t = Te.isBreakingSpace(r)
                          , e = Te.isBreakingSpace(s[s.length - 1]);
                        if (t && e)
                            continue
                    }
                    const l = Te.getFromCache(r, h, a, n);
                    if (l > f)
                        if ("" !== s && (o += Te.addLine(s),
                        s = "",
                        i = 0),
                        Te.canBreakWords(r, e.breakWords)) {
                            const t = Te.wordWrapSplit(r);
                            for (let l = 0; l < t.length; l++) {
                                let u = t[l]
                                  , c = u
                                  , p = 1;
                                for (; t[l + p]; ) {
                                    const n = t[l + p];
                                    if (Te.canBreakChars(c, n, r, l, e.breakWords))
                                        break;
                                    u += n,
                                    c = n,
                                    p++
                                }
                                l += p - 1;
                                const m = Te.getFromCache(u, h, a, n);
                                m + i > f && (o += Te.addLine(s),
                                d = !1,
                                s = "",
                                i = 0),
                                s += u,
                                i += m
                            }
                        } else {
                            s.length > 0 && (o += Te.addLine(s),
                            s = "",
                            i = 0);
                            const e = t === p.length - 1;
                            o += Te.addLine(r, !e),
                            d = !1,
                            s = "",
                            i = 0
                        }
                    else
                        l + i > f && (d = !1,
                        o += Te.addLine(s),
                        s = "",
                        i = 0),
                        (s.length > 0 || !Te.isBreakingSpace(r) || d) && (s += r,
                        i += l)
                }
                return o += Te.addLine(s, !1),
                o
            }
            static addLine(t, e=!0) {
                return t = Te.trimRight(t),
                e ? `${t}\n` : t
            }
            static getFromCache(t, e, r, n) {
                let i = r[t];
                return "number" != typeof i && (i = Te._measureText(t, e, n) + e,
                r[t] = i),
                i
            }
            static collapseSpaces(t) {
                return "normal" === t || "pre-line" === t
            }
            static collapseNewlines(t) {
                return "normal" === t
            }
            static trimRight(t) {
                if ("string" != typeof t)
                    return "";
                for (let e = t.length - 1; e >= 0; e--) {
                    const r = t[e];
                    if (!Te.isBreakingSpace(r))
                        break;
                    t = t.slice(0, -1)
                }
                return t
            }
            static isNewline(t) {
                return "string" == typeof t && Te._newlines.includes(t.charCodeAt(0))
            }
            static isBreakingSpace(t, e) {
                return "string" == typeof t && Te._breakingSpaces.includes(t.charCodeAt(0))
            }
            static tokenize(t) {
                const e = [];
                let r = "";
                if ("string" != typeof t)
                    return e;
                for (let n = 0; n < t.length; n++) {
                    const i = t[n]
                      , s = t[n + 1];
                    Te.isBreakingSpace(i, s) || Te.isNewline(i) ? ("" !== r && (e.push(r),
                    r = ""),
                    e.push(i)) : r += i
                }
                return "" !== r && e.push(r),
                e
            }
            static canBreakWords(t, e) {
                return e
            }
            static canBreakChars(t, e, r, n, i) {
                return !0
            }
            static wordWrapSplit(t) {
                return Te.graphemeSegmenter(t)
            }
            static measureFont(t) {
                if (Te._fonts[t])
                    return Te._fonts[t];
                const e = {
                    ascent: 0,
                    descent: 0,
                    fontSize: 0
                }
                  , r = Te._canvas
                  , n = Te._context;
                n.font = t;
                const i = Te.METRICS_STRING + Te.BASELINE_SYMBOL
                  , s = Math.ceil(n.measureText(i).width);
                let o = Math.ceil(n.measureText(Te.BASELINE_SYMBOL).width);
                const a = Math.ceil(Te.HEIGHT_MULTIPLIER * o);
                if (o = o * Te.BASELINE_MULTIPLIER | 0,
                0 === s || 0 === a)
                    return Te._fonts[t] = e,
                    e;
                r.width = s,
                r.height = a,
                n.fillStyle = "#f00",
                n.fillRect(0, 0, s, a),
                n.font = t,
                n.textBaseline = "alphabetic",
                n.fillStyle = "#000",
                n.fillText(i, 0, o);
                const h = n.getImageData(0, 0, s, a).data
                  , l = h.length
                  , u = 4 * s;
                let c = 0
                  , d = 0
                  , f = !1;
                for (c = 0; c < o; ++c) {
                    for (let t = 0; t < u; t += 4)
                        if (255 !== h[d + t]) {
                            f = !0;
                            break
                        }
                    if (f)
                        break;
                    d += u
                }
                for (e.ascent = o - c,
                d = l - u,
                f = !1,
                c = a; c > o; --c) {
                    for (let t = 0; t < u; t += 4)
                        if (255 !== h[d + t]) {
                            f = !0;
                            break
                        }
                    if (f)
                        break;
                    d -= u
                }
                return e.descent = c - o,
                e.fontSize = e.ascent + e.descent,
                Te._fonts[t] = e,
                e
            }
            static clearMetrics(t="") {
                t ? delete Te._fonts[t] : Te._fonts = {}
            }
            static get _canvas() {
                if (!Te.__canvas) {
                    let t;
                    try {
                        const e = new OffscreenCanvas(0,0)
                          , r = e.getContext("2d", Ee);
                        if (r?.measureText)
                            return Te.__canvas = e,
                            e;
                        t = n.Xd.ADAPTER.createCanvas()
                    } catch (e) {
                        t = n.Xd.ADAPTER.createCanvas()
                    }
                    t.width = t.height = 10,
                    Te.__canvas = t
                }
                return Te.__canvas
            }
            static get _context() {
                return Te.__context || (Te.__context = Te._canvas.getContext("2d", Ee)),
                Te.__context
            }
        }
        ;
        let we = Te;
        we.METRICS_STRING = "|ÉqÅ",
        we.BASELINE_SYMBOL = "M",
        we.BASELINE_MULTIPLIER = 1.4,
        we.HEIGHT_MULTIPLIER = 2,
        we.graphemeSegmenter = ( () => {
            if ("function" == typeof Intl?.Segmenter) {
                const t = new Intl.Segmenter;
                return e => [...t.segment(e)].map((t => t.segment))
            }
            return t => [...t]
        }
        )(),
        we.experimentalLetterSpacing = !1,
        we._fonts = {},
        we._newlines = [10, 13],
        we._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
        const Se = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
          , Ae = class {
            constructor(t) {
                this.styleID = 0,
                this.reset(),
                Pe(this, t, t)
            }
            clone() {
                const t = {};
                return Pe(t, this, Ae.defaultStyle),
                new Ae(t)
            }
            reset() {
                Pe(this, Ae.defaultStyle, Ae.defaultStyle)
            }
            get align() {
                return this._align
            }
            set align(t) {
                this._align !== t && (this._align = t,
                this.styleID++)
            }
            get breakWords() {
                return this._breakWords
            }
            set breakWords(t) {
                this._breakWords !== t && (this._breakWords = t,
                this.styleID++)
            }
            get dropShadow() {
                return this._dropShadow
            }
            set dropShadow(t) {
                this._dropShadow !== t && (this._dropShadow = t,
                this.styleID++)
            }
            get dropShadowAlpha() {
                return this._dropShadowAlpha
            }
            set dropShadowAlpha(t) {
                this._dropShadowAlpha !== t && (this._dropShadowAlpha = t,
                this.styleID++)
            }
            get dropShadowAngle() {
                return this._dropShadowAngle
            }
            set dropShadowAngle(t) {
                this._dropShadowAngle !== t && (this._dropShadowAngle = t,
                this.styleID++)
            }
            get dropShadowBlur() {
                return this._dropShadowBlur
            }
            set dropShadowBlur(t) {
                this._dropShadowBlur !== t && (this._dropShadowBlur = t,
                this.styleID++)
            }
            get dropShadowColor() {
                return this._dropShadowColor
            }
            set dropShadowColor(t) {
                const e = Re(t);
                this._dropShadowColor !== e && (this._dropShadowColor = e,
                this.styleID++)
            }
            get dropShadowDistance() {
                return this._dropShadowDistance
            }
            set dropShadowDistance(t) {
                this._dropShadowDistance !== t && (this._dropShadowDistance = t,
                this.styleID++)
            }
            get fill() {
                return this._fill
            }
            set fill(t) {
                const e = Re(t);
                this._fill !== e && (this._fill = e,
                this.styleID++)
            }
            get fillGradientType() {
                return this._fillGradientType
            }
            set fillGradientType(t) {
                this._fillGradientType !== t && (this._fillGradientType = t,
                this.styleID++)
            }
            get fillGradientStops() {
                return this._fillGradientStops
            }
            set fillGradientStops(t) {
                (function(t, e) {
                    if (!Array.isArray(t) || !Array.isArray(e))
                        return !1;
                    if (t.length !== e.length)
                        return !1;
                    for (let r = 0; r < t.length; ++r)
                        if (t[r] !== e[r])
                            return !1;
                    return !0
                }
                )(this._fillGradientStops, t) || (this._fillGradientStops = t,
                this.styleID++)
            }
            get fontFamily() {
                return this._fontFamily
            }
            set fontFamily(t) {
                this.fontFamily !== t && (this._fontFamily = t,
                this.styleID++)
            }
            get fontSize() {
                return this._fontSize
            }
            set fontSize(t) {
                this._fontSize !== t && (this._fontSize = t,
                this.styleID++)
            }
            get fontStyle() {
                return this._fontStyle
            }
            set fontStyle(t) {
                this._fontStyle !== t && (this._fontStyle = t,
                this.styleID++)
            }
            get fontVariant() {
                return this._fontVariant
            }
            set fontVariant(t) {
                this._fontVariant !== t && (this._fontVariant = t,
                this.styleID++)
            }
            get fontWeight() {
                return this._fontWeight
            }
            set fontWeight(t) {
                this._fontWeight !== t && (this._fontWeight = t,
                this.styleID++)
            }
            get letterSpacing() {
                return this._letterSpacing
            }
            set letterSpacing(t) {
                this._letterSpacing !== t && (this._letterSpacing = t,
                this.styleID++)
            }
            get lineHeight() {
                return this._lineHeight
            }
            set lineHeight(t) {
                this._lineHeight !== t && (this._lineHeight = t,
                this.styleID++)
            }
            get leading() {
                return this._leading
            }
            set leading(t) {
                this._leading !== t && (this._leading = t,
                this.styleID++)
            }
            get lineJoin() {
                return this._lineJoin
            }
            set lineJoin(t) {
                this._lineJoin !== t && (this._lineJoin = t,
                this.styleID++)
            }
            get miterLimit() {
                return this._miterLimit
            }
            set miterLimit(t) {
                this._miterLimit !== t && (this._miterLimit = t,
                this.styleID++)
            }
            get padding() {
                return this._padding
            }
            set padding(t) {
                this._padding !== t && (this._padding = t,
                this.styleID++)
            }
            get stroke() {
                return this._stroke
            }
            set stroke(t) {
                const e = Re(t);
                this._stroke !== e && (this._stroke = e,
                this.styleID++)
            }
            get strokeThickness() {
                return this._strokeThickness
            }
            set strokeThickness(t) {
                this._strokeThickness !== t && (this._strokeThickness = t,
                this.styleID++)
            }
            get textBaseline() {
                return this._textBaseline
            }
            set textBaseline(t) {
                this._textBaseline !== t && (this._textBaseline = t,
                this.styleID++)
            }
            get trim() {
                return this._trim
            }
            set trim(t) {
                this._trim !== t && (this._trim = t,
                this.styleID++)
            }
            get whiteSpace() {
                return this._whiteSpace
            }
            set whiteSpace(t) {
                this._whiteSpace !== t && (this._whiteSpace = t,
                this.styleID++)
            }
            get wordWrap() {
                return this._wordWrap
            }
            set wordWrap(t) {
                this._wordWrap !== t && (this._wordWrap = t,
                this.styleID++)
            }
            get wordWrapWidth() {
                return this._wordWrapWidth
            }
            set wordWrapWidth(t) {
                this._wordWrapWidth !== t && (this._wordWrapWidth = t,
                this.styleID++)
            }
            toFontString() {
                const t = "number" == typeof this.fontSize ? `${this.fontSize}px` : this.fontSize;
                let e = this.fontFamily;
                Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
                for (let t = e.length - 1; t >= 0; t--) {
                    let r = e[t].trim();
                    /([\"\'])[^\'\"]+\1/.test(r) || Se.includes(r) || (r = `"${r}"`),
                    e[t] = r
                }
                return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${t} ${e.join(",")}`
            }
        }
        ;
        let Ce = Ae;
        function Re(t) {
            const e = n.Il.shared;
            return Array.isArray(t) ? t.map((t => e.setValue(t).toHex())) : e.setValue(t).toHex()
        }
        function Pe(t, e, r) {
            for (const n in r)
                Array.isArray(e[n]) ? t[n] = e[n].slice() : t[n] = e[n]
        }
        Ce.defaultStyle = {
            align: "left",
            breakWords: !1,
            dropShadow: !1,
            dropShadowAlpha: 1,
            dropShadowAngle: Math.PI / 6,
            dropShadowBlur: 0,
            dropShadowColor: "black",
            dropShadowDistance: 5,
            fill: "black",
            fillGradientType: be.LINEAR_VERTICAL,
            fillGradientStops: [],
            fontFamily: "Arial",
            fontSize: 26,
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            leading: 0,
            letterSpacing: 0,
            lineHeight: 0,
            lineJoin: "miter",
            miterLimit: 10,
            padding: 0,
            stroke: "black",
            strokeThickness: 0,
            textBaseline: "alphabetic",
            trim: !1,
            whiteSpace: "pre",
            wordWrap: !1,
            wordWrapWidth: 100
        };
        const Ie = {
            texture: !0,
            children: !1,
            baseTexture: !0
        }
          , Me = class extends a {
            constructor(t, e, r) {
                let i = !1;
                r || (r = n.Xd.ADAPTER.createCanvas(),
                i = !0),
                r.width = 3,
                r.height = 3;
                const s = n.xE.from(r);
                s.orig = new n.Ae,
                s.trim = new n.Ae,
                super(s),
                this._ownCanvas = i,
                this.canvas = r,
                this.context = r.getContext("2d", {
                    willReadFrequently: !0
                }),
                this._resolution = Me.defaultResolution ?? n.Xd.RESOLUTION,
                this._autoResolution = Me.defaultAutoResolution,
                this._text = null,
                this._style = null,
                this._styleListener = null,
                this._font = "",
                this.text = t,
                this.style = e,
                this.localStyleID = -1
            }
            static get experimentalLetterSpacing() {
                return we.experimentalLetterSpacing
            }
            static set experimentalLetterSpacing(t) {
                n.P6.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"),
                we.experimentalLetterSpacing = t
            }
            updateText(t) {
                const e = this._style;
                if (this.localStyleID !== e.styleID && (this.dirty = !0,
                this.localStyleID = e.styleID),
                !this.dirty && t)
                    return;
                this._font = this._style.toFontString();
                const r = this.context
                  , i = we.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas)
                  , s = i.width
                  , o = i.height
                  , a = i.lines
                  , h = i.lineHeight
                  , l = i.lineWidths
                  , u = i.maxLineWidth
                  , c = i.fontProperties;
                let d, f;
                this.canvas.width = Math.ceil(Math.ceil(Math.max(1, s) + 2 * e.padding) * this._resolution),
                this.canvas.height = Math.ceil(Math.ceil(Math.max(1, o) + 2 * e.padding) * this._resolution),
                r.scale(this._resolution, this._resolution),
                r.clearRect(0, 0, this.canvas.width, this.canvas.height),
                r.font = this._font,
                r.lineWidth = e.strokeThickness,
                r.textBaseline = e.textBaseline,
                r.lineJoin = e.lineJoin,
                r.miterLimit = e.miterLimit;
                const p = e.dropShadow ? 2 : 1;
                for (let t = 0; t < p; ++t) {
                    const s = e.dropShadow && 0 === t
                      , p = s ? Math.ceil(Math.max(1, o) + 2 * e.padding) : 0
                      , m = p * this._resolution;
                    if (s) {
                        r.fillStyle = "black",
                        r.strokeStyle = "black";
                        const t = e.dropShadowColor
                          , i = e.dropShadowBlur * this._resolution
                          , s = e.dropShadowDistance * this._resolution;
                        r.shadowColor = n.Il.shared.setValue(t).setAlpha(e.dropShadowAlpha).toRgbaString(),
                        r.shadowBlur = i,
                        r.shadowOffsetX = Math.cos(e.dropShadowAngle) * s,
                        r.shadowOffsetY = Math.sin(e.dropShadowAngle) * s + m
                    } else
                        r.fillStyle = this._generateFillStyle(e, a, i),
                        r.strokeStyle = e.stroke,
                        r.shadowColor = "black",
                        r.shadowBlur = 0,
                        r.shadowOffsetX = 0,
                        r.shadowOffsetY = 0;
                    let g = (h - c.fontSize) / 2;
                    h - c.fontSize < 0 && (g = 0);
                    for (let t = 0; t < a.length; t++)
                        d = e.strokeThickness / 2,
                        f = e.strokeThickness / 2 + t * h + c.ascent + g,
                        "right" === e.align ? d += u - l[t] : "center" === e.align && (d += (u - l[t]) / 2),
                        e.stroke && e.strokeThickness && this.drawLetterSpacing(a[t], d + e.padding, f + e.padding - p, !0),
                        e.fill && this.drawLetterSpacing(a[t], d + e.padding, f + e.padding - p)
                }
                this.updateTexture()
            }
            drawLetterSpacing(t, e, r, n=!1) {
                const i = this._style.letterSpacing;
                let s = !1;
                if (we.experimentalLetterSpacingSupported && (we.experimentalLetterSpacing ? (this.context.letterSpacing = `${i}px`,
                this.context.textLetterSpacing = `${i}px`,
                s = !0) : (this.context.letterSpacing = "0px",
                this.context.textLetterSpacing = "0px")),
                0 === i || s)
                    return void (n ? this.context.strokeText(t, e, r) : this.context.fillText(t, e, r));
                let o = e;
                const a = we.graphemeSegmenter(t);
                let h = this.context.measureText(t).width
                  , l = 0;
                for (let t = 0; t < a.length; ++t) {
                    const e = a[t];
                    n ? this.context.strokeText(e, o, r) : this.context.fillText(e, o, r);
                    let s = "";
                    for (let e = t + 1; e < a.length; ++e)
                        s += a[e];
                    l = this.context.measureText(s).width,
                    o += h - l + i,
                    h = l
                }
            }
            updateTexture() {
                const t = this.canvas;
                if (this._style.trim) {
                    const e = n.P6.trimCanvas(t);
                    e.data && (t.width = e.width,
                    t.height = e.height,
                    this.context.putImageData(e.data, 0, 0))
                }
                const e = this._texture
                  , r = this._style
                  , i = r.trim ? 0 : r.padding
                  , s = e.baseTexture;
                e.trim.width = e._frame.width = t.width / this._resolution,
                e.trim.height = e._frame.height = t.height / this._resolution,
                e.trim.x = -i,
                e.trim.y = -i,
                e.orig.width = e._frame.width - 2 * i,
                e.orig.height = e._frame.height - 2 * i,
                this._onTextureUpdate(),
                s.setRealSize(t.width, t.height, this._resolution),
                e.updateUvs(),
                this.dirty = !1
            }
            _render(t) {
                this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
                this.dirty = !0),
                this.updateText(!0),
                super._render(t)
            }
            updateTransform() {
                this.updateText(!0),
                super.updateTransform()
            }
            getBounds(t, e) {
                return this.updateText(!0),
                -1 === this._textureID && (t = !1),
                super.getBounds(t, e)
            }
            getLocalBounds(t) {
                return this.updateText(!0),
                super.getLocalBounds.call(this, t)
            }
            _calculateBounds() {
                this.calculateVertices(),
                this._bounds.addQuad(this.vertexData)
            }
            _generateFillStyle(t, e, r) {
                const n = t.fill;
                if (!Array.isArray(n))
                    return n;
                if (1 === n.length)
                    return n[0];
                let i;
                const s = t.dropShadow ? t.dropShadowDistance : 0
                  , o = t.padding || 0
                  , a = this.canvas.width / this._resolution - s - 2 * o
                  , h = this.canvas.height / this._resolution - s - 2 * o
                  , l = n.slice()
                  , u = t.fillGradientStops.slice();
                if (!u.length) {
                    const t = l.length + 1;
                    for (let e = 1; e < t; ++e)
                        u.push(e / t)
                }
                if (l.unshift(n[0]),
                u.unshift(0),
                l.push(n[n.length - 1]),
                u.push(1),
                t.fillGradientType === be.LINEAR_VERTICAL) {
                    i = this.context.createLinearGradient(a / 2, o, a / 2, h + o);
                    const n = r.fontProperties.fontSize + t.strokeThickness;
                    for (let t = 0; t < e.length; t++) {
                        const s = r.lineHeight * (t - 1) + n
                          , o = r.lineHeight * t;
                        let a = o;
                        t > 0 && s > o && (a = (o + s) / 2);
                        const c = o + n
                          , d = r.lineHeight * (t + 1);
                        let f = c;
                        t + 1 < e.length && d < c && (f = (c + d) / 2);
                        const p = (f - a) / h;
                        for (let t = 0; t < l.length; t++) {
                            let e = 0;
                            e = "number" == typeof u[t] ? u[t] : t / l.length;
                            let r = Math.min(1, Math.max(0, a / h + e * p));
                            r = Number(r.toFixed(5)),
                            i.addColorStop(r, l[t])
                        }
                    }
                } else {
                    i = this.context.createLinearGradient(o, h / 2, a + o, h / 2);
                    const t = l.length + 1;
                    let e = 1;
                    for (let r = 0; r < l.length; r++) {
                        let n;
                        n = "number" == typeof u[r] ? u[r] : e / t,
                        i.addColorStop(n, l[r]),
                        e++
                    }
                }
                return i
            }
            destroy(t) {
                "boolean" == typeof t && (t = {
                    children: t
                }),
                t = Object.assign({}, Ie, t),
                super.destroy(t),
                this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
                this.context = null,
                this.canvas = null,
                this._style = null
            }
            get width() {
                return this.updateText(!0),
                Math.abs(this.scale.x) * this._texture.orig.width
            }
            set width(t) {
                this.updateText(!0);
                const e = n.P6.sign(this.scale.x) || 1;
                this.scale.x = e * t / this._texture.orig.width,
                this._width = t
            }
            get height() {
                return this.updateText(!0),
                Math.abs(this.scale.y) * this._texture.orig.height
            }
            set height(t) {
                this.updateText(!0);
                const e = n.P6.sign(this.scale.y) || 1;
                this.scale.y = e * t / this._texture.orig.height,
                this._height = t
            }
            get style() {
                return this._style
            }
            set style(t) {
                t = t || {},
                this._style = t instanceof Ce ? t : new Ce(t),
                this.localStyleID = -1,
                this.dirty = !0
            }
            get text() {
                return this._text
            }
            set text(t) {
                t = String(null == t ? "" : t),
                this._text !== t && (this._text = t,
                this.dirty = !0)
            }
            get resolution() {
                return this._resolution
            }
            set resolution(t) {
                this._autoResolution = !1,
                this._resolution !== t && (this._resolution = t,
                this.dirty = !0)
            }
        }
        ;
        let De = Me;
        De.defaultAutoResolution = !0;
        class Oe {
            constructor(t) {
                this.maxItemsPerFrame = t,
                this.itemsLeft = 0
            }
            beginFrame() {
                this.itemsLeft = this.maxItemsPerFrame
            }
            allowedToUpload() {
                return this.itemsLeft-- > 0
            }
        }
        function Be(t, e) {
            let r = !1;
            if (t?._textures?.length)
                for (let i = 0; i < t._textures.length; i++)
                    if (t._textures[i]instanceof n.xE) {
                        const n = t._textures[i].baseTexture;
                        e.includes(n) || (e.push(n),
                        r = !0)
                    }
            return r
        }
        function ke(t, e) {
            if (t.baseTexture instanceof n.VL) {
                const r = t.baseTexture;
                return e.includes(r) || e.push(r),
                !0
            }
            return !1
        }
        function Le(t, e) {
            if (t._texture && t._texture instanceof n.xE) {
                const r = t._texture.baseTexture;
                return e.includes(r) || e.push(r),
                !0
            }
            return !1
        }
        function Ne(t, e) {
            return e instanceof De && (e.updateText(!0),
            !0)
        }
        function Fe(t, e) {
            if (e instanceof Ce) {
                const t = e.toFontString();
                return we.measureFont(t),
                !0
            }
            return !1
        }
        function Ue(t, e) {
            if (t instanceof De) {
                e.includes(t.style) || e.push(t.style),
                e.includes(t) || e.push(t);
                const r = t._texture.baseTexture;
                return e.includes(r) || e.push(r),
                !0
            }
            return !1
        }
        function Ge(t, e) {
            return t instanceof Ce && (e.includes(t) || e.push(t),
            !0)
        }
        const je = class {
            constructor(t) {
                this.limiter = new Oe(je.uploadsPerFrame),
                this.renderer = t,
                this.uploadHookHelper = null,
                this.queue = [],
                this.addHooks = [],
                this.uploadHooks = [],
                this.completes = [],
                this.ticking = !1,
                this.delayedTick = () => {
                    this.queue && this.prepareItems()
                }
                ,
                this.registerFindHook(Ue),
                this.registerFindHook(Ge),
                this.registerFindHook(Be),
                this.registerFindHook(ke),
                this.registerFindHook(Le),
                this.registerUploadHook(Ne),
                this.registerUploadHook(Fe)
            }
            upload(t) {
                return new Promise((e => {
                    t && this.add(t),
                    this.queue.length ? (this.completes.push(e),
                    this.ticking || (this.ticking = !0,
                    n.vB.system.addOnce(this.tick, this, n.uF.UTILITY))) : e()
                }
                ))
            }
            tick() {
                setTimeout(this.delayedTick, 0)
            }
            prepareItems() {
                for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
                    const t = this.queue[0];
                    let e = !1;
                    if (t && !t._destroyed)
                        for (let r = 0, n = this.uploadHooks.length; r < n; r++)
                            if (this.uploadHooks[r](this.uploadHookHelper, t)) {
                                this.queue.shift(),
                                e = !0;
                                break
                            }
                    e || this.queue.shift()
                }
                if (this.queue.length)
                    n.vB.system.addOnce(this.tick, this, n.uF.UTILITY);
                else {
                    this.ticking = !1;
                    const t = this.completes.slice(0);
                    this.completes.length = 0;
                    for (let e = 0, r = t.length; e < r; e++)
                        t[e]()
                }
            }
            registerFindHook(t) {
                return t && this.addHooks.push(t),
                this
            }
            registerUploadHook(t) {
                return t && this.uploadHooks.push(t),
                this
            }
            add(t) {
                for (let e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++)
                    ;
                if (t instanceof i.W2)
                    for (let e = t.children.length - 1; e >= 0; e--)
                        this.add(t.children[e]);
                return this
            }
            destroy() {
                this.ticking && n.vB.system.remove(this.tick, this),
                this.ticking = !1,
                this.addHooks = null,
                this.uploadHooks = null,
                this.renderer = null,
                this.completes = null,
                this.queue = null,
                this.limiter = null,
                this.uploadHookHelper = null
            }
        }
        ;
        let ze = je;
        function He(t, e) {
            return e instanceof n.VL && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e),
            !0)
        }
        function $e(t, e) {
            if (!(e instanceof ce))
                return !1;
            const {geometry: r} = e;
            e.finishPoly(),
            r.updateBatches();
            const {batches: n} = r;
            for (let e = 0; e < n.length; e++) {
                const {texture: r} = n[e].style;
                r && He(t, r.baseTexture)
            }
            return r.batchable || t.geometry.bind(r, e._resolveDirectShader(t)),
            !0
        }
        function Xe(t, e) {
            return t instanceof ce && (e.push(t),
            !0)
        }
        ze.uploadsPerFrame = 4,
        Object.defineProperties(n.Xd, {
            UPLOADS_PER_FRAME: {
                get() {
                    return ze.uploadsPerFrame
                },
                set(t) {
                    n.P6.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"),
                    ze.uploadsPerFrame = t
                }
            }
        });
        class Ve extends ze {
            constructor(t) {
                super(t),
                this.uploadHookHelper = this.renderer,
                this.registerFindHook(Xe),
                this.registerUploadHook(He),
                this.registerUploadHook($e)
            }
        }
        Ve.extension = {
            name: "prepare",
            type: n.nw.RendererSystem
        },
        n.Rw.add(Ve),
        new n.E9;
        var We = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
        const Ye = new n.y3;
        class qe extends n.bO {
            constructor(t) {
                super(t),
                t.runners.contextChange.add(this),
                this.quad = new n.ud,
                this.state = n.ZM.for2d()
            }
            contextChange() {
                const t = this.renderer
                  , e = {
                    globals: t.globalUniforms
                };
                this.simpleShader = n.ex.from(We, "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n", e),
                this.shader = t.context.webGLVersion > 1 ? n.ex.from("#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n", e) : n.ex.from(We, "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n", e)
            }
            render(t) {
                const e = this.renderer
                  , r = this.quad;
                let i = r.vertices;
                i[0] = i[6] = t._width * -t.anchor.x,
                i[1] = i[3] = t._height * -t.anchor.y,
                i[2] = i[4] = t._width * (1 - t.anchor.x),
                i[5] = i[7] = t._height * (1 - t.anchor.y);
                const s = t.uvRespectAnchor ? t.anchor.x : 0
                  , o = t.uvRespectAnchor ? t.anchor.y : 0;
                i = r.uvs,
                i[0] = i[6] = -s,
                i[1] = i[3] = -o,
                i[2] = i[4] = 1 - s,
                i[5] = i[7] = 1 - o,
                r.invalidate();
                const a = t._texture
                  , h = a.baseTexture
                  , l = h.alphaMode > 0
                  , u = t.tileTransform.localTransform
                  , c = t.uvMatrix;
                let d = h.isPowerOfTwo && a.frame.width === h.width && a.frame.height === h.height;
                d && (h._glTextures[e.CONTEXT_UID] ? d = h.wrapMode !== n.Nt.CLAMP : h.wrapMode === n.Nt.CLAMP && (h.wrapMode = n.Nt.REPEAT));
                const f = d ? this.simpleShader : this.shader
                  , p = a.width
                  , m = a.height
                  , g = t._width
                  , v = t._height;
                Ye.set(u.a * p / g, u.b * p / v, u.c * m / g, u.d * m / v, u.tx / g, u.ty / v),
                Ye.invert(),
                d ? Ye.prepend(c.mapCoord) : (f.uniforms.uMapCoord = c.mapCoord.toArray(!0),
                f.uniforms.uClampFrame = c.uClampFrame,
                f.uniforms.uClampOffset = c.uClampOffset),
                f.uniforms.uTransform = Ye.toArray(!0),
                f.uniforms.uColor = n.Il.shared.setValue(t.tint).premultiply(t.worldAlpha, l).toArray(f.uniforms.uColor),
                f.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0),
                f.uniforms.uSampler = a,
                e.shader.bind(f),
                e.geometry.bind(r),
                this.state.blendMode = n.P6.correctBlendMode(t.blendMode, l),
                e.state.set(this.state),
                e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
            }
        }
        qe.extension = {
            name: "tilingSprite",
            type: n.nw.RendererPlugin
        },
        n.Rw.add(qe);
        const Ke = class {
            constructor(t, e, r=null) {
                this.linkedSheets = [],
                this._texture = t instanceof n.xE ? t : null,
                this.baseTexture = t instanceof n.VL ? t : this._texture.baseTexture,
                this.textures = {},
                this.animations = {},
                this.data = e;
                const i = this.baseTexture.resource;
                this.resolution = this._updateResolution(r || (i ? i.url : null)),
                this._frames = this.data.frames,
                this._frameKeys = Object.keys(this._frames),
                this._batchIndex = 0,
                this._callback = null
            }
            _updateResolution(t=null) {
                const {scale: e} = this.data.meta;
                let r = n.P6.getResolutionOfUrl(t, null);
                return null === r && (r = parseFloat(e ?? "1")),
                1 !== r && this.baseTexture.setResolution(r),
                r
            }
            parse() {
                return new Promise((t => {
                    this._callback = t,
                    this._batchIndex = 0,
                    this._frameKeys.length <= Ke.BATCH_SIZE ? (this._processFrames(0),
                    this._processAnimations(),
                    this._parseComplete()) : this._nextBatch()
                }
                ))
            }
            _processFrames(t) {
                let e = t;
                const r = Ke.BATCH_SIZE;
                for (; e - t < r && e < this._frameKeys.length; ) {
                    const t = this._frameKeys[e]
                      , r = this._frames[t]
                      , i = r.frame;
                    if (i) {
                        let e = null
                          , s = null;
                        const o = !1 !== r.trimmed && r.sourceSize ? r.sourceSize : r.frame
                          , a = new n.Ae(0,0,Math.floor(o.w) / this.resolution,Math.floor(o.h) / this.resolution);
                        e = r.rotated ? new n.Ae(Math.floor(i.x) / this.resolution,Math.floor(i.y) / this.resolution,Math.floor(i.h) / this.resolution,Math.floor(i.w) / this.resolution) : new n.Ae(Math.floor(i.x) / this.resolution,Math.floor(i.y) / this.resolution,Math.floor(i.w) / this.resolution,Math.floor(i.h) / this.resolution),
                        !1 !== r.trimmed && r.spriteSourceSize && (s = new n.Ae(Math.floor(r.spriteSourceSize.x) / this.resolution,Math.floor(r.spriteSourceSize.y) / this.resolution,Math.floor(i.w) / this.resolution,Math.floor(i.h) / this.resolution)),
                        this.textures[t] = new n.xE(this.baseTexture,e,a,s,r.rotated ? 2 : 0,r.anchor,r.borders),
                        n.xE.addToCache(this.textures[t], t)
                    }
                    e++
                }
            }
            _processAnimations() {
                const t = this.data.animations || {};
                for (const e in t) {
                    this.animations[e] = [];
                    for (let r = 0; r < t[e].length; r++) {
                        const n = t[e][r];
                        this.animations[e].push(this.textures[n])
                    }
                }
            }
            _parseComplete() {
                const t = this._callback;
                this._callback = null,
                this._batchIndex = 0,
                t.call(this, this.textures)
            }
            _nextBatch() {
                this._processFrames(this._batchIndex * Ke.BATCH_SIZE),
                this._batchIndex++,
                setTimeout(( () => {
                    this._batchIndex * Ke.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(),
                    this._parseComplete())
                }
                ), 0)
            }
            destroy(t=!1) {
                for (const t in this.textures)
                    this.textures[t].destroy();
                this._frames = null,
                this._frameKeys = null,
                this.data = null,
                this.textures = null,
                t && (this._texture?.destroy(),
                this.baseTexture.destroy()),
                this._texture = null,
                this.baseTexture = null,
                this.linkedSheets = []
            }
        }
        ;
        let Ze = Ke;
        Ze.BATCH_SIZE = 1e3;
        const Je = ["jpg", "png", "jpeg", "avif", "webp"];
        function Qe(t, e, r) {
            const i = {};
            if (t.forEach((t => {
                i[t] = e
            }
            )),
            Object.keys(e.textures).forEach((t => {
                i[t] = e.textures[t]
            }
            )),
            !r) {
                const r = n.P6.path.dirname(t[0]);
                e.linkedSheets.forEach(( (t, n) => {
                    const s = Qe([`${r}/${e.data.meta.related_multi_packs[n]}`], t, !0);
                    Object.assign(i, s)
                }
                ))
            }
            return i
        }
        const tr = {
            extension: n.nw.Asset,
            cache: {
                test: t => t instanceof Ze,
                getCacheableAssets: (t, e) => Qe(t, e, !1)
            },
            resolver: {
                test: t => {
                    const e = t.split("?")[0].split(".")
                      , r = e.pop()
                      , n = e.pop();
                    return "json" === r && Je.includes(n)
                }
                ,
                parse: t => {
                    const e = t.split(".");
                    return {
                        resolution: parseFloat(n.Xd.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
                        format: e[e.length - 2],
                        src: t
                    }
                }
            },
            loader: {
                name: "spritesheetLoader",
                extension: {
                    type: n.nw.LoadParser,
                    priority: j.Normal
                },
                async testParse(t, e) {
                    return ".json" === n.P6.path.extname(e.src).toLowerCase() && !!t.frames
                },
                async parse(t, e, r) {
                    let i = n.P6.path.dirname(e.src);
                    i && i.lastIndexOf("/") !== i.length - 1 && (i += "/");
                    let s = i + t.meta.image;
                    s = vt(s, e.src);
                    const o = (await r.load([s]))[s]
                      , a = new Ze(o.baseTexture,t,e.src);
                    await a.parse();
                    const h = t?.meta?.related_multi_packs;
                    if (Array.isArray(h)) {
                        const t = [];
                        for (const n of h) {
                            if ("string" != typeof n)
                                continue;
                            let s = i + n;
                            e.data?.ignoreMultiPack || (s = vt(s, e.src),
                            t.push(r.load({
                                src: s,
                                data: {
                                    ignoreMultiPack: !0
                                }
                            })))
                        }
                        const n = await Promise.all(t);
                        a.linkedSheets = n,
                        n.forEach((t => {
                            t.linkedSheets = [a].concat(a.linkedSheets.filter((e => e !== t)))
                        }
                        ))
                    }
                    return a
                },
                unload(t) {
                    t.destroy(!0)
                }
            }
        };
        n.Rw.add(tr);
        class er {
            constructor() {
                this.info = [],
                this.common = [],
                this.page = [],
                this.char = [],
                this.kerning = [],
                this.distanceField = []
            }
        }
        class rr {
            static test(t) {
                return "string" == typeof t && t.startsWith("info face=")
            }
            static parse(t) {
                const e = t.match(/^[a-z]+\s+.+$/gm)
                  , r = {
                    info: [],
                    common: [],
                    page: [],
                    char: [],
                    chars: [],
                    kerning: [],
                    kernings: [],
                    distanceField: []
                };
                for (const t in e) {
                    const n = e[t].match(/^[a-z]+/gm)[0]
                      , i = e[t].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm)
                      , s = {};
                    for (const t in i) {
                        const e = i[t].split("=")
                          , r = e[0]
                          , n = e[1].replace(/"/gm, "")
                          , o = parseFloat(n)
                          , a = isNaN(o) ? n : o;
                        s[r] = a
                    }
                    r[n].push(s)
                }
                const n = new er;
                return r.info.forEach((t => n.info.push({
                    face: t.face,
                    size: parseInt(t.size, 10)
                }))),
                r.common.forEach((t => n.common.push({
                    lineHeight: parseInt(t.lineHeight, 10)
                }))),
                r.page.forEach((t => n.page.push({
                    id: parseInt(t.id, 10),
                    file: t.file
                }))),
                r.char.forEach((t => n.char.push({
                    id: parseInt(t.id, 10),
                    page: parseInt(t.page, 10),
                    x: parseInt(t.x, 10),
                    y: parseInt(t.y, 10),
                    width: parseInt(t.width, 10),
                    height: parseInt(t.height, 10),
                    xoffset: parseInt(t.xoffset, 10),
                    yoffset: parseInt(t.yoffset, 10),
                    xadvance: parseInt(t.xadvance, 10)
                }))),
                r.kerning.forEach((t => n.kerning.push({
                    first: parseInt(t.first, 10),
                    second: parseInt(t.second, 10),
                    amount: parseInt(t.amount, 10)
                }))),
                r.distanceField.forEach((t => n.distanceField.push({
                    distanceRange: parseInt(t.distanceRange, 10),
                    fieldType: t.fieldType
                }))),
                n
            }
        }
        class nr {
            static test(t) {
                const e = t;
                return "getElementsByTagName"in e && e.getElementsByTagName("page").length && null !== e.getElementsByTagName("info")[0].getAttribute("face")
            }
            static parse(t) {
                const e = new er
                  , r = t.getElementsByTagName("info")
                  , n = t.getElementsByTagName("common")
                  , i = t.getElementsByTagName("page")
                  , s = t.getElementsByTagName("char")
                  , o = t.getElementsByTagName("kerning")
                  , a = t.getElementsByTagName("distanceField");
                for (let t = 0; t < r.length; t++)
                    e.info.push({
                        face: r[t].getAttribute("face"),
                        size: parseInt(r[t].getAttribute("size"), 10)
                    });
                for (let t = 0; t < n.length; t++)
                    e.common.push({
                        lineHeight: parseInt(n[t].getAttribute("lineHeight"), 10)
                    });
                for (let t = 0; t < i.length; t++)
                    e.page.push({
                        id: parseInt(i[t].getAttribute("id"), 10) || 0,
                        file: i[t].getAttribute("file")
                    });
                for (let t = 0; t < s.length; t++) {
                    const r = s[t];
                    e.char.push({
                        id: parseInt(r.getAttribute("id"), 10),
                        page: parseInt(r.getAttribute("page"), 10) || 0,
                        x: parseInt(r.getAttribute("x"), 10),
                        y: parseInt(r.getAttribute("y"), 10),
                        width: parseInt(r.getAttribute("width"), 10),
                        height: parseInt(r.getAttribute("height"), 10),
                        xoffset: parseInt(r.getAttribute("xoffset"), 10),
                        yoffset: parseInt(r.getAttribute("yoffset"), 10),
                        xadvance: parseInt(r.getAttribute("xadvance"), 10)
                    })
                }
                for (let t = 0; t < o.length; t++)
                    e.kerning.push({
                        first: parseInt(o[t].getAttribute("first"), 10),
                        second: parseInt(o[t].getAttribute("second"), 10),
                        amount: parseInt(o[t].getAttribute("amount"), 10)
                    });
                for (let t = 0; t < a.length; t++)
                    e.distanceField.push({
                        fieldType: a[t].getAttribute("fieldType"),
                        distanceRange: parseInt(a[t].getAttribute("distanceRange"), 10)
                    });
                return e
            }
        }
        class ir {
            static test(t) {
                return !("string" != typeof t || !t.includes("<font>")) && nr.test(n.Xd.ADAPTER.parseXML(t))
            }
            static parse(t) {
                return nr.parse(n.Xd.ADAPTER.parseXML(t))
            }
        }
        const sr = [rr, nr, ir];
        function or(t, e, r, i, s, o, a) {
            const h = r.text
              , l = r.fontProperties;
            e.translate(i, s),
            e.scale(o, o);
            const u = a.strokeThickness / 2
              , c = -a.strokeThickness / 2;
            if (e.font = a.toFontString(),
            e.lineWidth = a.strokeThickness,
            e.textBaseline = a.textBaseline,
            e.lineJoin = a.lineJoin,
            e.miterLimit = a.miterLimit,
            e.fillStyle = function(t, e, r, n, i, s) {
                const o = r.fill;
                if (!Array.isArray(o))
                    return o;
                if (1 === o.length)
                    return o[0];
                let a;
                const h = r.dropShadow ? r.dropShadowDistance : 0
                  , l = r.padding || 0
                  , u = t.width / n - h - 2 * l
                  , c = t.height / n - h - 2 * l
                  , d = o.slice()
                  , f = r.fillGradientStops.slice();
                if (!f.length) {
                    const t = d.length + 1;
                    for (let e = 1; e < t; ++e)
                        f.push(e / t)
                }
                if (d.unshift(o[0]),
                f.unshift(0),
                d.push(o[o.length - 1]),
                f.push(1),
                r.fillGradientType === be.LINEAR_VERTICAL) {
                    a = e.createLinearGradient(u / 2, l, u / 2, c + l);
                    let t = 0;
                    const n = (s.fontProperties.fontSize + r.strokeThickness) / c;
                    for (let e = 0; e < i.length; e++) {
                        const r = s.lineHeight * e;
                        for (let e = 0; e < d.length; e++) {
                            let i = 0;
                            i = "number" == typeof f[e] ? f[e] : e / d.length;
                            const s = r / c + i * n;
                            let o = Math.max(t, s);
                            o = Math.min(o, 1),
                            a.addColorStop(o, d[e]),
                            t = o
                        }
                    }
                } else {
                    a = e.createLinearGradient(l, c / 2, u + l, c / 2);
                    const t = d.length + 1;
                    let r = 1;
                    for (let e = 0; e < d.length; e++) {
                        let n;
                        n = "number" == typeof f[e] ? f[e] : r / t,
                        a.addColorStop(n, d[e]),
                        r++
                    }
                }
                return a
            }(t, e, a, o, [h], r),
            e.strokeStyle = a.stroke,
            a.dropShadow) {
                const t = a.dropShadowColor
                  , r = a.dropShadowBlur * o
                  , i = a.dropShadowDistance * o;
                e.shadowColor = n.Il.shared.setValue(t).setAlpha(a.dropShadowAlpha).toRgbaString(),
                e.shadowBlur = r,
                e.shadowOffsetX = Math.cos(a.dropShadowAngle) * i,
                e.shadowOffsetY = Math.sin(a.dropShadowAngle) * i
            } else
                e.shadowColor = "black",
                e.shadowBlur = 0,
                e.shadowOffsetX = 0,
                e.shadowOffsetY = 0;
            a.stroke && a.strokeThickness && e.strokeText(h, u, c + r.lineHeight - l.descent),
            a.fill && e.fillText(h, u, c + r.lineHeight - l.descent),
            e.setTransform(1, 0, 0, 1, 0, 0),
            e.fillStyle = "rgba(0, 0, 0, 0)"
        }
        function ar(t) {
            return Array.from ? Array.from(t) : t.split("")
        }
        function hr(t) {
            return t.codePointAt ? t.codePointAt(0) : t.charCodeAt(0)
        }
        const lr = class {
            constructor(t, e, r) {
                const [i] = t.info
                  , [s] = t.common
                  , [o] = t.page
                  , [a] = t.distanceField
                  , h = n.P6.getResolutionOfUrl(o.file)
                  , l = {};
                this._ownsTextures = r,
                this.font = i.face,
                this.size = i.size,
                this.lineHeight = s.lineHeight / h,
                this.chars = {},
                this.pageTextures = l;
                for (let r = 0; r < t.page.length; r++) {
                    const {id: i, file: s} = t.page[r];
                    l[i] = e instanceof Array ? e[r] : e[s],
                    a?.fieldType && "none" !== a.fieldType && (l[i].baseTexture.alphaMode = n.iw.NO_PREMULTIPLIED_ALPHA,
                    l[i].baseTexture.mipmap = n.KI.OFF)
                }
                for (let e = 0; e < t.char.length; e++) {
                    const {id: r, page: i} = t.char[e];
                    let {x: s, y: o, width: a, height: u, xoffset: c, yoffset: d, xadvance: f} = t.char[e];
                    s /= h,
                    o /= h,
                    a /= h,
                    u /= h,
                    c /= h,
                    d /= h,
                    f /= h;
                    const p = new n.Ae(s + l[i].frame.x / h,o + l[i].frame.y / h,a,u);
                    this.chars[r] = {
                        xOffset: c,
                        yOffset: d,
                        xAdvance: f,
                        kerning: {},
                        texture: new n.xE(l[i].baseTexture,p),
                        page: i
                    }
                }
                for (let e = 0; e < t.kerning.length; e++) {
                    let {first: r, second: n, amount: i} = t.kerning[e];
                    r /= h,
                    n /= h,
                    i /= h,
                    this.chars[n] && (this.chars[n].kerning[r] = i)
                }
                this.distanceFieldRange = a?.distanceRange,
                this.distanceFieldType = a?.fieldType?.toLowerCase() ?? "none"
            }
            destroy() {
                for (const t in this.chars)
                    this.chars[t].texture.destroy(),
                    this.chars[t].texture = null;
                for (const t in this.pageTextures)
                    this._ownsTextures && this.pageTextures[t].destroy(!0),
                    this.pageTextures[t] = null;
                this.chars = null,
                this.pageTextures = null
            }
            static install(t, e, r) {
                let i;
                if (t instanceof er)
                    i = t;
                else {
                    const e = function(t) {
                        for (let e = 0; e < sr.length; e++)
                            if (sr[e].test(t))
                                return sr[e];
                        return null
                    }(t);
                    if (!e)
                        throw new Error("Unrecognized data format for font.");
                    i = e.parse(t)
                }
                e instanceof n.xE && (e = [e]);
                const s = new lr(i,e,r);
                return lr.available[s.font] = s,
                s
            }
            static uninstall(t) {
                const e = lr.available[t];
                if (!e)
                    throw new Error(`No font found named '${t}'`);
                e.destroy(),
                delete lr.available[t]
            }
            static from(t, e, r) {
                if (!t)
                    throw new Error("[BitmapFont] Property `name` is required.");
                const {chars: i, padding: s, resolution: o, textureWidth: a, textureHeight: h, ...l} = Object.assign({}, lr.defaultOptions, r)
                  , u = function(t) {
                    "string" == typeof t && (t = [t]);
                    const e = [];
                    for (let r = 0, n = t.length; r < n; r++) {
                        const n = t[r];
                        if (Array.isArray(n)) {
                            if (2 !== n.length)
                                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${n.length}.`);
                            const t = n[0].charCodeAt(0)
                              , r = n[1].charCodeAt(0);
                            if (r < t)
                                throw new Error("[BitmapFont]: Invalid character range.");
                            for (let n = t, i = r; n <= i; n++)
                                e.push(String.fromCharCode(n))
                        } else
                            e.push(...ar(n))
                    }
                    if (0 === e.length)
                        throw new Error("[BitmapFont]: Empty set when resolving characters.");
                    return e
                }(i)
                  , c = e instanceof Ce ? e : new Ce(e)
                  , d = a
                  , f = new er;
                f.info[0] = {
                    face: c.fontFamily,
                    size: c.fontSize
                },
                f.common[0] = {
                    lineHeight: c.fontSize
                };
                let p, m, g, v = 0, y = 0, _ = 0;
                const x = []
                  , b = [];
                for (let t = 0; t < u.length; t++) {
                    p || (p = n.Xd.ADAPTER.createCanvas(),
                    p.width = a,
                    p.height = h,
                    m = p.getContext("2d"),
                    g = new n.VL(p,{
                        resolution: o,
                        ...l
                    }),
                    x.push(g),
                    b.push(new n.xE(g)),
                    f.page.push({
                        id: b.length - 1,
                        file: ""
                    }));
                    const e = u[t]
                      , r = we.measureText(e, c, !1, p)
                      , i = r.width
                      , E = Math.ceil(r.height)
                      , T = Math.ceil(("italic" === c.fontStyle ? 2 : 1) * i);
                    if (y >= h - E * o) {
                        if (0 === y)
                            throw new Error(`[BitmapFont] textureHeight ${h}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${e}')`);
                        --t,
                        p = null,
                        m = null,
                        g = null,
                        y = 0,
                        v = 0,
                        _ = 0;
                        continue
                    }
                    if (_ = Math.max(E + r.fontProperties.descent, _),
                    T * o + v >= d) {
                        if (0 === v)
                            throw new Error(`[BitmapFont] textureWidth ${a}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${e}')`);
                        --t,
                        y += _ * o,
                        y = Math.ceil(y),
                        v = 0,
                        _ = 0;
                        continue
                    }
                    or(p, m, r, v, y, o, c);
                    const w = hr(r.text);
                    f.char.push({
                        id: w,
                        page: b.length - 1,
                        x: v / o,
                        y: y / o,
                        width: T,
                        height: E,
                        xoffset: 0,
                        yoffset: 0,
                        xadvance: i - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0)
                    }),
                    v += (T + 2 * s) * o,
                    v = Math.ceil(v)
                }
                for (let t = 0, e = u.length; t < e; t++) {
                    const r = u[t];
                    for (let t = 0; t < e; t++) {
                        const e = u[t]
                          , n = m.measureText(r).width
                          , i = m.measureText(e).width
                          , s = m.measureText(r + e).width - (n + i);
                        s && f.kerning.push({
                            first: hr(r),
                            second: hr(e),
                            amount: s
                        })
                    }
                }
                const E = new lr(f,b,!0);
                return void 0 !== lr.available[t] && lr.uninstall(t),
                lr.available[t] = E,
                E
            }
        }
        ;
        let ur = lr;
        ur.ALPHA = [["a", "z"], ["A", "Z"], " "],
        ur.NUMERIC = [["0", "9"]],
        ur.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "],
        ur.ASCII = [[" ", "~"]],
        ur.defaultOptions = {
            resolution: 1,
            textureWidth: 512,
            textureHeight: 512,
            padding: 4,
            chars: lr.ALPHANUMERIC
        },
        ur.available = {};
        const cr = []
          , dr = []
          , fr = []
          , pr = class extends i.W2 {
            constructor(t, e={}) {
                super();
                const {align: r, tint: i, maxWidth: s, letterSpacing: o, fontName: a, fontSize: h} = Object.assign({}, pr.styleDefaults, e);
                if (!ur.available[a])
                    throw new Error(`Missing BitmapFont "${a}"`);
                this._activePagesMeshData = [],
                this._textWidth = 0,
                this._textHeight = 0,
                this._align = r,
                this._tintColor = new n.Il(i),
                this._font = void 0,
                this._fontName = a,
                this._fontSize = h,
                this.text = t,
                this._maxWidth = s,
                this._maxLineHeight = 0,
                this._letterSpacing = o,
                this._anchor = new n.AB(( () => {
                    this.dirty = !0
                }
                ),this,0,0),
                this._roundPixels = n.Xd.ROUND_PIXELS,
                this.dirty = !0,
                this._resolution = n.Xd.RESOLUTION,
                this._autoResolution = !0,
                this._textureCache = {}
            }
            updateText() {
                const t = ur.available[this._fontName]
                  , e = this.fontSize
                  , r = e / t.size
                  , i = new n.E9
                  , s = []
                  , o = []
                  , a = []
                  , h = ar(this._text.replace(/(?:\r\n|\r)/g, "\n") || " ")
                  , l = this._maxWidth * t.size / e
                  , u = "none" === t.distanceFieldType ? cr : dr;
                let c = null
                  , d = 0
                  , f = 0
                  , p = 0
                  , m = -1
                  , g = 0
                  , v = 0
                  , y = 0
                  , _ = 0;
                for (let e = 0; e < h.length; e++) {
                    const r = h[e]
                      , u = hr(r);
                    if (/(?:\s)/.test(r) && (m = e,
                    g = d,
                    _++),
                    "\r" === r || "\n" === r) {
                        o.push(d),
                        a.push(-1),
                        f = Math.max(f, d),
                        ++p,
                        ++v,
                        i.x = 0,
                        i.y += t.lineHeight,
                        c = null,
                        _ = 0;
                        continue
                    }
                    const x = t.chars[u];
                    if (!x)
                        continue;
                    c && x.kerning[c] && (i.x += x.kerning[c]);
                    const b = fr.pop() || {
                        texture: n.xE.EMPTY,
                        line: 0,
                        charCode: 0,
                        prevSpaces: 0,
                        position: new n.E9
                    };
                    b.texture = x.texture,
                    b.line = p,
                    b.charCode = u,
                    b.position.x = Math.round(i.x + x.xOffset + this._letterSpacing / 2),
                    b.position.y = Math.round(i.y + x.yOffset),
                    b.prevSpaces = _,
                    s.push(b),
                    d = b.position.x + Math.max(x.xAdvance - x.xOffset, x.texture.orig.width),
                    i.x += x.xAdvance + this._letterSpacing,
                    y = Math.max(y, x.yOffset + x.texture.height),
                    c = u,
                    -1 !== m && l > 0 && i.x > l && (++v,
                    n.P6.removeItems(s, 1 + m - v, 1 + e - m),
                    e = m,
                    m = -1,
                    o.push(g),
                    a.push(s.length > 0 ? s[s.length - 1].prevSpaces : 0),
                    f = Math.max(f, g),
                    p++,
                    i.x = 0,
                    i.y += t.lineHeight,
                    c = null,
                    _ = 0)
                }
                const x = h[h.length - 1];
                "\r" !== x && "\n" !== x && (/(?:\s)/.test(x) && (d = g),
                o.push(d),
                f = Math.max(f, d),
                a.push(-1));
                const b = [];
                for (let t = 0; t <= p; t++) {
                    let e = 0;
                    "right" === this._align ? e = f - o[t] : "center" === this._align ? e = (f - o[t]) / 2 : "justify" === this._align && (e = a[t] < 0 ? 0 : (f - o[t]) / a[t]),
                    b.push(e)
                }
                const E = s.length
                  , T = {}
                  , w = []
                  , S = this._activePagesMeshData;
                u.push(...S);
                for (let e = 0; e < E; e++) {
                    const r = s[e].texture
                      , i = r.baseTexture.uid;
                    if (!T[i]) {
                        let e = u.pop();
                        if (!e) {
                            const r = new ve;
                            let i, s;
                            "none" === t.distanceFieldType ? (i = new ye(n.xE.EMPTY),
                            s = n.T$.NORMAL) : (i = new ye(n.xE.EMPTY,{
                                program: n.$r.from("// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n", "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n"),
                                uniforms: {
                                    uFWidth: 0
                                }
                            }),
                            s = n.T$.NORMAL_NPM);
                            const o = new ge(r,i);
                            o.blendMode = s,
                            e = {
                                index: 0,
                                indexCount: 0,
                                vertexCount: 0,
                                uvsCount: 0,
                                total: 0,
                                mesh: o,
                                vertices: null,
                                uvs: null,
                                indices: null
                            }
                        }
                        e.index = 0,
                        e.indexCount = 0,
                        e.vertexCount = 0,
                        e.uvsCount = 0,
                        e.total = 0;
                        const {_textureCache: s} = this;
                        s[i] = s[i] || new n.xE(r.baseTexture),
                        e.mesh.texture = s[i],
                        e.mesh.tint = this._tintColor.value,
                        w.push(e),
                        T[i] = e
                    }
                    T[i].total++
                }
                for (let t = 0; t < S.length; t++)
                    w.includes(S[t]) || this.removeChild(S[t].mesh);
                for (let t = 0; t < w.length; t++)
                    w[t].mesh.parent !== this && this.addChild(w[t].mesh);
                this._activePagesMeshData = w;
                for (const t in T) {
                    const e = T[t]
                      , r = e.total;
                    if (!(e.indices?.length > 6 * r) || e.vertices.length < 2 * ge.BATCHABLE_SIZE)
                        e.vertices = new Float32Array(8 * r),
                        e.uvs = new Float32Array(8 * r),
                        e.indices = new Uint16Array(6 * r);
                    else {
                        const t = e.total
                          , r = e.vertices;
                        for (let e = 4 * t * 2; e < r.length; e++)
                            r[e] = 0
                    }
                    e.mesh.size = 6 * r
                }
                for (let t = 0; t < E; t++) {
                    const e = s[t];
                    let n = e.position.x + b[e.line] * ("justify" === this._align ? e.prevSpaces : 1);
                    this._roundPixels && (n = Math.round(n));
                    const i = n * r
                      , o = e.position.y * r
                      , a = e.texture
                      , h = T[a.baseTexture.uid]
                      , l = a.frame
                      , u = a._uvs
                      , c = h.index++;
                    h.indices[6 * c + 0] = 0 + 4 * c,
                    h.indices[6 * c + 1] = 1 + 4 * c,
                    h.indices[6 * c + 2] = 2 + 4 * c,
                    h.indices[6 * c + 3] = 0 + 4 * c,
                    h.indices[6 * c + 4] = 2 + 4 * c,
                    h.indices[6 * c + 5] = 3 + 4 * c,
                    h.vertices[8 * c + 0] = i,
                    h.vertices[8 * c + 1] = o,
                    h.vertices[8 * c + 2] = i + l.width * r,
                    h.vertices[8 * c + 3] = o,
                    h.vertices[8 * c + 4] = i + l.width * r,
                    h.vertices[8 * c + 5] = o + l.height * r,
                    h.vertices[8 * c + 6] = i,
                    h.vertices[8 * c + 7] = o + l.height * r,
                    h.uvs[8 * c + 0] = u.x0,
                    h.uvs[8 * c + 1] = u.y0,
                    h.uvs[8 * c + 2] = u.x1,
                    h.uvs[8 * c + 3] = u.y1,
                    h.uvs[8 * c + 4] = u.x2,
                    h.uvs[8 * c + 5] = u.y2,
                    h.uvs[8 * c + 6] = u.x3,
                    h.uvs[8 * c + 7] = u.y3
                }
                this._textWidth = f * r,
                this._textHeight = (i.y + t.lineHeight) * r;
                for (const t in T) {
                    const e = T[t];
                    if (0 !== this.anchor.x || 0 !== this.anchor.y) {
                        let t = 0;
                        const r = this._textWidth * this.anchor.x
                          , n = this._textHeight * this.anchor.y;
                        for (let i = 0; i < e.total; i++)
                            e.vertices[t++] -= r,
                            e.vertices[t++] -= n,
                            e.vertices[t++] -= r,
                            e.vertices[t++] -= n,
                            e.vertices[t++] -= r,
                            e.vertices[t++] -= n,
                            e.vertices[t++] -= r,
                            e.vertices[t++] -= n
                    }
                    this._maxLineHeight = y * r;
                    const n = e.mesh.geometry.getBuffer("aVertexPosition")
                      , i = e.mesh.geometry.getBuffer("aTextureCoord")
                      , s = e.mesh.geometry.getIndex();
                    n.data = e.vertices,
                    i.data = e.uvs,
                    s.data = e.indices,
                    n.update(),
                    i.update(),
                    s.update()
                }
                for (let t = 0; t < s.length; t++)
                    fr.push(s[t]);
                this._font = t,
                this.dirty = !1
            }
            updateTransform() {
                this.validate(),
                this.containerUpdateTransform()
            }
            _render(t) {
                this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
                this.dirty = !0);
                const {distanceFieldRange: e, distanceFieldType: r, size: n} = ur.available[this._fontName];
                if ("none" !== r) {
                    const {a: r, b: i, c: s, d: o} = this.worldTransform
                      , a = Math.sqrt(r * r + i * i)
                      , h = Math.sqrt(s * s + o * o)
                      , l = (Math.abs(a) + Math.abs(h)) / 2
                      , u = this.fontSize / n
                      , c = t._view.resolution;
                    for (const t of this._activePagesMeshData)
                        t.mesh.shader.uniforms.uFWidth = l * e * u * c
                }
                super._render(t)
            }
            getLocalBounds() {
                return this.validate(),
                super.getLocalBounds()
            }
            validate() {
                const t = ur.available[this._fontName];
                if (!t)
                    throw new Error(`Missing BitmapFont "${this._fontName}"`);
                this._font !== t && (this.dirty = !0),
                this.dirty && this.updateText()
            }
            get tint() {
                return this._tintColor.value
            }
            set tint(t) {
                if (this.tint !== t) {
                    this._tintColor.setValue(t);
                    for (let e = 0; e < this._activePagesMeshData.length; e++)
                        this._activePagesMeshData[e].mesh.tint = t
                }
            }
            get align() {
                return this._align
            }
            set align(t) {
                this._align !== t && (this._align = t,
                this.dirty = !0)
            }
            get fontName() {
                return this._fontName
            }
            set fontName(t) {
                if (!ur.available[t])
                    throw new Error(`Missing BitmapFont "${t}"`);
                this._fontName !== t && (this._fontName = t,
                this.dirty = !0)
            }
            get fontSize() {
                return this._fontSize ?? ur.available[this._fontName].size
            }
            set fontSize(t) {
                this._fontSize !== t && (this._fontSize = t,
                this.dirty = !0)
            }
            get anchor() {
                return this._anchor
            }
            set anchor(t) {
                "number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t)
            }
            get text() {
                return this._text
            }
            set text(t) {
                t = String(null == t ? "" : t),
                this._text !== t && (this._text = t,
                this.dirty = !0)
            }
            get maxWidth() {
                return this._maxWidth
            }
            set maxWidth(t) {
                this._maxWidth !== t && (this._maxWidth = t,
                this.dirty = !0)
            }
            get maxLineHeight() {
                return this.validate(),
                this._maxLineHeight
            }
            get textWidth() {
                return this.validate(),
                this._textWidth
            }
            get letterSpacing() {
                return this._letterSpacing
            }
            set letterSpacing(t) {
                this._letterSpacing !== t && (this._letterSpacing = t,
                this.dirty = !0)
            }
            get roundPixels() {
                return this._roundPixels
            }
            set roundPixels(t) {
                t !== this._roundPixels && (this._roundPixels = t,
                this.dirty = !0)
            }
            get textHeight() {
                return this.validate(),
                this._textHeight
            }
            get resolution() {
                return this._resolution
            }
            set resolution(t) {
                this._autoResolution = !1,
                this._resolution !== t && (this._resolution = t,
                this.dirty = !0)
            }
            destroy(t) {
                const {_textureCache: e} = this
                  , r = "none" === ur.available[this._fontName].distanceFieldType ? cr : dr;
                r.push(...this._activePagesMeshData);
                for (const t of this._activePagesMeshData)
                    this.removeChild(t.mesh);
                this._activePagesMeshData = [],
                r.filter((t => e[t.mesh.texture.baseTexture.uid])).forEach((t => {
                    t.mesh.texture = n.xE.EMPTY
                }
                ));
                for (const t in e)
                    e[t].destroy(),
                    delete e[t];
                this._font = null,
                this._tintColor = null,
                this._textureCache = null,
                super.destroy(t)
            }
        }
        ;
        pr.styleDefaults = {
            align: "left",
            tint: 16777215,
            maxWidth: 0,
            letterSpacing: 0
        };
        const mr = [".xml", ".fnt"]
          , gr = {
            extension: {
                type: n.nw.LoadParser,
                priority: j.Normal
            },
            name: "loadBitmapFont",
            test(t) {
                return mr.includes(n.P6.path.extname(t).toLowerCase())
            },
            async testParse(t) {
                return rr.test(t) || ir.test(t)
            },
            async parse(t, e, r) {
                const i = rr.test(t) ? rr.parse(t) : ir.parse(t)
                  , {src: s} = e
                  , {page: o} = i
                  , a = [];
                for (let t = 0; t < o.length; ++t) {
                    const e = o[t].file;
                    let r = n.P6.path.join(n.P6.path.dirname(s), e);
                    r = vt(r, s),
                    a.push(r)
                }
                const h = await r.load(a)
                  , l = a.map((t => h[t]));
                return ur.install(i, l, !0)
            },
            async load(t, e) {
                return (await n.Xd.ADAPTER.fetch(t)).text()
            },
            unload(t) {
                t.destroy()
            }
        };
        n.Rw.add(gr);
        const vr = class extends Ce {
            constructor() {
                super(...arguments),
                this._fonts = [],
                this._overrides = [],
                this._stylesheet = "",
                this.fontsDirty = !1
            }
            static from(t) {
                return new vr(Object.keys(vr.defaultOptions).reduce(( (e, r) => ({
                    ...e,
                    [r]: t[r]
                })), {}))
            }
            cleanFonts() {
                this._fonts.length > 0 && (this._fonts.forEach((t => {
                    URL.revokeObjectURL(t.src),
                    t.refs--,
                    0 === t.refs && (t.fontFace && document.fonts.delete(t.fontFace),
                    delete vr.availableFonts[t.originalUrl])
                }
                )),
                this.fontFamily = "Arial",
                this._fonts.length = 0,
                this.styleID++,
                this.fontsDirty = !0)
            }
            loadFont(t, e={}) {
                const {availableFonts: r} = vr;
                if (r[t]) {
                    const e = r[t];
                    return this._fonts.push(e),
                    e.refs++,
                    this.styleID++,
                    this.fontsDirty = !0,
                    Promise.resolve()
                }
                return n.Xd.ADAPTER.fetch(t).then((t => t.blob())).then((async t => new Promise(( (e, r) => {
                    const n = URL.createObjectURL(t)
                      , i = new FileReader;
                    i.onload = () => e([n, i.result]),
                    i.onerror = r,
                    i.readAsDataURL(t)
                }
                )))).then((async ([i,s]) => {
                    const o = Object.assign({
                        family: n.P6.path.basename(t, n.P6.path.extname(t)),
                        weight: "normal",
                        style: "normal",
                        src: i,
                        dataSrc: s,
                        refs: 1,
                        originalUrl: t,
                        fontFace: null
                    }, e);
                    r[t] = o,
                    this._fonts.push(o),
                    this.styleID++;
                    const a = new FontFace(o.family,`url(${o.src})`,{
                        weight: o.weight,
                        style: o.style
                    });
                    o.fontFace = a,
                    await a.load(),
                    document.fonts.add(a),
                    await document.fonts.ready,
                    this.styleID++,
                    this.fontsDirty = !0
                }
                ))
            }
            addOverride(...t) {
                const e = t.filter((t => !this._overrides.includes(t)));
                e.length > 0 && (this._overrides.push(...e),
                this.styleID++)
            }
            removeOverride(...t) {
                const e = t.filter((t => this._overrides.includes(t)));
                e.length > 0 && (this._overrides = this._overrides.filter((t => !e.includes(t))),
                this.styleID++)
            }
            toCSS(t) {
                return [`transform: scale(${t})`, "transform-origin: top left", "display: inline-block", `color: ${this.normalizeColor(this.fill)}`, `font-size: ${this.fontSize}px`, `font-family: ${this.fontFamily}`, `font-weight: ${this.fontWeight}`, `font-style: ${this.fontStyle}`, `font-variant: ${this.fontVariant}`, `letter-spacing: ${this.letterSpacing}px`, `text-align: ${this.align}`, `padding: ${this.padding}px`, `white-space: ${this.whiteSpace}`, ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [], ...this.wordWrap ? ["word-wrap: " + (this.breakWords ? "break-all" : "break-word"), `max-width: ${this.wordWrapWidth}px`] : [], ...this.strokeThickness ? [`-webkit-text-stroke-width: ${this.strokeThickness}px`, `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`, `text-stroke-width: ${this.strokeThickness}px`, `text-stroke-color: ${this.normalizeColor(this.stroke)}`, "paint-order: stroke"] : [], ...this.dropShadow ? [this.dropShadowToCSS()] : [], ...this._overrides].join(";")
            }
            toGlobalCSS() {
                return this._fonts.reduce(( (t, e) => `${t}\n            @font-face {\n                font-family: "${e.family}";\n                src: url('${e.dataSrc}');\n                font-weight: ${e.weight};\n                font-style: ${e.style}; \n            }`), this._stylesheet)
            }
            get stylesheet() {
                return this._stylesheet
            }
            set stylesheet(t) {
                this._stylesheet !== t && (this._stylesheet = t,
                this.styleID++)
            }
            normalizeColor(t) {
                return Array.isArray(t) && (t = n.P6.rgb2hex(t)),
                "number" == typeof t ? n.P6.hex2string(t) : t
            }
            dropShadowToCSS() {
                let t = this.normalizeColor(this.dropShadowColor);
                const e = this.dropShadowAlpha
                  , r = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance)
                  , n = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
                t.startsWith("#") && e < 1 && (t += (255 * e | 0).toString(16).padStart(2, "0"));
                const i = `${r}px ${n}px`;
                return this.dropShadowBlur > 0 ? `text-shadow: ${i} ${this.dropShadowBlur}px ${t}` : `text-shadow: ${i} ${t}`
            }
            reset() {
                Object.assign(this, vr.defaultOptions)
            }
            onBeforeDraw() {
                const {fontsDirty: t} = this;
                return this.fontsDirty = !1,
                this.isSafari && this._fonts.length > 0 && t ? new Promise((t => setTimeout(t, 100))) : Promise.resolve()
            }
            get isSafari() {
                const {userAgent: t} = n.Xd.ADAPTER.getNavigator();
                return /^((?!chrome|android).)*safari/i.test(t)
            }
            set fillGradientStops(t) {
                console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText")
            }
            get fillGradientStops() {
                return super.fillGradientStops
            }
            set fillGradientType(t) {
                console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText")
            }
            get fillGradientType() {
                return super.fillGradientType
            }
            set miterLimit(t) {
                console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText")
            }
            get miterLimit() {
                return super.miterLimit
            }
            set trim(t) {
                console.warn("[HTMLTextStyle] trim is not supported by HTMLText")
            }
            get trim() {
                return super.trim
            }
            set textBaseline(t) {
                console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText")
            }
            get textBaseline() {
                return super.textBaseline
            }
            set leading(t) {
                console.warn("[HTMLTextStyle] leading is not supported by HTMLText")
            }
            get leading() {
                return super.leading
            }
            set lineJoin(t) {
                console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText")
            }
            get lineJoin() {
                return super.lineJoin
            }
        }
        ;
        let yr = vr;
        yr.availableFonts = {},
        yr.defaultOptions = {
            align: "left",
            breakWords: !1,
            dropShadow: !1,
            dropShadowAlpha: 1,
            dropShadowAngle: Math.PI / 6,
            dropShadowBlur: 0,
            dropShadowColor: "black",
            dropShadowDistance: 5,
            fill: "black",
            fontFamily: "Arial",
            fontSize: 26,
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            letterSpacing: 0,
            lineHeight: 0,
            padding: 0,
            stroke: "black",
            strokeThickness: 0,
            whiteSpace: "normal",
            wordWrap: !1,
            wordWrapWidth: 100
        };
        const _r = class extends a {
            constructor(t="", e={}) {
                super(n.xE.EMPTY),
                this._text = null,
                this._style = null,
                this._autoResolution = !0,
                this._loading = !1,
                this.localStyleID = -1,
                this.dirty = !1,
                this.ownsStyle = !1;
                const r = new Image
                  , i = n.xE.from(r, {
                    scaleMode: n.Xd.SCALE_MODE,
                    resourceOptions: {
                        autoLoad: !1
                    }
                });
                i.orig = new n.Ae,
                i.trim = new n.Ae,
                this.texture = i;
                const s = "http://www.w3.org/2000/svg"
                  , o = "http://www.w3.org/1999/xhtml"
                  , a = document.createElementNS(s, "svg")
                  , h = document.createElementNS(s, "foreignObject")
                  , l = document.createElementNS(o, "div")
                  , u = document.createElementNS(o, "style");
                h.setAttribute("width", "10000"),
                h.setAttribute("height", "10000"),
                h.style.overflow = "hidden",
                a.appendChild(h),
                this.maxWidth = _r.defaultMaxWidth,
                this.maxHeight = _r.defaultMaxHeight,
                this._domElement = l,
                this._styleElement = u,
                this._svgRoot = a,
                this._foreignObject = h,
                this._foreignObject.appendChild(u),
                this._foreignObject.appendChild(l),
                this._image = r,
                this._loadImage = new Image,
                this._autoResolution = _r.defaultAutoResolution,
                this._resolution = _r.defaultResolution ?? n.Xd.RESOLUTION,
                this.text = t,
                this.style = e
            }
            measureText(t) {
                const {text: e, style: r, resolution: n} = Object.assign({
                    text: this._text,
                    style: this._style,
                    resolution: this._resolution
                }, t);
                Object.assign(this._domElement, {
                    innerHTML: e,
                    style: r.toCSS(n)
                }),
                this._styleElement.textContent = r.toGlobalCSS(),
                document.body.appendChild(this._svgRoot);
                const i = this._domElement.getBoundingClientRect();
                this._svgRoot.remove();
                const s = Math.min(this.maxWidth, Math.ceil(i.width))
                  , o = Math.min(this.maxHeight, Math.ceil(i.height));
                return this._svgRoot.setAttribute("width", s.toString()),
                this._svgRoot.setAttribute("height", o.toString()),
                e !== this._text && (this._domElement.innerHTML = this._text),
                r !== this._style && (Object.assign(this._domElement, {
                    style: this._style?.toCSS(n)
                }),
                this._styleElement.textContent = this._style?.toGlobalCSS()),
                {
                    width: s + 2 * r.padding,
                    height: o + 2 * r.padding
                }
            }
            async updateText(t=!0) {
                const {style: e, _image: r, _loadImage: n} = this;
                if (this.localStyleID !== e.styleID && (this.dirty = !0,
                this.localStyleID = e.styleID),
                !this.dirty && t)
                    return;
                const {width: i, height: s} = this.measureText();
                r.width = n.width = Math.ceil(Math.max(1, i)),
                r.height = n.height = Math.ceil(Math.max(1, s)),
                this._loading || (this._loading = !0,
                await new Promise((t => {
                    n.onload = async () => {
                        await e.onBeforeDraw(),
                        this._loading = !1,
                        r.src = n.src,
                        n.onload = null,
                        n.src = "",
                        this.updateTexture(),
                        t()
                    }
                    ;
                    const i = (new XMLSerializer).serializeToString(this._svgRoot);
                    n.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(i)}`
                }
                )))
            }
            get source() {
                return this._image
            }
            updateTexture() {
                const {style: t, texture: e, _image: r, resolution: n} = this
                  , {padding: i} = t
                  , {baseTexture: s} = e;
                e.trim.width = e._frame.width = r.width / n,
                e.trim.height = e._frame.height = r.height / n,
                e.trim.x = -i,
                e.trim.y = -i,
                e.orig.width = e._frame.width - 2 * i,
                e.orig.height = e._frame.height - 2 * i,
                this._onTextureUpdate(),
                s.setRealSize(r.width, r.height, n),
                this.dirty = !1
            }
            _render(t) {
                this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
                this.dirty = !0),
                this.updateText(!0),
                super._render(t)
            }
            _renderCanvas(t) {
                this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
                this.dirty = !0),
                this.updateText(!0),
                super._renderCanvas(t)
            }
            getLocalBounds(t) {
                return this.updateText(!0),
                super.getLocalBounds(t)
            }
            _calculateBounds() {
                this.updateText(!0),
                this.calculateVertices(),
                this._bounds.addQuad(this.vertexData)
            }
            _onStyleChange() {
                this.dirty = !0
            }
            destroy(t) {
                "boolean" == typeof t && (t = {
                    children: t
                }),
                t = Object.assign({}, _r.defaultDestroyOptions, t),
                super.destroy(t);
                const e = null;
                this.ownsStyle && this._style?.cleanFonts(),
                this._style = e,
                this._svgRoot?.remove(),
                this._svgRoot = e,
                this._domElement?.remove(),
                this._domElement = e,
                this._foreignObject?.remove(),
                this._foreignObject = e,
                this._styleElement?.remove(),
                this._styleElement = e,
                this._loadImage.src = "",
                this._loadImage.onload = null,
                this._loadImage = e,
                this._image.src = "",
                this._image = e
            }
            get width() {
                return this.updateText(!0),
                Math.abs(this.scale.x) * this._image.width / this.resolution
            }
            set width(t) {
                this.updateText(!0);
                const e = n.P6.sign(this.scale.x) || 1;
                this.scale.x = e * t / this._image.width / this.resolution,
                this._width = t
            }
            get height() {
                return this.updateText(!0),
                Math.abs(this.scale.y) * this._image.height / this.resolution
            }
            set height(t) {
                this.updateText(!0);
                const e = n.P6.sign(this.scale.y) || 1;
                this.scale.y = e * t / this._image.height / this.resolution,
                this._height = t
            }
            get style() {
                return this._style
            }
            set style(t) {
                this._style !== t && ((t = t || {})instanceof yr ? (this.ownsStyle = !1,
                this._style = t) : t instanceof Ce ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"),
                this.ownsStyle = !0,
                this._style = yr.from(t)) : (this.ownsStyle = !0,
                this._style = new yr(t)),
                this.localStyleID = -1,
                this.dirty = !0)
            }
            get text() {
                return this._text
            }
            set text(t) {
                t = String("" === t || null == t ? " " : t),
                t = this.sanitiseText(t),
                this._text !== t && (this._text = t,
                this.dirty = !0)
            }
            get resolution() {
                return this._resolution
            }
            set resolution(t) {
                this._autoResolution = !1,
                this._resolution !== t && (this._resolution = t,
                this.dirty = !0)
            }
            sanitiseText(t) {
                return t.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;")
            }
        }
        ;
        let xr = _r;
        xr.defaultDestroyOptions = {
            texture: !0,
            children: !1,
            baseTexture: !0
        },
        xr.defaultMaxWidth = 2024,
        xr.defaultMaxHeight = 2024,
        xr.defaultAutoResolution = !0
    }
}]);
